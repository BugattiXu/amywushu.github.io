<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amywushu</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://amywushu.github.io/"/>
  <updated>2016-12-07T11:50:21.980Z</updated>
  <id>https://amywushu.github.io/</id>
  
  <author>
    <name>Amywushu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARC 是如何进行内存管理的</title>
    <link href="https://amywushu.github.io/2016/12/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-ARC-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84.html"/>
    <id>https://amywushu.github.io/2016/12/07/基础知识-ARC-是如何进行内存管理的.html</id>
    <published>2016-12-06T16:00:00.000Z</published>
    <updated>2016-12-07T11:50:21.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>任重而道远，不过进一寸便有进一寸的欢喜。</p>
</blockquote>
<h2 id="基础知识提要"><a href="#基础知识提要" class="headerlink" title="基础知识提要"></a>基础知识提要</h2><p>对于 Objective-C 对象来讲，手动内存管理主要是通过以下方法来进行的：   </p>
<ul>
<li>retain ：　　 　使得对象的引用计数+1</li>
<li>release：　　　使得对象的引用计数-1</li>
<li>autorelease：　使得对象的引用计数在 autorelease pool 释放的时候再-1</li>
<li>dealloc：　　　当对象的引用计数为0的时候自动调用，表明对象被释放</li>
</ul>
<a id="more"></a>
<p>因为只有 OC 对象是分配在堆上的（其他如 C 语言对象是分配在栈上的），因此也<strong>只有 OC 对象在未开启 ARC 的时候需要我们手动管理内存。</strong></p>
<p>对象的计数器，用来表示当前有多少个事物想令此对象继续存活下去。</p>
<h2 id="对象的内存管理"><a href="#对象的内存管理" class="headerlink" title="对象的内存管理"></a>对象的内存管理</h2><h3 id="简单内存管理示例"><a href="#简单内存管理示例" class="headerlink" title="简单内存管理示例"></a>简单内存管理示例</h3><p>　　简单的手动内存管理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ARC 无效</span></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="comment">//obj变量持有NSObject对象，该对象的引用计数=1</span></div><div class="line"></div><div class="line">[obj <span class="keyword">retain</span>];</div><div class="line"><span class="comment">//NSObject对象的引用计数+1 = 2</span></div><div class="line"></div><div class="line">[obj release];</div><div class="line"><span class="comment">//NSObject对象的引用计数-1 = 1</span></div><div class="line"></div><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">//创建自动释放池</span></div><div class="line"></div><div class="line">[obj autorelease];</div><div class="line"><span class="comment">//NSObject对象加入自动释放池，引用计数+1 = 2</span></div><div class="line"></div><div class="line">[pool drain];</div><div class="line"><span class="comment">//自动释放池释放，对池中的所有对象发送 release 消息，因此NSObject对象引用计数-1 = 1</span></div><div class="line"></div><div class="line">[obj release];</div><div class="line"><span class="comment">//NSObject对象的引用计数-1 = 0</span></div><div class="line"><span class="comment">//自动调用 dealloc 方法，废弃对象</span></div></pre></td></tr></table></figure>
<p>　　<br>　　对应的 ARC 自动管理：<br>　　因为开启 ARC 后，编译器会自动对 OC 对象进行内存管理，所以，ARC 有效时，不能调用 retain /release /autorelease /dealloc /retainCount 方法，其中，dealloc 方法可以覆写，但依然不能显示调用。   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//启用 ARC</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="comment">//obj变量持有NSObject对象，该对象的引用计数=1</span></div><div class="line"></div><div class="line">	<span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">		<span class="keyword">id</span> __autoreleasing obj2 = obj;</div><div class="line">		<span class="comment">//obj变量将NSObject对象赋给带有__autoreleasing关键字的obj2变量，相当于[obj autorelease]；</span></div><div class="line">		<span class="comment">//NSObject对象加入自动释放池，引用计数+1 = 2</span></div><div class="line"></div><div class="line">	&#125; <span class="comment">//自动释放池释放，对池中的所有对象发送 release 消息，因此NSObject对象引用计数-1 = 1</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//NSObject对象的持有者obj变量超出其作用域，引用失效</span></div><div class="line"><span class="comment">//因此，NSObject对象的引用计数-1 = 0</span></div><div class="line"><span class="comment">//自动调用 dealloc 方法，废弃对象</span></div></pre></td></tr></table></figure>
<h3 id="ARC-对象所有权修饰符"><a href="#ARC-对象所有权修饰符" class="headerlink" title="ARC 对象所有权修饰符"></a>ARC 对象所有权修饰符</h3><ul>
<li>__strong： 默认修饰符，表示对对象的“强引用”，该修饰符修饰的变量在超出其作用域时被废弃，随着强引用的失效，自动 release 自己所持有的对象；</li>
<li>__weak： 弱引用。不持有对象，若该对象被废弃，则弱引用变量将自动赋值为 nil；</li>
<li>__unsafe_unretained： 同 __weak 一样不持有对象，但对象废弃时，不会自动为 nil，容易出现悬挂指针；</li>
<li>__autoreleasing： 相当于调用 autorelease 方法，即对象被注册到 autorelease pool 中。</li>
</ul>
<p><strong>什么叫做持有对象？</strong><br>　　我们知道 OC 对象的变量类型其实是指针变量，这些指针存储在栈上，指针指向的对象存储在堆中。<br>&emsp;&emsp;指针 X1 指向对象 A，并使得对象 A 的引用计数+1，则我们说指针变量 X1 持有对象 A，或者 X1 持有该对象的强引用。<br>&emsp;&emsp;指针 X2 虽然指向对象 A，但是对对象 A 的引用计数没有任何影响，即 X2 不指向对象 A，对象 A 的引用计数也不会减1；X2 指向对象 A，对象 A 的引用计数也不会加1，则我们说指针变量 X2 不持有对象 A。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//启用 ARC</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj_weak = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj_unsafe;</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="comment">//obj变量默认加了__strong修饰符，所以是强引用，持有NSObject对象，该对象的引用计数+1 =1</span></div><div class="line">	</div><div class="line">	obj_weak = obj0;</div><div class="line">	<span class="comment">//obj1持有NSObject对象的弱引用，对引用计数无影响</span></div><div class="line"></div><div class="line">	obj_unsafe = obj0;</div><div class="line">	<span class="comment">//obj_unsafe不持有NSObject对象，对引用计数无影响</span></div><div class="line"></div><div class="line">	<span class="keyword">id</span> obj_strong = obj0;</div><div class="line">	<span class="comment">//obj3变量默认加了__strong修饰符，是强引用，NSObject对象的引用计数+1 = 2</span></div><div class="line"></div><div class="line">	<span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">		<span class="keyword">id</span> __autoreleasing obj_auto = obj0;</div><div class="line">		<span class="comment">//obj变量将NSObject对象赋给带有__autoreleasing关键字的obj_auto变量，相当于[obj autorelease]；</span></div><div class="line">		<span class="comment">//obj_auto暂时持有NSObject对象，稍后释放；</span></div><div class="line">		<span class="comment">//NSObject对象被暂时持有，加入自动释放池，引用计数+1 = 3</span></div><div class="line"></div><div class="line">	&#125; <span class="comment">//自动释放池释放，obj_auto变量超出其作用域，持有对象失效，</span></div><div class="line">	  <span class="comment">//也就是自动释放池取消obj_auto变量对对象的暂时持有权，</span></div><div class="line">	  <span class="comment">//相当于对池中的NSObject对象发送 release 消息，因此对象引用计数-1 = 2</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//NSObject对象的持有者obj0变量超出其作用域，强引用失效，释放自己所持有的对象，NSObject对象的引用计数-1 = 1；</span></div><div class="line"><span class="comment">//持有者obj_storng变量超出作用域，强引用失效，释放自己所持有的对象，对象的引用计数-1 = 0；</span></div><div class="line"><span class="comment">//NSObject对象无持有者（即引用计数为0），自动调用 dealloc 方法，废弃对象；</span></div><div class="line"><span class="comment">//该对象的弱引用变量obj_weak失效，自动赋值为nil;</span></div><div class="line"><span class="comment">//obj_unsafe变量表示的对象已被废弃，变为悬挂指针。</span></div></pre></td></tr></table></figure>
<p><br><br><strong>修饰符番外</strong><br>　　id 的指针或对象的指针会默认加上 __autoreleasing 修饰符，如<code>NSError **error</code>，实际上为<code>NSError *__autoreleasing* error</code>。</p>
<p>&emsp;&emsp;对象被废弃时，含有 __weak 修饰符的变量将会有以下动作：<br>1) 从 weak 表中获取以废弃对象的地址为键值的记录；<br>2) 将包含在记录中的所有 __weak 修饰符变量的地址，赋值为 nil；<br>3) 从 weak 表中删除记录；<br>4) 从引用计数表中删除以被废弃对象的地址为键值的记录。   </p>
<p>　　也就是说含有 __weak 修饰符的变量所指的对象被废弃时，会比其他修饰符多执行前3步，如果大量使用 weak 修饰符，则会消耗相应的 CPU 资源，因此<strong>最好是在需要避免循环引用的时候才使用 __weak 修饰符。</strong></p>
<p>在访问有 __weak 修饰符的变量时，其实会访问注册到 autorelease pool 的对象。</p>
<pre><code>
{
    id __weak obj1 = obj;
}

//实际上为：
id obj1;
objc_initWeak(&obj1, obj);
objc_destroyWeak(&obj1);
</code></pre>

<pre><code>
{
    id __weak obj2 = obj;
    NSLog(@"%@", obj2);
}


//实际上为：
id obj2;
objc_initWeak(&obj2, obj);

id tmp = objc_loadWeakRetained(&obj2);
objc_autorelease(tmp);

NSLog(@"%@", tmp);

objc_destroyWeak(&obj2);
</code></pre>

<p>　　在 @autoreleasepool 块结束之前，使用多少次 weak 变量，就会注册到 autorelease pool 中多少次，所以在使用 __weak 修饰符的变量时，最好赋值给 __strong 修饰符的变量后使用。</p>
<blockquote>
<p>可通过 <code>_objc_autoreleasePoolPrint()</code> 函数打印出注册到 autorelease pool 中的对象。</p>
</blockquote>
<h2 id="方法的内存管理"><a href="#方法的内存管理" class="headerlink" title="方法的内存管理"></a>方法的内存管理</h2><p>方法命名规则：    </p>
<ul>
<li>alloc/new/copy/mutableCopy 使用这些名称开头的方法，意味着生成的对象自己持有；</li>
<li>以上名称之外的其他方法取得的对象，自己不持有。</li>
</ul>
<p>注：以 <code>init</code> 开始的方法必须是实例方法，且必须要返回对象，该返回对象不注册到 autorelease pool 上，基本上只是对 alloc 方法返回值的对象进行初始化处理并返回该对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ARC 无效</span></div><div class="line">- (<span class="keyword">id</span>)allocObject</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)object</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	[obj autorelease];</div><div class="line">	<span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj1 = [obj0 allocObject];</div><div class="line">	<span class="comment">//alloc开头的方法返回自己生成并持有的对象，</span></div><div class="line">	<span class="comment">//即obj变量持有NSObject对象，该对象的引用计数至少=1</span></div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">id</span> obj2 = [obj0 object];</div><div class="line">	<span class="comment">//取得对象存在，但obj2变量不持有NSObject对象，</span></div><div class="line">	<span class="comment">//该对象的引用计数无变化</span></div><div class="line"></div><div class="line">	[obj2 <span class="keyword">retain</span>];</div><div class="line">	<span class="comment">//使得obj2持有对象，对象的引用计数+1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//启用ARC</span></div><div class="line">- (<span class="keyword">id</span>)object</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="keyword">return</span> obj；</div><div class="line">	<span class="comment">//因为return使得变量obj超出作用域，所以强引用失效，自己持有的对象会被释放，</span></div><div class="line">	<span class="comment">//但是因为该对象是作为方法的返回值，所以ARC会自动将其注册到autorelease pool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　也就是说<strong>对于非自己持有的方法，比如 [NSMutableArray array] 方法，在其方法内部，自动为返回值添加了 autorelease，我们可以使用这个返回值，但并不持有返回值所指的对象。</strong>在其对应的 autorelease pool 释放时（在主线程中，就是 RunLoop 循环一次之后），返回值所指的对象即被释放，如果没有对返回值执行 retain 操作，则对象没有持有者，自动调用 dealloc 方法，被废弃。</p>
<p>　　我们常说，ARC 有效时，编译器会自动插入 retain/release/autorelease 方法。但实际上，<strong>ARC 在调用这些方法时，并不是通过普通的 OC 消息派发机制，而是直接调用底层 C 语言版本</strong>，比如 ARC 会调用与 retain 等价的底层函数 objc_retain。这样做更能能优化性能，也是不能覆写 retain、release、autorelease 方法的原因，因为这些方法不会被直接调用。</p>
<p>　　ARC 的优化还体现在很多方面，如使用非自己持有的方法，我们可以看到，在方法内部的返回对象调用 autorelease，与方法返回后，在调用方对返回对象 retain，两个操作实际上是可以抵消的，ARC 会自动做这方面的优化。以 [NSMutableArray array] 为例：</p>
<pre code="">
// ARC 代码
+ (id)array
{
    return [[NSMutableArray alloc] init];
}

//编译器的模拟代码
+ (id)array
{
    id obj = objc_msgSend(NSMutableArray, @selector(alloc));
    objc_msgSend(obj, @selector(init));
    return objc_autoreleaseReturnValue(obj);
}

// ARC 代码
{
    id obj = [NSMutableArray array];
    //obj默认为 __strong 修饰符变量，相当于[返回对象 retain]
}

//编译器的模拟代码
id obj = objc_msgSend(NSMutableArray, @selector(array));

objc_retainAutoreleasedReturnValue(obj);

objc_release(obj);

</pre>

<p>　　<code>objc_autoreleaseReturnValue</code> 函数会检查使用该函数的方法，或函数调用方的执行命令列表，如果方法的调用方在调用了该方法后，紧接着调用了 <code>objc_retainAutoreleasedReturnValue()</code> 函数，那么就不将返回的对象注册到 autorelease pool 中，而是直接传递到方法的调用方。</p>
<h2 id="Block-的内存管理"><a href="#Block-的内存管理" class="headerlink" title="Block 的内存管理"></a>Block 的内存管理</h2><p>Block 的内存管理主要涉及到循环引用的问题。</p>
<p>Block 的创建一般是在栈上，但以下情况会被复制到堆上：<br>1) 调用 Block 的 copy 方法时；<br>2) Block 作为函数返回指时；<br>3) 将 Block 赋值给 __strong 修饰符的 id 类型或 Block 类型的成员变量时；<br>4) 在方法名中含有 usingBlock 的 Cocoa 框架方法或 GCD 的 API 中传递 Block 时。    </p>
<p>我们知道 Block 会在声明时截获在 Block 内部将会用到的变量，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">	<span class="keyword">void</span> (^blk) (<span class="keyword">void</span>) = ^&#123;printf(val);&#125;;</div><div class="line">	val = <span class="number">20</span>;</div><div class="line">	blk();</div><div class="line"><span class="comment">//输出结果：10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="strong-变量"><a href="#strong-变量" class="headerlink" title="__strong 变量"></a>__strong 变量</h3><p>　　对于 OC 对象而言，当 Block 从栈上被复制到堆上时，会对将要用到的带有 __strong 修饰符的变量执行 retain 操作，也就是 Block 会持有这个变量所指向的对象。如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启 ARC</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^blk_t)(<span class="keyword">id</span>);</div><div class="line">blk_t blk;</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">	blk = ^(<span class="keyword">id</span> obj) &#123;</div><div class="line">		[array addObject:obj];</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"count = %ld"</span>, [array count]);</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//array超出作用域，变量被废弃，</span></div><div class="line"> <span class="comment">//但blk持有array所指向的对象，所以对象不会被废弃</span></div><div class="line"></div><div class="line">blk([[<span class="built_in">NSObject</span> alloc] init]);</div><div class="line">blk([[<span class="built_in">NSObject</span> alloc] init]);</div><div class="line"></div><div class="line"><span class="comment">//输出： count = 1</span></div><div class="line"><span class="comment">//      count = 2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li>开启 ARC 时，对于修饰符为 __strong 且捕获了外部变量（无论是否是 OC 对象）的 Block，会自动进行 copy 操作，将 Block 从栈上复制到堆上，由 NSStackBlock 转换为 NSMallocBlock。</li>
<li>修饰符为 __strong 但未捕获外部变量的 Block，或者通过声明全局变量来声明 Block，都会自动创建为 NSGlobalBlock 类型。</li>
<li>无法手动创建堆上的 Block，即 NSMallocBlock。</li>
</ul>
<p>　　上述代码中 array 变量超出了作用域因此被废弃，但是 blk 调用的时候仍可以使用 array 是为什么呢？<br>　　是因为 Block 在进行 copy 操作的时候，会在自身结构体中添加一个同类型的 __strong 修饰符的 array 变量，所以访问的并不是之前我们所定义的 <code>id array</code>，而是 <code>block-&gt;array</code>。</p>
<h3 id="block-变量"><a href="#block-变量" class="headerlink" title="__block 变量"></a>__block 变量</h3><p>　　__block 修饰符的变量可以在 Block 中更改变量，Block 在捕获变量时，会对有该修饰符的变量生成 __Block_byref_val 结构体。</p>
<pre><code>
__block val =10;

//在 Block 中存储为结构体
__Block_byref_val_0 val = {
    void *__isa;
    __Block_byref_val_0 *__forwarding;  //= &val
    int __flags;
    int __size; //=sizeof(__Block_byref_val_0)
    int val; //=10
}
</code></pre>

<p>　　__Block_byref_val 结构体的成员变量 __forwarding 是指向该结构体实例自身的指针。Block 在访问__block 修饰的变量时，是通过这个指针来的：<br>　　<code>block -&gt;val(block结构体中的成员变量)-&gt;__forwarding-&gt;val</code>。<br>当 Block 从栈复制到堆上是，该变量也会复制到堆上，栈上的原来指向自身的 __forwarding 指针会改变为指向堆上的 __block 变量。</p>
<p>　　因此 __block 修饰的变量在 ARC 和非 ARC 中是有差别的。</p>
<p>　　ARC 有效时，__block 变量除了可以在 Block 内部修改之外，无其他用处，是否 retain 取决于变量的 ARC 修饰符（__strong 持有、__weak 不持有等）。那么由于可修改，因此<strong>可以在 Block 内部对造成循环引用的变量赋值为 nil，释放掉自身的对象持有权，从而打破循环。</strong></p>
<p>　　ARC 无效时，在 [block copy] 之后，没有__block 修饰符的变量对象会被自动后台 retain，从而被 Block 持有；而有__block 修饰符的变量反而不会被 retain，不会被 Block 持有。因此<strong>对变量添加 __block 修饰符可以在非 ARC 情况下打破循环引用。</strong></p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>既然 Block 也会持有对象，那么就很容易出现不易发现的循环引用问题了。如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启 ARC</span></div><div class="line">- (<span class="keyword">void</span>)loadView </div><div class="line">&#123; </div><div class="line"></div><div class="line"> [<span class="keyword">super</span> loadView]; </div><div class="line"></div><div class="line"> _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span> </div><div class="line"> object:<span class="literal">nil</span> </div><div class="line"> queue:<span class="literal">nil</span> </div><div class="line"> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123; </div><div class="line"> [<span class="keyword">self</span> dismissModalViewControllerAnimated:<span class="literal">YES</span>]; </div><div class="line"> &#125;]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如之前所提到的 Blcok 被复制到堆上的情况，<code>在使用方法名中含有 usingBlock 的 Cocoa 框架方法</code>时会被自动 copy 到堆上，从而对捕获到的 <code>__strong 变量</code> 执行 retain 操作，Block 持有该变量。</p>
<p>&emsp;&emsp;在本例中，self 的成员变量 _observer 会 <code>copy 一份 Block</code>，从而持有 Block，而 Block 中用到了默认为 <code>__strong 修饰符的 self变量</code> ，从而持有 self，self 类本身又持有 <code>成员变量 _observer</code>，从而导致循环引用，使得谁都无法被最终释放，导致内存泄漏。</p>
<p>所以，要打破这种循环引用，需要使得 [block copy] 时不会 retain 捕获到的 self 变量。</p>
<h4 id="方法一：-在-ARC-中使用不持有对象的-weak-或-unsafe-unretain-修饰符"><a href="#方法一：-在-ARC-中使用不持有对象的-weak-或-unsafe-unretain-修饰符" class="headerlink" title="方法一： 在 ARC 中使用不持有对象的 __weak 或 __unsafe_unretain 修饰符"></a>方法一： 在 ARC 中使用不持有对象的 <code>__weak</code> 或 <code>__unsafe_unretain</code> 修饰符</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启 ARC</span></div><div class="line">- (<span class="keyword">void</span>)loadView </div><div class="line">&#123; </div><div class="line"> [<span class="keyword">super</span> loadView];</div><div class="line"> </div><div class="line"> __<span class="keyword">weak</span> TestViewController *wself = <span class="keyword">self</span>; </div><div class="line"></div><div class="line"> _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span> </div><div class="line"> object:<span class="literal">nil</span> </div><div class="line"> queue:<span class="literal">nil</span> </div><div class="line"> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123; </div><div class="line"></div><div class="line"> __<span class="keyword">strong</span> TestViewController *sself = wself;</div><div class="line"> </div><div class="line"> [sself dismissModalViewControllerAnimated:<span class="literal">YES</span>]; </div><div class="line"> &#125;]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于拥有 __weak 修饰符的 wself 变量，Block 复制时，不会对该变量指向的对象进行 retain，从而不持有该对象，对该对象的引用计数无影响。在 Block 内部又通过 __strong 修饰符的 sself 变量来持有对象，是为了避免在 Block 执行过程中，该对象被其他地方释放，从而造成访问错误。这实际上是一种延迟 self 的 retain 操作，使得它不在 Block 被 copy 的时候 retain，而是在执行的时候 retain。</p>
<p>&emsp;&emsp;因为如果在最初 copy 的时候 retain，那么只有等 Block 被废弃时，该变量才会被废弃，从而释放对对象 X 的持有权。但是由于循环引用，该变量始终直接或间接的持有 block 对象，所以 Block 永远不会被废弃，进而也不会释放对象 X 的持有权，从而造成这两块内存永远不会被回收，即内存泄漏。</p>
<p>&emsp;&emsp;而在执行的时候 retain，ARC会对 Block 的执行作用域的变量自动进行内存管理，执行完毕后即释放，不会等到 Block 被废弃时才能被释放，因此打破了循环引用。</p>
<h4 id="方法二：在-ARC-中使用-block-修饰符，并在-Block-中为其赋值为-nil"><a href="#方法二：在-ARC-中使用-block-修饰符，并在-Block-中为其赋值为-nil" class="headerlink" title="方法二：在 ARC 中使用 __block 修饰符，并在 Block 中为其赋值为 nil"></a>方法二：在 ARC 中使用 <code>__block 修饰符，并在 Block 中为其赋值为 nil</code></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启 ARC</span></div><div class="line">- (<span class="keyword">void</span>)loadView </div><div class="line">&#123; </div><div class="line"> [<span class="keyword">super</span> loadView];</div><div class="line"> </div><div class="line"> __blok TestViewController *wself = <span class="keyword">self</span>; </div><div class="line"></div><div class="line"> _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span> </div><div class="line"> object:<span class="literal">nil</span> </div><div class="line"> queue:<span class="literal">nil</span> </div><div class="line"> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</div><div class="line"> [wself dismissModalViewControllerAnimated:<span class="literal">YES</span>]; </div><div class="line"> &#125;]; </div><div class="line"></div><div class="line"> wself = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在 Block 执行时释放了对 self 所指向的对象的持有权，因此 Block 执行后即打破循环引用，同样不会等到 Block 被废弃时才能释放对象的持有权，因为没有内存泄漏。</p>
<p>&emsp;&emsp;这种方法的缺点是，一定要确保 Block 会执行。如果有多种分支，而某一条分支中的 Block 不会执行，那么这条分支同样会造成内存泄漏。</p>
<h4 id="方法三：在非-ARC-中使用-block-修饰符"><a href="#方法三：在非-ARC-中使用-block-修饰符" class="headerlink" title="方法三：在非 ARC 中使用 __block 修饰符"></a>方法三：在非 ARC 中使用 <code>__block 修饰符</code></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ARC 无效</span></div><div class="line">- (<span class="keyword">void</span>)loadView </div><div class="line">&#123; </div><div class="line"> [<span class="keyword">super</span> loadView];</div><div class="line"> </div><div class="line"> __blok TestViewController *wself = <span class="keyword">self</span>; </div><div class="line"></div><div class="line"> _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span> </div><div class="line"> object:<span class="literal">nil</span> </div><div class="line"> queue:<span class="literal">nil</span> </div><div class="line"> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</div><div class="line"> [wself dismissModalViewControllerAnimated:<span class="literal">YES</span>]; </div><div class="line"> &#125;]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在非 ARC 中，Block 不持有 __block 修饰符修饰的对象，因此也不会造成循环引用。</p>
<p>注1：在使用委托 delegate 时，属性要用 weak 关键字也是为了避免循环引用。<br>注2：在异常 <code>NSException</code> 处理过程中，也容易遗忘对象释放，从而造成内存泄漏，一般须在 <code>@finally</code> 中将未释放的资源释放掉。当然如果该异常直接造成程序崩溃，也就无所谓释放不释放了。</p>
<p>以上即是 ARC 与非 ARC 的内存管理区别，以及 ARC 是如何将手动管理转换为自动管理的。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] 《Objective-C 高级编程 - iOS 与 OS X 多线程和内存管理》<br>[2] 《Effective Objective-C 2.0》<br>[3]&ensp;Objective-C中block实现和技巧学习　<a href="http://www.tuicool.com/articles/aQFV7bv" target="_blank" rel="external">http://www.tuicool.com/articles/aQFV7bv</a></p>
<p><strong>声明: 本文转载需标明出处，禁止用于商业目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;任重而道远，不过进一寸便有进一寸的欢喜。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础知识提要&quot;&gt;&lt;a href=&quot;#基础知识提要&quot; class=&quot;headerlink&quot; title=&quot;基础知识提要&quot;&gt;&lt;/a&gt;基础知识提要&lt;/h2&gt;&lt;p&gt;对于 Objective-C 对象来讲，手动内存管理主要是通过以下方法来进行的：   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;retain ：　　 　使得对象的引用计数+1&lt;/li&gt;
&lt;li&gt;release：　　　使得对象的引用计数-1&lt;/li&gt;
&lt;li&gt;autorelease：　使得对象的引用计数在 autorelease pool 释放的时候再-1&lt;/li&gt;
&lt;li&gt;dealloc：　　　当对象的引用计数为0的时候自动调用，表明对象被释放&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础知识" scheme="https://amywushu.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="ARC" scheme="https://amywushu.github.io/tags/ARC/"/>
    
      <category term="内存管理" scheme="https://amywushu.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>通过汇编解读 objc_msgSend</title>
    <link href="https://amywushu.github.io/2016/11/09/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86-%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB-objc_msgSend.html"/>
    <id>https://amywushu.github.io/2016/11/09/逆向知识-通过汇编解读-objc_msgSend.html</id>
    <published>2016-11-08T16:00:00.000Z</published>
    <updated>2016-12-07T08:49:33.672Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>想做一条瀑布，每一秒钟都可以跳楼。</p>
</blockquote>
<h2 id="基础知识提要"><a href="#基础知识提要" class="headerlink" title="基础知识提要"></a>基础知识提要</h2><p>调用方法，本质是发送消息。比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person *p = [[Person alloc] init];</div><div class="line">[p test];</div><div class="line"></div><div class="line"><span class="comment">// 本质是发送消息： clang -rewrite-objc main.m</span></div><div class="line">((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)p, sel_registerName(<span class="string">"test"</span>));</div></pre></td></tr></table></figure>
<p>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个，<br>objc_msgSend、 objc_msgSend_stret、 objc_msgSendSuper 和 objc_msgSendSuper_stret。 </p>
<a id="more"></a>
<blockquote>
<ul>
<li>发送给对象的父类的消息会使用 objc_msgSendSuper ;   </li>
<li>有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret ;   </li>
<li>其它的消息都是使用 objc_msgSend 发送的。</li>
</ul>
</blockquote>
<p>也就是说所有的方法调用，都是通过 objc_msgSend（或其大类）来实现转发的。</p>
<p>objc_msgSend 的具体实现由汇编语言编写而成，不同平台有不同的实现，objc-msg-arm.s、objc-msg-arm64.s、objc-msg-i386.s、objc-msg-simulator-i386.s、objc-msg-simulator-x86_64.s、objc-msg-x86_64.s。<br>本文以 ARM64 平台为例。</p>
<h2 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h2><h3 id="汇编概览"><a href="#汇编概览" class="headerlink" title="汇编概览"></a>汇编概览</h3><p>如下图所示：</p>
<p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/objc_msgSend1.png" alt=""></p>
<h3 id="流程图分析"><a href="#流程图分析" class="headerlink" title="流程图分析"></a>流程图分析</h3><h4 id="分支1：X0-0"><a href="#分支1：X0-0" class="headerlink" title="分支1：X0 = 0"></a>分支1：X0 = 0</h4><p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/objc_msgSend2.png" alt=""></p>
<p>这条分支很简单，对照图1的总图来讲，就是蓝色的那条线，第1行-&gt;第2行-&gt; 29 -&gt; 35~41 ret。<br>先对传入的 X0（即对象地址）作判断，如果 X0=0，则直接返回。</p>
<h4 id="分支2：X0-lt-0-Tagger-Pointer"><a href="#分支2：X0-lt-0-Tagger-Pointer" class="headerlink" title="分支2：X0 &lt; 0 (Tagger Pointer)"></a>分支2：X0 &lt; 0 (Tagger Pointer)</h4><p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/objc_msgSend3.png" alt=""></p>
<p>对照图1来讲，流程为黄色的那根线，1~2 -&gt; 29~34 -&gt; 6 -&gt; …</p>
<p>判断 X0&lt;0，即地址最高位为1，这是 Tagger Pointer 类型的标志（对于 ARM64 架构来讲），关于这个类型，部分内容在我之前的文章<a href="https://amywushu.github.io/2016/10/20/%E8%AF%AD%E6%B3%95-copy-%E4%B8%8E-mutableCopy%EF%BC%88%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89.html">copy 与 mutableCopy（传说中的深浅拷贝）</a>中5.4节有提到。</p>
<p>loc_1800b9c30 这个模块取出了 Tagger Pointer 的类索引表，赋值给 X10。<br>下一行 <code>UBFM  X11,X0,#0x3C,#0x3F</code>，取 0x3C~0x3F 中的值赋给 X11，其余位以0填充，与图1第32行的意思相同，都是取出最高4位，比如 NSString 类型的 Tagger Pointer 最高4位为 a，运算过后，x11 = 0xa 。<br>接着 <code>LDR  X9,[X10,X11,LSL#3]</code>，先运算 X11 左移3位等于 0x50。x9 = x10[0x50]，也就是在类索引表中查找所属类。找到后跳到 loc_1800b9BD0，也就是图1中的第6行。</p>
<h4 id="分支3：X0-gt-0"><a href="#分支3：X0-gt-0" class="headerlink" title="分支3：X0 &gt; 0"></a>分支3：X0 &gt; 0</h4><p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/objc_msgSend4.png" alt=""></p>
<p>这是大多数情况会走的流程。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类的结构</span></div><div class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</div><div class="line">    <span class="comment">// Class ISA;       //继承自objc_object</span></div><div class="line">    Class superclass; 	<span class="comment">// 父类引用</span></div><div class="line">    cache_t cache;		<span class="comment">// 用来缓存指针和虚函数表</span></div><div class="line">    class_data_bits_t bits; <span class="comment">// class_rw_t 指针加上 rr/alloc 标志</span></div><div class="line">&#125;</div></pre></td></tr></table></figure> 
<p>接下来我们根据汇编指令一条条来分析。<br><code>LDR  X13,[X0]</code> 取出调用方法的对象指针保存的地址（从上面代码可以看出，就是 isa 指针地址），赋给 X13。 </p>
<p><code>AND  X9,X13,#0x1FFFFFFF8</code> 解读这条指令之前，要先了解 isa 指针的结构。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> isa_t &#123;</div><div class="line">    isa_t() &#123; &#125;</div><div class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</div><div class="line">    Class cls;</div><div class="line">    uintptr_t bits;</div><div class="line">    <span class="keyword">struct</span> &#123;</div><div class="line">        uintptr_t indexed           : <span class="number">1</span>;</div><div class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</div><div class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</div><div class="line">        uintptr_t shiftcls          : <span class="number">33</span>; </div><div class="line">        uintptr_t magic             : <span class="number">6</span>;</div><div class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</div><div class="line">        uintptr_t deallocating      : <span class="number">1</span>;</div><div class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</div><div class="line">        uintptr_t extra_rc          : <span class="number">19</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先先来看一下这 64 个二进制位每一位的含义：</p>
<table>
<thead>
<tr>
<th>区域名</th>
<th style="text-align:center">代表信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>indexed (0位)</td>
<td style="text-align:center">0 表示普通的 isa 指针，1 表示使用优化，存储引用计数</td>
</tr>
<tr>
<td>has_assoc (1、2位)</td>
<td style="text-align:center">表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快</td>
</tr>
<tr>
<td>shiftcls (3~35位)</td>
<td style="text-align:center">类的指针</td>
</tr>
<tr>
<td>magic (36~41位)</td>
<td style="text-align:center">固定值，用于在调试时分辨对象是否未完成初始化</td>
</tr>
<tr>
<td>weakly_referenced (42位)</td>
<td style="text-align:center">表示该对象是否有过 weak 对象，如果没有，则析构时更快</td>
</tr>
<tr>
<td>deallocating (43位)</td>
<td style="text-align:center">表示该对象是否正在析构</td>
</tr>
<tr>
<td>has_sidetable_rc (44位)</td>
<td style="text-align:center">表示该对象的引用计数值是否过大无法存储在 isa 指针</td>
</tr>
<tr>
<td>extra_rc (45~63位)</td>
<td style="text-align:center">存储引用计数值减一后的结果</td>
</tr>
</tbody>
</table>
<p>也就是说 0x1FFFFFFF8 取1的位数刚好是 shiftcls 的区域，是 isa 指针中存储的该对象的类指针。所以 X9 = isa-&gt;cls。</p>
<p><code>LDP  X10,X11,[X9,#0X10]</code>： X9+16个字节，也就是跳过了8个字节的 isa 指针，和8个字节的 superclass 指针，到了 cache 指针这里。 cache 的结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> bucket_t &#123;</div><div class="line">    <span class="keyword">void</span> *sel;</div><div class="line">    <span class="keyword">void</span> *imp;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> cache_t &#123;</div><div class="line">    <span class="keyword">struct</span> bucket_t *buckets;</div><div class="line">    mask_t mask;</div><div class="line">    mask_t occupied;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>因此，X10=buckets 指针，X11 的低32位为 mask，高32位为 occupied（mask_t 是 int 类型）。 occupied是 cache 中实际拥有的方法个数。</p>
<p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/objc_msgSend5.png" alt=""></p>
<p><code>AND  W12,W1,W11</code>： 将 _cmd 的低32位和 cache-&gt;mask 作与运算。<br><code>ADD  X12,X10,X12,LSL#4</code>: 与运算后的结果左移4位，作为buckets的索引（相当于数组下标）。这里也可以看出 mask 的作用，应该是一种优化的 hash 表搜索算法。将取得的指针赋给 X12。<br><code>LDP  X16,X17,[X12]</code>： 由 bucket 的结构可以知道，这里是将 bucket [(_cmd&amp;mask)&lt;&lt;4] 中的 sel 赋给 X16，imp 赋给 X17（imp 为方法的入口地址）。<br>这三条指令就是通过 mask 找到一个 bucket 元素。</p>
<p><code>CMP  X16,X1</code>,  <code>B.NE  loc_1800B9BEC</code>,  <code>BR  X17</code>： 这3条指令很好理解，比较 bucket 元素中的 sel 和 _cmd 的值是否相等，不相等，则跳到 loc_1800B9BEC 模块，相等则直接进入对应 imp（方法入口地址）。</p>
<p><code>loc_1800B9BEC  CBZ  X16,_objc_msgSend_uncached_impcache</code>： 如果 X16=0 则跳到 objc_msgSend_uncached 这个函数去，不等于0则继续执行。<br><code>CMP  X12,X10</code>,  <code>B.EQ  loc_1800B9C00</code>：  判断是否已搜索到最后一个 bucket（即 bucket 的初始地址），是则跳到 loc_1800B9C00，否则继续执行。</p>
<ul>
<li><p>先讨论没有搜索完的情况，<br><code>loc_1800B9C00  LDP  X16,X17,[X12,#-0X10]</code>,  <code>B  loc_1800B9BE0</code>： bucket 元素减16字节，即跳到前一个 bucket 元素，同样将 sel 和 imp 指针赋值，然后跳回与 _cmd 比较的那条指令循环。</p>
</li>
<li><p>直到搜索完毕，<br><code>ADD  X12,X12,W11,UXTW #4</code>： x12 = buckets+(mask&lt;&lt;4)，扩大搜索范围，在缓存内全面搜索。（进行到这一步，说明 bucket [(_cmd&amp;mask)&lt;&lt;4] 元素之前的 bucket 已全部被占满，且均不是我没要找的方法）<br><code>LDP  X16,X17,[X12]</code>： 跟之前的命令意思一样。</p>
</li>
</ul>
<p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/objc_msgSend6.png" alt=""></p>
<p>可以看到，之后的流程跟前面的循环一模一样，但是加大了搜索范围，从 bucket [mask&lt;&lt;4] 往前开始搜索（进行到这一步说明 bucket [(_cmd&amp;mask)&lt;&lt;4] 前面的缓存都占满了）。从以上分析，我们可以看出，<strong>能在缓存 cache 里找到的方法，会直接跳到入口地址 X17。</strong>而没有在 cache 里的方法，则要继续调用 objc_msgSend_uncached 函数。现在，返回图1再查看，是不是觉得思路清晰很多呀！</p>
<h4 id="关于缓存-cahce"><a href="#关于缓存-cahce" class="headerlink" title="关于缓存 cahce"></a>关于缓存 cahce</h4><p>cache 的原则是缓存那些可能要执行的函数地址。 </p>
<blockquote>
<p>有一种说法是，只要函数执行过一次的方法，都会存入缓存。但在我的测试中，有时候会遵循这种说法，有时候又不尽然，执行过的方法不一定会被放入缓存，但没有被执行过的肯定不会进入缓存。具体什么样的操作会导致方法被载入缓存，还需要从类的初始化探讨起，此点存疑。    </p>
</blockquote>
<p>cahce 其实是一个 hash 表，通过 _cmd&amp;mask 的结果再左移4位，作为索引值，如果这个地址存的方法 _cmd2 与 _cmd 不同，那么有两种原因：一是 _cmd 压根儿没被载入缓存；二是由于它的索引值跟 _cmd 相同，但 _cmd2 先进入缓存，因此 _cmd2 占据了这个位置。这时，如果 _cmd 被载入缓存的话，则在 _cmd2 索引值-1的位置存入，如果这个位置也不为0，那么继续前往索引值-2的位置，直到找到一个0位，然后存入。</p>
<p>在上面的汇编分析中，我们也能看到这个思路。在图1中第8行，取 bucket 索引值；第10行，比较 _cmd 值；如果不同则第13行，查看是否为0，如果为0，则不再搜索，直接进入 uncache 函数（因为是0的话，由上一段分析可以知道，说明这个方法没有在缓存里）；如果不为0，则前往索引值-1（地址-16）的位置查找；第17行返回循环到第10行。</p>
<p>下面来做一个测试，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">aboutObjectiveC</span></span></div><div class="line">-(<span class="keyword">void</span>)objc_msgSend1 &#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"objc_msgSend1"</span>);</div><div class="line">	[<span class="keyword">self</span> objc_msgSend2];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)objc_msgSend1 &#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"objc_msgSend2"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/objc_msgSend7.png" alt=""></p>
<p>如上图所示，在 main.m 第17行下断点（即第二次执行 objc_msgSend1 方法时），si 进入 objc_msgSend 函数，然后执行到图1中的第7行，打印各值如下</p>
<p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/objc_msgSend8.png" alt=""></p>
<p>w11 是 mask 的值为0011，跟 init的 SEL(0x1883910b6) 指针作与运算，为0x2，左移4位为0x20，因此在 x10+0x20 处载入 cache；跟 objc_msgSend1 的 SEL(0x10008ecac) 作与运算，为0x0，左移4位还是0x0，因此在 x10 bucket 处载入 cache；同样对 objc_msgSend2 作与运算左移4位，也是0x20，而 bucket[0x20] 处已经被 init 占用了，因此前往 bucket[0x20-0x10] 处，这个位置是0，所以将 objc_msgSend2 填入缓存的这个位置。如下图所示：</p>
<p><img src="/images/2016-11-09-逆向知识-通过汇编解读-objc_msgSend/cache.png" alt=""></p>
<h4 id="lookUpImpOrForward-函数"><a href="#lookUpImpOrForward-函数" class="headerlink" title="lookUpImpOrForward 函数"></a>lookUpImpOrForward 函数</h4><p>我们已经知道如果缓存中没有找到该方法，则跳转执行 _objc_msgSend_uncached_impcache，在这里又会执行 bl _class_lookupMethodAndLoadCache3 指令，跳转到 _class_lookupMethodAndLoadCache3，由汇编语言的实现回到了 C 函数的实现，这个函数只是简单的调用了另外一个函数 lookUpImpOrForward，并传入参数 cache=NO，这个函数是 Runtime 消息机制中非常重要的一环。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="keyword">id</span> inst, </div><div class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</div><div class="line">&#123;</div><div class="line">    Class curClass;</div><div class="line">    IMP imp = <span class="literal">nil</span>;</div><div class="line">    Method meth;</div><div class="line">    <span class="keyword">bool</span> triedResolver = <span class="literal">NO</span>;</div><div class="line"></div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line"></div><div class="line">	<span class="comment">//因为 _class_lookupMethodAndLoadCache3 传入的 cache = NO，</span></div><div class="line">	<span class="comment">//所以这里会直接跳过 if 中代码的执行，</span></div><div class="line">	<span class="comment">//在 objc_msgSend 中已经使用汇编代码查找过了。 </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cache) &#123;</div><div class="line">        imp = cache_getImp(cls, sel);</div><div class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">//根据 cls-&gt;isRealized() 来判断是否要调用 realizeClass 函数在</span></div><div class="line">	<span class="comment">// Objective-C 运行时 初始化的过程中会对其中的类进行第一次初始化</span></div><div class="line">	<span class="comment">//也就是执行 realizeClass 方法，为类分配可读写结构体 class_rw_t</span></div><div class="line">	<span class="comment">//的空间，并返回正确的类结构体。</span></div><div class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</div><div class="line">        rwlock_writer_t lock(runtimeLock);</div><div class="line">        realizeClass(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">//根据 cls-&gt;isInitialized() 来判断类的是不是 initialized，</span></div><div class="line">	<span class="comment">//也就是类的首次被使用的时候，其 initialize 方法要在此时被调用</span></div><div class="line">	<span class="comment">//一次，也仅此一次。没有 initialized 的话，则调用</span></div><div class="line">	<span class="comment">//_class_initialize 函数去触发这个类的 initialize 方法，然后</span></div><div class="line">	<span class="comment">//会设置 isInitialized 状态为 initialized </span></div><div class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></div><div class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></div><div class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></div><div class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The lock is held to make method-lookup + cache-fill atomic </span></div><div class="line">    <span class="comment">// with respect to method addition. Otherwise, a category could </span></div><div class="line">    <span class="comment">// be added but ignored indefinitely because the cache was re-filled </span></div><div class="line">    <span class="comment">// with the old value after the cache flush on behalf of the category.</span></div><div class="line"> retry:</div><div class="line">    runtimeLock.read();</div><div class="line"></div><div class="line">    <span class="comment">// 是否开启GC(垃圾回收)；</span></div><div class="line">    <span class="keyword">if</span> (ignoreSelector(sel)) &#123;</div><div class="line">        imp = _objc_ignored_method;</div><div class="line">        cache_fill(cls, sel, imp, inst);</div><div class="line">        <span class="keyword">goto</span> done;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里再次查找 cache 是因为有可能 cache 真的又有了，因为锁的原因</span></div><div class="line">    imp = cache_getImp(cls, sel);</div><div class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line">    <span class="comment">// Try this class's method lists.</span></div><div class="line">    meth = getMethodNoSuper_nolock(cls, sel);</div><div class="line">    <span class="keyword">if</span> (meth) &#123;</div><div class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class="line">        imp = meth-&gt;imp;</div><div class="line">        <span class="keyword">goto</span> done;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Try superclass caches and method lists.</span></div><div class="line">    curClass = cls;</div><div class="line">    <span class="keyword">while</span> ((curClass = curClass-&gt;superclass)) &#123;</div><div class="line">        <span class="comment">// Superclass cache.</span></div><div class="line">        imp = cache_getImp(curClass, sel);</div><div class="line">        <span class="keyword">if</span> (imp) &#123;</div><div class="line">            <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</div><div class="line">                <span class="comment">// Found the method in a superclass. Cache it in this class.</span></div><div class="line">                log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Found a forward:: entry in a superclass.</span></div><div class="line">                <span class="comment">// Stop searching, but don't cache yet; call method </span></div><div class="line">                <span class="comment">// resolver for this class first.</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Superclass method list.</span></div><div class="line">        meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">        <span class="keyword">if</span> (meth) &#123;</div><div class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class="line">            imp = meth-&gt;imp;</div><div class="line">            <span class="keyword">goto</span> done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></div><div class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class="line">        runtimeLock.unlockRead();</div><div class="line">        _class_resolveMethod(cls, sel, inst);</div><div class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></div><div class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></div><div class="line">        triedResolver = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">goto</span> retry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></div><div class="line">    <span class="comment">// Use forwarding.</span></div><div class="line">    imp = (IMP)_objc_msgForward_impcache;</div><div class="line">    cache_fill(cls, sel, imp, inst);</div><div class="line"></div><div class="line"> done:</div><div class="line">    runtimeLock.unlockRead();</div><div class="line"></div><div class="line">    <span class="comment">// paranoia: look for ignored selectors with non-ignored implementations</span></div><div class="line">    assert(!(ignoreSelector(sel)  &amp;&amp;  imp != (IMP)&amp;_objc_ignored_method));</div><div class="line"></div><div class="line">    <span class="comment">// paranoia: never let uncached leak out</span></div><div class="line">    assert(imp != _objc_msgSend_uncached_impcache);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lookUpImpOrForward 主要做了以下几个工作</p>
<ul>
<li>判断类的初始化 cls-&gt;isRealized() 和 cls-&gt;isInitialized() ；</li>
<li>是否开启GC(垃圾回收)；</li>
<li>再次尝试去缓存中获取IMP；</li>
<li>找不到接着去 class 的方法列表查找，找到会加入缓存列表然后返回 IMP；</li>
<li>找不到，去父类的缓存列表找，然后去父类的方法列表找，找到了会加入自己的缓存列表，然后返回 IMP，找不到循环此步骤，直到找到基类；</li>
<li>都找不到则 _class_resolveMethod 函数会被调用，进入消息动态处理、转发阶段。</li>
</ul>
<p>对于 objc_msgSend 反汇编的分析就结束啦！如果是在动态调试过程中，遇到 objc_msgSend 想要进入被调用的方法的话，有 cache，则直接 si 进入 br X17，如果没有 cache，则在 _objc_msgSend_uncached_impcache 函数中最后几行中的 br X17 指令输入 si 即可进入被调用方法。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] ObjC Runtime（五）：消息传递机制　<a href="https://xiuchundao.me/post/runtime-messaging" target="_blank" rel="external">https://xiuchundao.me/post/runtime-messaging</a><br>[2] 从源代码看 ObjC 中消息的发送　<a href="http://draveness.me/message/" target="_blank" rel="external">http://draveness.me/message/</a><br>[3] objc_msgSend内部到底做了什么？　<a href="http://oriochan.com/14710029019312.html" target="_blank" rel="external">http://oriochan.com/14710029019312.html</a><br>[4] 用 isa 承载对象的类信息　<a href="http://www.desgard.com/isa/" target="_blank" rel="external">http://www.desgard.com/isa/</a><br>[5] 深入解析 ObjC 中方法的结构<br><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md" target="_blank" rel="external">https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md</a></p>
<p><strong>声明: 本文转载需标明出处，禁止用于商业目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;想做一条瀑布，每一秒钟都可以跳楼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础知识提要&quot;&gt;&lt;a href=&quot;#基础知识提要&quot; class=&quot;headerlink&quot; title=&quot;基础知识提要&quot;&gt;&lt;/a&gt;基础知识提要&lt;/h2&gt;&lt;p&gt;调用方法，本质是发送消息。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Person *p = [[Person alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[p test];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 本质是发送消息： clang -rewrite-objc main.m&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;((&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*)(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, SEL))(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)objc_msgSend)((&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)p, sel_registerName(&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个，&lt;br&gt;objc_msgSend、 objc_msgSend_stret、 objc_msgSendSuper 和 objc_msgSendSuper_stret。 &lt;/p&gt;
    
    </summary>
    
      <category term="逆向知识" scheme="https://amywushu.github.io/categories/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="逆向" scheme="https://amywushu.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="objc_msgSend" scheme="https://amywushu.github.io/tags/objc-msgSend/"/>
    
  </entry>
  
  <entry>
    <title>copy 与 mutableCopy（传说中的深浅拷贝）</title>
    <link href="https://amywushu.github.io/2016/10/20/%E8%AF%AD%E6%B3%95-copy-%E4%B8%8E-mutableCopy%EF%BC%88%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89.html"/>
    <id>https://amywushu.github.io/2016/10/20/语法-copy-与-mutableCopy（传说中的深浅拷贝）.html</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2016-12-07T08:39:54.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>光是永恒的，所以你是永恒的。</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对象拷贝有两种方式：浅拷贝和深拷贝。</p>
<p>浅拷贝(shallow copy)，并不拷贝对象本身，<strong>仅仅是拷贝指向对象的指针</strong>。<br>如果 <code>B = [A 浅拷贝]</code>，则 A、B 两个对象中都保存的同一个指针，如果 A 通过这个指针改变了指针指向的对象，那么 B 指针指向的对象也就随之改变了；</p>
<p>深拷贝是直接<strong>拷贝整个对象到另一块内存中</strong>，开辟新的地址来存储，两个对象至此一别，再无关联。</p>
<blockquote>
<p>对于集合对象（如 NSSArray、NSDictionary 等）而言，又有<strong>单层深拷贝</strong>与<strong>完全拷贝</strong>之分。</p>
<p>单层深拷贝(one-level-deep copy)：指的是对于被拷贝对象，至少有一层是深拷贝。<br>完全拷贝(real-deep copy)：指的是对于被拷贝对象的每一层都是对象拷贝。</p>
</blockquote>
<a id="more"></a>
<h2 id="copy-与-mutableCopy"><a href="#copy-与-mutableCopy" class="headerlink" title="copy 与 mutableCopy"></a>copy 与 mutableCopy</h2><p>不管是集合类对象，还是非集合类对象，接收到 copy 和 mutableCopy 消息时，都遵循以下准则：</p>
<ul>
<li>copy 返回不可变(imutable)对象，如果对copy返回值使用可变对象方法就会crash；</li>
<li>mutablCopy 默认返回可变(mutable)对象（如果拷贝后的对象本身是不可变的，那也没法变呀，总不能改变人对象的类型吧，比如 <code>NSString *str2 = [str1 mutableCopy];</code> ）。</li>
</ul>
<h2 id="示例头文件"><a href="#示例头文件" class="headerlink" title="示例头文件"></a>示例头文件</h2><p>首先定义了一系列会用到的属性，另外，我在宏定义里去掉了 NSLog 的时间戳，然后定义了 AmyLog ，用来显示对象的所属类，以及地址。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#define NSLog(FORMAT, ...) fprintf(stderr, <span class="meta-string">"%s\n"</span>, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String] )</span></div><div class="line"></div><div class="line"><span class="meta">#define AmyLog(_var) NSLog(@<span class="meta-string">"     (%@ *) %p\n"</span>, [_var class], _var)</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FirstClass</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">//非集合类对象</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableString</span> *mString;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *stringCopy;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *stringMutableCopy;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableString</span> *mStringCopy;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableString</span> *mStringMutableCopy;</div><div class="line"></div><div class="line"><span class="comment">//集合类对象</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *arrayCopy;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *arrayMutableCopy;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *mArrayCopy;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *mArrayMutableCopy;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="非集合类对象-NSString"><a href="#非集合类对象-NSString" class="headerlink" title="非集合类对象(NSString)"></a>非集合类对象(NSString)</h2><h3 id="执行代码："><a href="#执行代码：" class="headerlink" title="执行代码："></a>执行代码：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FirstClass *fC = [[FirstClass alloc] init];</div><div class="line">        </div><div class="line">fC.string = <span class="string">@"originString"</span>;</div><div class="line">fC.stringCopy = fC.string;  <span class="comment">//浅，指针 (不可变String）</span></div><div class="line">fC.stringMutableCopy = [fC.string mutableCopy];  <span class="comment">//深，新地址 (可变String)</span></div><div class="line">        </div><div class="line">fC.mStringCopy = [fC.string <span class="keyword">copy</span>];  <span class="comment">//浅，指针 (不可变String）</span></div><div class="line">fC.mStringMutableCopy = [fC.string mutableCopy];  <span class="comment">//深，新地址 (可变String)</span></div><div class="line">        </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"\n非集合类对象(NSString)：\noriginal address:    "</span>); AmyLog(fC.string);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copy -&gt; NSString:    "</span>); AmyLog(fC.stringCopy);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"mutableCopy -&gt; NSString:    "</span>); AmyLog(fC.stringMutableCopy);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copy -&gt; NSMutableString:   "</span>); AmyLog(fC.mStringCopy);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"mutableCopy -&gt; NSMutableString:    "</span>); AmyLog(fC.mStringMutableCopy);</div></pre></td></tr></table></figure>
<h3 id="打印结果："><a href="#打印结果：" class="headerlink" title="打印结果："></a>打印结果：</h3><p><img src="/images/2016-10-20-语法-copy-与-mutableCopy（传说中的深浅拷贝）/NSString.png" alt=""></p>
<h3 id="NSCFConstantString-和-NSCFString"><a href="#NSCFConstantString-和-NSCFString" class="headerlink" title="__NSCFConstantString 和 __NSCFString"></a>__NSCFConstantString 和 __NSCFString</h3><p><strong>__NSCFConstantString</strong>  </p>
<blockquote>
<p>__NSCFConstantString 对象，就是<strong>字符串常量对象，存储在栈上</strong>，创建之后由系统来管理内存释放.相同内容的  NSCFConstantString 对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的 retainCount ，对其进行 retain 或  release 也不会影响其引用计数。</p>
<p>当创建一个 NSCFConstantString 对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。</p>
<p>总的来说，<strong>对于 NSCFConstantString 对象，只要字符串内容不变，就不会分配新的内存地址</strong>，无论你是赋值、 retain、 copy 。这种优化在大量使用 NSString 的情况下可以节省内存，提高性能。</p>
<p>——摘自简书作者路子：<a href="http://www.jianshu.com/p/0e98f37114e3" target="_blank" rel="external">NSString：内存简述，Copy与Strong关键字</a></p>
</blockquote>
<p>对于 NSString 来说，以下几种赋值方法将会保存为 NSCFConstantString 对象：  </p>
<ol>
<li>直接赋值，如 <code>NSString *str = @&quot;STR&quot;;</code>   </li>
<li>stringWithString ,如 <code>NSString *str = [NSString stringWithString:@&quot;Str&quot;];</code>   </li>
<li><code>str1 = str2;</code>  </li>
<li><code>str1 = [str2 copy/retain];</code></li>
</ol>
<p><strong>__NSCFString</strong> </p>
<p>__NSCFString 对象是 <strong>NSString 的一种子类，存储在堆上</strong>，不属于字符串常量对象。该对象创建之后和其他的 Obj 对象一样引用计数为1，对其执行 retain 和 release 将改变其 retainCount 。</p>
<p>诸如 <code>[NSString stringWithFormat:]</code> 方法以及 <code>NSMutableString</code> 创建的字符串等，都是构造的这种对象。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>mutableCopy</code> 意味着你告诉编译器，我拷贝过来的这个对象可能会改变，因此编译器肯定会新开辟一个地址给你。 因此采用这种方式的都是深拷贝（包括单层深拷贝和完全拷贝）。<br>通过结果我们也可以看见，正如我们前面所提到的，copy 返回不可变对象，因此对于原始对象是不可变的 NSSring 类型，完全没有必要再新分配一块内存。<strong>因此对于不可变的非集合对象，采用 mutableCopy 方式的拷贝就是深拷贝，copy 是浅拷贝。</strong></p>
<h2 id="非集合类对象-NSMutableString"><a href="#非集合类对象-NSMutableString" class="headerlink" title="非集合类对象(NSMutableString)"></a>非集合类对象(NSMutableString)</h2><h3 id="执行代码：-1"><a href="#执行代码：-1" class="headerlink" title="执行代码："></a>执行代码：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fC.mString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"mStringingi"</span>];</div><div class="line">fC.stringCopy = fC.mString;  <span class="comment">//深，新地址（可变String）</span></div><div class="line">fC.stringMutableCopy = [fC.mString mutableCopy]; <span class="comment">////深，新地址 (可变String)</span></div><div class="line">        </div><div class="line">fC.mStringCopy = [fC.mString <span class="keyword">copy</span>];  <span class="comment">//深，新地址，可变String）</span></div><div class="line">fC.mStringMutableCopy = [fC.mString mutableCopy]; <span class="comment">//深，新地址，(可变String)</span></div><div class="line">        </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"\n非集合类对象(NSMutableString)：\noriginal address:    "</span>); AmyLog(fC.mString);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copy -&gt; NSString:    "</span>); AmyLog(fC.stringCopy);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"mutableCopy -&gt; NSString:    "</span>); AmyLog(fC.stringMutableCopy);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copy -&gt; NSMutableString:   "</span>); AmyLog(fC.mStringCopy);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"mutableCopy -&gt; NSMutableString:    "</span>); AmyLog(fC.mStringMutableCopy);</div></pre></td></tr></table></figure>
<h3 id="打印结果：-1"><a href="#打印结果：-1" class="headerlink" title="打印结果："></a>打印结果：</h3><p><img src="/images/2016-10-20-语法-copy-与-mutableCopy（传说中的深浅拷贝）/NSMutableString.png" alt=""></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们已经知道只要用 <code>mutableCopy</code> ，对于非集合对象的拷贝，无论可变不可变，都是深拷贝。 <code>copy</code> 对于不可变对象的拷贝是浅拷贝。那么对于 <code>copy</code> 可变对象呢？如上图的结果所示，是深拷贝。</p>
<p>也很容易理解，我这个对象是可变的，我随时可能通过其他引用它的指针来改变这个对象，现在你要拷贝一份不可变的内容，编译器当然不能直接把它的指针给你啦，这样岂不就是可变的了？所以要新分配给你一块内存，用来储存你拷贝的不可变内容。</p>
<p>就是说，<strong>对于可变非集合对象的拷贝，copy 和 mutableCopy 都是做的深拷贝。</strong></p>
<h3 id="NSTaggedPointerString"><a href="#NSTaggedPointerString" class="headerlink" title="__NSTaggedPointerString"></a>__NSTaggedPointerString</h3><p>Tagged Pointer 是一个能够提升性能、节省内存的有趣的技术。我们知道，程序都使用了指针地址对齐概念。指针地址对齐就是指在分配堆中的内存时往往采用偶数倍或以2为指数倍的内存地址作为地址边界。几乎所有系统架构，包括 Mac OS 和 iOS，都使用了地址对齐概念对象。对于 iOS 和 MAC 来说，指针地址是以16个字节（或16的倍数）为对齐边界的，进一步说，分配的内存地址最后4位永远都是0。</p>
<p>Tagged Pointer 利用了这一现状，它使对象指针中非零位（最后4位）有了特殊的含义。在苹果的64位 Objective-C 实现中，<strong>若对象指针的最低有效位为1(即奇数)，则该指针为 Tagged Pointer 。这种指针不通过解引用 isa 来获取其所属类，</strong>而是通过接下来三位的一个类表的索引。该索引是用来查找所属类是采用 Tagged Pointer 的哪个类。剩下的60位则留给类来使用。</p>
<p>Tagged Pointer 有一个简单的应用，那就是 NSNumber 。它使用60位来存储数值。最低位置1。剩下3位为 NSNumber 的标志。这样，就可以存储任何所需内存小于60位的数值。</p>
<blockquote>
<p>注：以上是在 x86_64 架构中，<strong>在 iOS ARM64 架构中，是最高4位表示所属类，对于最低位，不同类有不同的意义，比如 NSString 代表的是字符长度 length</strong>，NSNumber 我猜测代表的是数字长度类型。</p>
</blockquote>
<p>从外部看，Tagged Pointer很像一个对象。它能够响应消息，因为 objc_msgSend 可以识别 Tagged Pointer 。假设你调用 integerValue ，它将从那60位中提取数值并返回。这样，每访问一个对象，就省下了一次真正对象的内存分配，省下了一次间接取值的时间。同时引用计数可以是空指令，因为没有内存需要释放。对于常用的类，这将是一个巨大的性能提升。</p>
<p>NSString 也是如此。对于那些所需内存小于60位的字符串，它可以创建一个 Tagged Pointer。所需内存大于60位的则放置在真正的 NSString 对象里。这使得常用的短字符串的性能得到明显的提升。</p>
<p>关于 NSString 中的 Tagged Pointer 编码比较复杂，条件是<strong>长度小于11位，且由 Apple 的代码生成在运行时</strong>，即不是直接定义，而是如上图中 mutableCopy/copy 转换而来，编码详情请见<a href="http://www.cocoachina.com/ios/20150918/13449.html" target="_blank" rel="external">【译】采用Tagged Pointer的字符串</a></p>
<blockquote>
<p>在 WWDC2013 中 APPLE 对于它的特点是这样总结的： </p>
<ol>
<li>Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和NSDate   </li>
<li><strong>Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free 。</strong>跟 __NSCFConstantString  一样拥有非常大的 retainCount ，因为压根儿就不在堆上啊。 </li>
<li>在内存读取上有着3倍的效率，创建时比以前快106倍。</li>
</ol>
</blockquote>
<p>对 NSString 对象来说，当非字面量的数字，英文字母字符串的长度小于等于11的时候会自动成为 NSTaggedPointerString 类型（赋值为常量除外），如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 __NSCFString 类型。</p>
<p><strong>Tagged Pointer 举例</strong><br>比如我们将上面的字符串改为<br> <code>fC.mString = [NSMutableString stringWithString:@&quot;mStringingin&quot;];</code>，<br>比之前少了1位，只有11位，则输出结果就变为了：</p>
<p><img src="/images/2016-10-20-语法-copy-与-mutableCopy（传说中的深浅拷贝）/NSMutableString2.png" alt=""></p>
<p>除了拷贝的可变副本（最后一个），其他不可变副本都是 Tagged Pointer ，直接存储的值。</p>
<h2 id="集合类对象-NSArray"><a href="#集合类对象-NSArray" class="headerlink" title="集合类对象(NSArray)"></a>集合类对象(NSArray)</h2><h3 id="执行代码：-2"><a href="#执行代码：-2" class="headerlink" title="执行代码："></a>执行代码：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">fC.array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"hello"</span>,<span class="string">@"world"</span>,<span class="string">@"baby"</span>, <span class="literal">nil</span>];</div><div class="line">fC.arrayCopy = fC.array;  <span class="comment">//浅，指针</span></div><div class="line">fC.arrayMutableCopy = [fC.array mutableCopy]; <span class="comment">//单层深，新地址</span></div><div class="line">        </div><div class="line">fC.mArrayCopy = [fC.array <span class="keyword">copy</span>]; <span class="comment">//浅，指针</span></div><div class="line">fC.mArrayMutableCopy = [fC.array mutableCopy]; <span class="comment">//单层深，新地址</span></div><div class="line">        </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"\n集合类对象(NSArray)：\noriginal address:    "</span>); AmyLog(fC.array); AmyLog([fC.array objectAtIndex:<span class="number">1</span>]);</div><div class="line">        </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copy -&gt; NSArray:    "</span>); AmyLog(fC.arrayCopy); AmyLog([fC.arrayCopy objectAtIndex:<span class="number">1</span>]);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"mutableCopy -&gt; NSArray:    "</span>); AmyLog(fC.arrayMutableCopy); AmyLog([fC.arrayMutableCopy objectAtIndex:<span class="number">1</span>]);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"copy -&gt; NSMutableArray:   "</span>); AmyLog(fC.mArrayCopy); AmyLog([fC.mArrayCopy objectAtIndex:<span class="number">1</span>]);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"mutableCopy -&gt; NSMutableArray:    "</span>); AmyLog(fC.mArrayMutableCopy); AmyLog([fC.mArrayMutableCopy objectAtIndex:<span class="number">1</span>]);</div></pre></td></tr></table></figure>
<h3 id="打印结果：-2"><a href="#打印结果：-2" class="headerlink" title="打印结果："></a>打印结果：</h3><p><img src="/images/2016-10-20-语法-copy-与-mutableCopy（传说中的深浅拷贝）/NSArray.png" alt=""></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>从结果可以发现，对于第一层的指针来说，跟 NSString 是一样的，copy 浅拷贝（复制指针，即指针不变）， mutableCopy 深拷贝（新内存），但是打印数组中的元素，就发现元素的指针并没有变，也就是第二层依然是浅拷贝，因此这就是单层深拷贝了。</p>
<h3 id="集合的浅拷贝和完全拷贝"><a href="#集合的浅拷贝和完全拷贝" class="headerlink" title="集合的浅拷贝和完全拷贝"></a>集合的浅拷贝和完全拷贝</h3><p>集合的浅拷贝有非常多种方法（上面那种 copy 就是）。当你进行浅拷贝时，会向原始的集合发送retain消息，引用计数加1，同时指针被拷贝到新的集合。</p>
<p>现在让我们看一些浅拷贝的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *shallowCopyArray = [someArray copyWithZone:<span class="literal">nil</span>];   </div><div class="line"><span class="built_in">NSSet</span> *shallowCopySet = [<span class="built_in">NSSet</span> mutableCopyWithZone:<span class="literal">nil</span>];   </div><div class="line"><span class="built_in">NSDictionary</span> *shallowCopyDict = [[<span class="built_in">NSDictionary</span> alloc] initWithDictionary:someDictionary copyItems:<span class="literal">NO</span>];</div></pre></td></tr></table></figure>
<p>那么如何才能对元素也进行深拷贝呢？</p>
<p>集合的深拷贝有两种方法。可以用 initWithArray:copyItems: 将第二个参数设置为 YES 即可深拷贝，如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> shallowCopyDict = [[<span class="built_in">NSDictionary</span> alloc] initWithDictionary:someDictionary copyItems:<span class="literal">YES</span>];</div></pre></td></tr></table></figure>
<p>如果你用这种方法深拷贝，集合里的每个对象都会收到 copyWithZone:  消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深拷贝到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深拷贝，会在运行时出错。 copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深拷贝。</p>
<p>第二个方法是将集合进行归档(archive)，然后解档(unarchive)，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *trueDeepCopyArray = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:[<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:oldArray]];</div></pre></td></tr></table></figure>
<p>终于搞定这个了！</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] NSString：内存简述，Copy与Strong关键字　<a href="http://www.jianshu.com/p/0e98f37114e3" target="_blank" rel="external">http://www.jianshu.com/p/0e98f37114e3</a><br>[2] iOS 集合的深复制与浅复制　<a href="https://www.zybuluo.com/MicroCai/note/50592" target="_blank" rel="external">https://www.zybuluo.com/MicroCai/note/50592</a><br>[3] 深入理解Tagged Pointe　<a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/" target="_blank" rel="external">http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/</a><br>[4] 【译】采用Tagged Pointer的字符串　<a href="http://www.cocoachina.com/ios/20150918/13449.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150918/13449.html</a></p>
<p><strong>声明: 本文转载需标明出处，禁止用于商业目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;光是永恒的，所以你是永恒的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;对象拷贝有两种方式：浅拷贝和深拷贝。&lt;/p&gt;
&lt;p&gt;浅拷贝(shallow copy)，并不拷贝对象本身，&lt;strong&gt;仅仅是拷贝指向对象的指针&lt;/strong&gt;。&lt;br&gt;如果 &lt;code&gt;B = [A 浅拷贝]&lt;/code&gt;，则 A、B 两个对象中都保存的同一个指针，如果 A 通过这个指针改变了指针指向的对象，那么 B 指针指向的对象也就随之改变了；&lt;/p&gt;
&lt;p&gt;深拷贝是直接&lt;strong&gt;拷贝整个对象到另一块内存中&lt;/strong&gt;，开辟新的地址来存储，两个对象至此一别，再无关联。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于集合对象（如 NSSArray、NSDictionary 等）而言，又有&lt;strong&gt;单层深拷贝&lt;/strong&gt;与&lt;strong&gt;完全拷贝&lt;/strong&gt;之分。&lt;/p&gt;
&lt;p&gt;单层深拷贝(one-level-deep copy)：指的是对于被拷贝对象，至少有一层是深拷贝。&lt;br&gt;完全拷贝(real-deep copy)：指的是对于被拷贝对象的每一层都是对象拷贝。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OC语法" scheme="https://amywushu.github.io/categories/OC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Property" scheme="https://amywushu.github.io/tags/Property/"/>
    
  </entry>
  
  <entry>
    <title>栈·参数存储排布</title>
    <link href="https://amywushu.github.io/2016/10/12/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86-%E6%A0%88%C2%B7%E5%8F%82%E6%95%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.html"/>
    <id>https://amywushu.github.io/2016/10/12/逆向知识-栈·参数存储方式.html</id>
    <published>2016-10-11T16:00:00.000Z</published>
    <updated>2016-12-07T08:40:16.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>人在世上，爱欲之中，独生独死，独来独往，苦乐自知，无有代者。</p>
</blockquote>
<h2 id="基础提要：栈结构"><a href="#基础提要：栈结构" class="headerlink" title="基础提要：栈结构"></a>基础提要：栈结构</h2><p>ARM内存中的栈区域是满递减的，由高地址向低地址增长，SP指针始终指向最后一个压入栈的地址，即栈顶地址。如图所示：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图1.png" alt=""></p>
<a id="more"></a>
<h3 id="为什么栈向下增长？"><a href="#为什么栈向下增长？" class="headerlink" title="为什么栈向下增长？"></a>为什么栈向下增长？</h3><blockquote>
<p>每一个可执行C程序，从低地址到高地址依次是：text，data，bss，堆，栈，环境参数变量；<strong>其中堆和栈之间有很大的地址空间空闲着，在需要分配空间的时候，堆向上涨，栈往下涨。</strong></p>
<p>这样设计可以使得堆和栈能够充分利用空闲的地址空间。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。</p>
<p>所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。</p>
<p>所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化！！</p>
<p>—— 引用自<a href="http://www.cnblogs.com/youxin/p/3313288.html" target="_blank" rel="external">判断栈和堆的生长方向</a></p>
</blockquote>
<h3 id="如何判断栈的增长方向？"><a href="#如何判断栈的增长方向？" class="headerlink" title="如何判断栈的增长方向？"></a>如何判断栈的增长方向？</h3><p>很简单，我们可以通过两个函数的调用来确定。我们知道，执行一个函数时，这个函数的相关信息都会出现栈之中，比如参数、返回地址和局部变量。</p>
<p>那么，当它调用另一个函数时，在它栈信息保持不变的情况下，会把被调用函数的信息放到栈中。两个函数的相对信息位置是固定的，肯定是先调用的函数其信息先入栈，后调用的函数其信息后入栈。只需要判断这两个地址，就可以判断栈的增长方向了。</p>
<p>比如设计两个函数<code>fun1()</code>和<code>fun2()</code>，将<code>fun1()</code>中某参数的地址传给<code>fun2()</code>，且在<code>fun1()</code>中调用<code>fun2()</code>，最后在<code>fun2()</code>中打印出两个函数参数的地址，则大功告成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> *a)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> b=<span class="number">0</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n%x\n"</span>,a,&amp;b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</div><div class="line">    func2(&amp;a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    func1();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我这边测试打印出来分别是<code>5fbff91c</code>  <code>5fbff8f4</code> （我用的<code>Xcode</code> 的 <code>command line</code> 测试的）。即<code>a</code> 的地址 &gt; <code>b</code>的地址，先分配的是高地址，因此是高地址向低地址增长。</p>
<h3 id="如何区分栈底和栈顶？"><a href="#如何区分栈底和栈顶？" class="headerlink" title="如何区分栈底和栈顶？"></a>如何区分栈底和栈顶？</h3><p>很容易将分不清高地址和低地址到底谁才是栈底。我们可以想象一个桶，这个桶内的空间就是栈区，桶底（栈底）是确定了的，不会改变。往桶内加水，即使入栈操作。水面即是栈顶，也就<code>SP</code>指针所在的位置。我们不断加水，只会使得水面（栈顶<code>SP</code>指针）增长，而水底（栈底指针）仍旧不变。而栈区又是高地址向低地址增长，因此栈区的最高地址是为栈低，<code>SP</code>指针是栈顶指针。</p>
<p>只不过，在实际应用情况中，我们经常习惯将栈底指针（最高地址处）放在最上面，<code>SP</code>指针在最下面，也就是一个倒扣着的桶，在失重情况下，往倒扣的桶里加水，水底仍然是栈底指针，水面仍然是栈顶指针，水面随着水的加入而增长。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在逆向过程中，我一直对栈的数据排列非常迷惑，现在让我们一起来解决它吧！<br>以下是我逆向遇到的一个小实例：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图2.png" alt=""></p>
<p>在图中我们可以看到目前运行到第三行代码<code>stp   x9, x10, [sp, #8]</code>处，<code>stp</code>指令是将寄存器中的值依次存入后面的地址处。我们先打印一下<code>x12</code> <code>x8</code>以及<code>sp</code>的值：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图3.png" alt=""></p>
<p>那么也就是说第二条指令<code>stp   x12, x8, [sp, #24]</code>已经将<code>x12</code>和<code>x8</code>的值存入了<code>sp+24</code>地址处。</p>
<p>那么我们仔细想想，究竟这两个值在栈上是如何排列的呢？先存入的是<code>x12</code>还是<code>x8</code>呢？第二参数是在<code>sp+24</code>的高地址处还是低地址处呢？</p>
<p>我们打印一下内存上的信息看一下就知道了：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图4.png" alt=""></p>
<blockquote>
<p>/4xb: 就是说从该地址开始，按照1个字节，16进制的方式打印4个单位。<br>/4xw: 按照4个字节，16进制的方式打印4个单位</p>
<p>更多有关打印格式的请看<a href="http://blog.chinaunix.net/uid-26980210-id-3300895.html" target="_blank" rel="external">gdb查看内存区命令</a></p>
</blockquote>
<p>跟上面<code>x12</code>和<code>x8</code>比较后，我们可以发现，<strong>内存在打印的时候，每个打印单位（这里是以<code>w</code>格式打印，即4个字节）我们要从右往左看（从高地址到低地址），单位内部还是从左到右为高地址到低地址。</strong>也就是说，第一个打印单位的最右边是当前打印地址（最低地址），最后一个打印单位的最左边是最高地址。如下图所示，图中箭头为从高地址指向低地址：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图5.png" alt=""></p>
<p>那么，也就是说，<br><code>x12</code>存储在从<code>sp+24 (0x16fd11cc8)</code>到<code>sp+31 (0x16fd11ccf)</code>之间<br><code>x8</code> 存储在从<code>sp+32 (0x16fd11cd0)</code> 到<code>sp+39 (0x16fd11cd7)</code>之间</p>
<p>则他们之间的具体排列如下图所示</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图6.png" alt=""></p>
<h3 id="小测试（第3、4行命令）"><a href="#小测试（第3、4行命令）" class="headerlink" title="小测试（第3、4行命令）"></a>小测试（第3、4行命令）</h3><p>现在我们大概对数据的排布有一个更深入的理解了，那么，就以第三行命令来测试一下我们是否真的理解了吧！<br>在执行第三条命令之前，我们先看一下<code>x9</code>，<code>x10</code>的值：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图7.png" alt=""></p>
<p>那么，按照上一条命令的方式，我们来猜测一下内存排布吧。<br><code>stp    x9, x10, [sp, #8]</code> 这条命令的意思是，将<code>x9</code>，<code>x10</code>中的值依次放入<code>sp+8</code>所在的位置。那么，到底是存储在<code>sp+8</code>的高地址处，还是低地址处呢？</p>
<p>其实很好理解，因为栈是向低地址处增长的，如果我们往<code>sp</code>到<code>sp+8</code>处写入这两个寄存器的值，很明显是不够的，这里只有8个字节的空间，而我们需要16个字节，因此<code>sp</code>指针就会往低地址处移动，则栈空间就增大了，但是<code>sp</code>指针并没有改变，这些指令都没有关于要改变栈顶指针的，所以这个想法是错误的。</p>
<p>也就是说，<strong>在往栈内存储数据时，都在高地址到给定的地址之间存入，即向栈中已分配的空间存入。</strong></p>
<p>那么，<code>x9</code>，<code>x10</code>依次存储在<code>sp+8 ~ sp+15</code>，<code>sp+16 ~ sp+23</code>之间。</p>
<p>按照之前讲的打印单位与单位之间是从右往左为从高地址到低地址，单位内的顺序是从左往右，1个地址存储1个字节（8位，两个字符）。<br>我们按照一个字节一个字节的打印（16进制），则</p>
<ul>
<li>在<code>sp+8 ~ sp+15</code>处的数据应为：<code>64 c3 af 0b 00 00 00 00</code>；</li>
<li>在<code>sp+16 ~ sp+31</code>处的数据应为：<code>86 dd a9 b1 00 00 00 00</code>。</li>
</ul>
<p>如果我们按照<code>4xw</code>的格式打印，则应该是<code>sp+8:  0x0bafc364 0x00000000</code>，<code>sp+16:  0xb1a9dd86 0x00000000</code></p>
<p>我们打印一下看看猜测是否正确：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图8.png" alt=""></p>
<p>完全正确！<br>我们继续往下执行第4条命令：<br><code>str   x11, [sp]</code>这条命令的意思是，将<code>x11</code>中的值放入<code>sp</code>所指的地方。我们知道<code>sp</code>是栈顶指针，是栈的最后一个元素所在的位置，所以<code>x11</code>肯定是存储在<code>sp</code>到<code>sp+8</code>之间。<br>打印一下<code>x11</code>的值：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图9.png" alt=""></p>
<p>那么，依旧按照之前的方法，每个打印单位，要从右往左看：</p>
<ul>
<li>那么<code>sp</code>的地址<code>0x16fd11cb0</code>到<code>sp+8 (0x16fd11cb8)</code>之间依次应该为<code>ef e1 0f db 00 00 00 00</code>；</li>
<li>按照<code>4xw</code>的打印格式则应该为：<code>0x16fd11cb0:   0xdbofelef 0x00000000 0x0bafc364 0x00000000</code>   （<code>sp+8 ~ sp+15</code>是刚刚我们执行过的<code>x9</code>的值）</li>
</ul>
<p>打印一下：</p>
<p><img src="/images/2016-10-12-逆向知识-栈·参数存储方式/图10.png" alt=""></p>
<p>完全正确！<br>好了，现在关于内存栈的数据排列，你是不是有更清晰的图像印在脑海里了呢？</p>
<p><strong>声明: 本文转载需标明出处，禁止用于商业目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;人在世上，爱欲之中，独生独死，独来独往，苦乐自知，无有代者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础提要：栈结构&quot;&gt;&lt;a href=&quot;#基础提要：栈结构&quot; class=&quot;headerlink&quot; title=&quot;基础提要：栈结构&quot;&gt;&lt;/a&gt;基础提要：栈结构&lt;/h2&gt;&lt;p&gt;ARM内存中的栈区域是满递减的，由高地址向低地址增长，SP指针始终指向最后一个压入栈的地址，即栈顶地址。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2016-10-12-逆向知识-栈·参数存储方式/图1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="逆向知识" scheme="https://amywushu.github.io/categories/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="逆向" scheme="https://amywushu.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="栈" scheme="https://amywushu.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>C语言编程题（2016年360笔试习题之病毒）</title>
    <link href="https://amywushu.github.io/2016/09/21/%E7%BB%83%E4%B9%A0-C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%A2%98-2016%E5%B9%B4360%E7%AC%94%E8%AF%95%E4%B9%A0%E9%A2%98%E4%B9%8B%E7%97%85%E6%AF%92.html"/>
    <id>https://amywushu.github.io/2016/09/21/练习-C语言编程题-2016年360笔试习题之病毒.html</id>
    <published>2016-09-20T16:00:00.000Z</published>
    <updated>2016-12-07T09:30:42.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>人生如此，拿酒来。</p>
</blockquote>
<h2 id="题目（编程题：病毒）"><a href="#题目（编程题：病毒）" class="headerlink" title="题目（编程题：病毒）"></a>题目（编程题：病毒）</h2><p>小B最近对破解和程序攻击产生了兴趣，她迷上了病毒，然后可怕的事情发生了。不知道什么原因，可能是小B的技术水平还不够高，小B编写的病毒程序在攻击一个服务器时出现了问题。尽管成功的入侵了服务器，但并没有按照期望的方式发挥作用。</p>
<p>小B的目的很简单：控制服务器内存区域，试图在内存中装入从1到n之间的n个自然数，以覆盖内存区域。可能是小B对编程理解上的问题，病毒似乎没有完全成功。可能是由于保护机制的原因，内存写入只接受二进制的形式，所以十进制表达中除了0和1之外的其他值都没有成功写入内存。小B希望知道，究竟有多少数成功的写入了服务器的内存！</p>
<a id="more"></a>
<p><strong>输入</strong>  </p>
<blockquote>
<p>输入中有多组测试数据，每组测试数据在单独的一行中，为整数n（1&lt;=n&lt;=10^9）。</p>
</blockquote>
<p><strong>输出</strong> </p>
<blockquote>
<p>对每组测试数据，在单独的行中输出问题的答案。</p>
</blockquote>
<p><strong>举例</strong> </p>
<blockquote>
<p>输入：10<br>输出： 2</p>
<p>输入：20<br>输出：3</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  1. 输入的字符数组从最高位开始依次与1做比较</div><div class="line"> *  2. 小于等于1 取原值，并比较下一位，如果没有下一位，则返回；</div><div class="line"> *  3. 大于1，则其后的位数都取1，并返回；</div><div class="line"> *  4. 将得到的字符数组看作二进制，并转化为十进制。</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> addarray[<span class="number">10</span>] = <span class="string">""</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> array1[<span class="number">10</span>] = <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *cstring, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> compareString = *(cstring + n);</div><div class="line">    <span class="keyword">char</span> *onestring = <span class="string">"1"</span>;</div><div class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">10</span>] = <span class="string">""</span>;</div><div class="line">    <span class="keyword">char</span> *rec = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(onestring,&amp;compareString) &gt;= <span class="number">0</span>) &#123;  <span class="comment">//compareString &lt;= 1</span></div><div class="line">        <span class="built_in">array</span>[<span class="number">0</span>] = compareString;</div><div class="line">        <span class="keyword">if</span> (*(cstring+n+<span class="number">1</span>)) &#123;</div><div class="line">            <span class="built_in">strcat</span>(<span class="built_in">array</span>, fun(cstring, n+<span class="number">1</span>));</div><div class="line">            <span class="built_in">strcpy</span>(addarray, <span class="built_in">array</span>);</div><div class="line">            rec = addarray;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            rec = cstring + n;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;         <span class="comment">//compareString &gt; 1</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="built_in">strlen</span>(cstring) - n); i++) &#123;</div><div class="line">            <span class="built_in">strcat</span>(array1, onestring);</div><div class="line">        &#125;</div><div class="line">        rec = array1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rec;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">char</span> nstring[<span class="number">10</span>];</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Input String:"</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, nstring);</div><div class="line">  </div><div class="line">    <span class="keyword">char</span> *resultString = fun(nstring, <span class="number">0</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, resultString);</div><div class="line">  </div><div class="line">    <span class="keyword">long</span> result = strtol(resultString, <span class="literal">NULL</span>, <span class="number">2</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, result);</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Input String:20<br>11<br>3  </p>
<p>Input String:1040<br>1011<br>11  </p>
<p>Input Stirng:2300304<br>1111111<br>127  </p>
</blockquote>
<h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><p><strong>关于字符数组和字符串在函数间的传递</strong></p>
<p>从代码中可以看到我用了两个静态数组变量，之所以不直接定义在函数体内作为局部变量是因为：</p>
<blockquote>
<p>当用字符指针<code>char*</code>返回字符数组首地址时，函数体内的局部变量数组里的值已经被释放，返回的首地址虽然没有变，但里面的值已经无意义了。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">()</span></span></div><div class="line">  &#123;</div><div class="line">      <span class="comment">//char tmp[30]="测试";</span></div><div class="line">      <span class="keyword">char</span> *tmp=<span class="string">"测试"</span>;<span class="comment">//写成这样可以用指针返回数组首地址</span></div><div class="line">     <span class="keyword">return</span> tmp;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"> &#123;</div><div class="line">     <span class="built_in">printf</span>(<span class="string">"%s"</span>,test());</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>打印出来的值可能是乱码也能为nil。<br>解决方式：<br><strong>1.  static全局变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">static</span> <span class="keyword">char</span> tmp[<span class="number">30</span>]=<span class="string">"static测试"</span>;</div><div class="line">     <span class="keyword">return</span> tmp;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,test());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在数组tmp[30]前面加入了<code>static</code>关键字，它就使得<code>tmp[30]</code>存放在内存中的静态存储区中，所占用的存储单元一直不释放，直到整个程序运行结束。所以当主函数调用完<code>print()</code>函数后，该空间依然存在。所以<code>main()</code>函数中接到首地值后可以访问数组中的元素。</p>
<p><strong>2.  结构体作为返回值</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ret</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">30</span>];</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">struct</span> ret <span class="title">test</span><span class="params">(<span class="keyword">char</span> *tmp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> ret a;</div><div class="line">    <span class="built_in">strcpy</span>(a.buf,tmp);</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> ret b;</div><div class="line">    b=test(<span class="string">"用结构体作为返回值传递数组"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,b.buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两点注意：</p>
<p>1、数组之间的赋值不要直接，即不要直接将数组 A 赋给数组 B，而是要用<code>strcpy</code>（字符型数组）或者<code>memcpy</code>（非字符型数组）。</p>
<p>2、用结构体定义变量和函数时不要忘了结构体名（上面程序的<code>ret</code>）。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] 【原】C语言函数返回数组的问题　<a href="http://www.cnblogs.com/wuqi1003/archive/2013/01/09/2853657.html" target="_blank" rel="external">http://www.cnblogs.com/wuqi1003/archive/2013/01/09/2853657.html</a><br>[2] C语言中字符串如何转换为二进制、八进制、十进制、十六进制　  　<a href="http://blog.csdn.net/edonlii/article/details/9162769" target="_blank" rel="external">http://blog.csdn.net/edonlii/article/details/9162769</a><br>[3] C语言之strcat函数　<a href="http://blog.csdn.net/hgj125073/article/details/8439448" target="_blank" rel="external">http://blog.csdn.net/hgj125073/article/details/8439448</a><br>[4] C语言strcmp()函数：比较字符串（区分大小写）　<a href="http://c.biancheng.net/cpp/html/162.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/162.html</a></p>
<p><strong>声明: 本文转载需标明出处，禁止用于商业目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;人生如此，拿酒来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目（编程题：病毒）&quot;&gt;&lt;a href=&quot;#题目（编程题：病毒）&quot; class=&quot;headerlink&quot; title=&quot;题目（编程题：病毒）&quot;&gt;&lt;/a&gt;题目（编程题：病毒）&lt;/h2&gt;&lt;p&gt;小B最近对破解和程序攻击产生了兴趣，她迷上了病毒，然后可怕的事情发生了。不知道什么原因，可能是小B的技术水平还不够高，小B编写的病毒程序在攻击一个服务器时出现了问题。尽管成功的入侵了服务器，但并没有按照期望的方式发挥作用。&lt;/p&gt;
&lt;p&gt;小B的目的很简单：控制服务器内存区域，试图在内存中装入从1到n之间的n个自然数，以覆盖内存区域。可能是小B对编程理解上的问题，病毒似乎没有完全成功。可能是由于保护机制的原因，内存写入只接受二进制的形式，所以十进制表达中除了0和1之外的其他值都没有成功写入内存。小B希望知道，究竟有多少数成功的写入了服务器的内存！&lt;/p&gt;
    
    </summary>
    
      <category term="练习" scheme="https://amywushu.github.io/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="c" scheme="https://amywushu.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>@property 中的常用关键字分析</title>
    <link href="https://amywushu.github.io/2016/09/08/%E8%AF%AD%E6%B3%95-property-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90.html"/>
    <id>https://amywushu.github.io/2016/09/08/语法-property-中的常用关键字分析.html</id>
    <published>2016-09-07T16:00:00.000Z</published>
    <updated>2016-12-07T08:42:30.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>我搬进鸟的眼睛，经常盯着路过的风。</p>
</blockquote>
<h2 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h2><p>首先，我们需要知道：为什么<strong>只有OC对象需要进行内存管理</strong>，而其它非对象类型（如基本数据类型）不需要我们来管理呢？</p>
<blockquote>
<p>因为： Objective-C 的对象在内存中是以堆的方式分配空间的</p>
<ul>
<li>堆里面的内存是动态分配的，所以也就需要程序员手动的去添加内存、回收内存</li>
<li>OC对象存放于堆里面(堆内存要程序员手动回收，也就是 release )   </li>
<li>非OC对象一般放在栈里面(栈内存会被系统自动回收)</li>
</ul>
</blockquote>
<a id="more"></a>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</div><div class="line">Car *c = [[Car alloc] init];</div></pre></td></tr></table></figure>
<p>我们知道OC对象一般都是指针形式，大神ibireme在 <a href="http://blog.ibireme.com/2013/11/25/objc-object/" target="_blank" rel="external">Objective-C 中的类和对象</a>中提到：</p>
<blockquote>
<p>凡是首地址是*isa的struct指针，都可以被认为是objc中的对象。运行时可以通过isa指针，查找到该对象是属于什么类(Class)。</p>
</blockquote>
<p>下图可以清楚的表示 OC 中的堆栈分配：</p>
<p><img src="/images/2016-09-08-语法-property-中的常用关键字分析/图1.png" alt=""></p>
<h2 id="assign-与-weak"><a href="#assign-与-weak" class="headerlink" title="assign 与 weak"></a>assign 与 weak</h2><blockquote>
<p><strong>基础知识提要</strong></p>
<p>@property 声明的属性，会自动创建 getter,setter 方法。 属性中申明的关键字主要有三大类：</p>
<ul>
<li>readwrite/readonly： 是否生成 setter 方法, 默认 readwrite</li>
<li>assign/weak/strong/copy/retain： setter 方法中如何传递所有权等内存管理策略, ARC 环境默认为 strong</li>
<li>nonatomic/atomic：是否加线程锁（并不能完全控制线程访问，最好事是自己手动底层加锁，默认 atomic</li>
</ul>
</blockquote>
<p><em>NSString 的引用计数LLVM是有优化的，并不是简单根据设定的关键字来判断。本文只是为了方便易懂，以这个类作为例子。</em></p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>如果设置 assign ，在 setter 方法中是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setCarName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">	_carName = name;  <span class="comment">//默认是有下划线的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说成员变量 _name 并没有获得 name 所指的对象的所有权，原来对象 @“Amywushu” 的 retainCount 不会改变。一旦  name 被释放，_carName 也就不再指向一个合法的位置，出现指针悬空，如下图所示，相当于 _carName （图中为 carName ）指向的 name，但实际上 _carName 是指向OC对象的，这里只是为了方便理解。</p>
<p><img src="/images/2016-09-08-语法-property-中的常用关键字分析/图2assign.png" alt=""></p>
<h3 id="assign-weak-的区别"><a href="#assign-weak-的区别" class="headerlink" title="assign/weak 的区别"></a>assign/weak 的区别</h3><p>ARC 中 OC 对象已经不再使用 assign 了，而是使用 weak ，两者的区别在： weak 弱引用所指的对象没有被任何strong指针指向，那么就将被销毁，所有指向这个对象的 weak 指针也将被置为 nil 。而 assign 不会被置为 nil 。但对于非 OC 对象来讲，因为其存储空间在栈上，由系统管理内存，所以一般还是使用 assign。</p>
<h3 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="unsafe_unretained"></a>unsafe_unretained</h3><p>unsafe_unretained 的语义与 assign 类似，相当于用于 OC 对象类型的 assign 。使用这个关键字主要出于性能考虑，因为 weak 对性能有一些影响，因此对性能要求高的地方可以考虑使用 unsafe_unretained 替换 weak 。比如 <a href="https://github.com/ibireme/YYModel/blob/master/YYModel/NSObject%2BYYModel.m" target="_blank" rel="external">YYModel</a> 的实现，为了追求更高的性能，其中大量使用 unsafe_unretained 作为变量标识符。</p>
<h2 id="retain-与-strong"><a href="#retain-与-strong" class="headerlink" title="retain 与 strong"></a>retain 与 strong</h2><blockquote>
<p><strong>知识点:</strong></p>
<p><strong>MRR内存管理基本原则</strong></p>
<ol>
<li>为创建的所有对象设置所有权     </li>
<li>应使用retain方法获取对象（你尚未拥有）的所有权 </li>
<li>当不再使用某个对象时，必须放弃其所有权 </li>
<li>不能放弃不归你所有的对象的所有权</li>
</ol>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对象通过 alloc 消息创建后，变量 atom 就拥有了该对象的所有权（原则1）</span></div><div class="line">Atom *atom = [[Atom alloc] init];</div><div class="line"></div><div class="line"><span class="comment">//变量 href 获取了这个对象的所有权（原则2），不能写成 Atom *href = atom; </span></div><div class="line"><span class="comment">//这样写的话 href 没有获取对象的所有权，一旦 atom 释放了，href 就不再指向一个合法的位置，出现指针悬空。</span></div><div class="line">Atom *href = [atom <span class="keyword">retain</span>];</div><div class="line"></div><div class="line"><span class="comment">// 变量 atom 释放，但 href 依旧拥有该对象的所有权</span></div><div class="line">[atom release];</div><div class="line"></div><div class="line"><span class="comment">// 变量 href 释放，对象引用计数变为 0 ，运行时系统可以释放对象了</span></div><div class="line">[href release];</div></pre></td></tr></table></figure>
<p> ——引用自<a href="https://yq.aliyun.com/articles/57166?&amp;utm_source=qq" target="_blank" rel="external">[精通Objective-C]内存管理</a></p>
<p>如果设置 retain ，在 setter 方法中是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setCarName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">	<span class="keyword">if</span> (_carName != name) &#123;</div><div class="line">		[_carName release];</div><div class="line">		_carName = [name <span class="keyword">retain</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，retain/strong 会在 setter 方法中，对传入的对象 <code>&quot;Amywushu&quot;</code> 进行引用计数 +1 的操作。简单来说，就是会拥有传入对象 <code>&quot;Amywushu&quot;</code> 的所有权，而不是像 assign/weak 一样，依赖于传入的对象指针 <code>name</code> ，而并非拥有实际所有权。</p>
<p>相当于一个保险柜拥有两把钥匙，变量解除所有权 (release) ，也就相当于归还钥匙。当两把钥匙都被归还之后，这个保险柜（对象）也就会被释放。只要拥有该对象的所有权（至少有一把钥匙没有归还），这个对象就不会被释放。</p>
<p><img src="/images/2016-09-08-语法-property-中的常用关键字分析/图3.png" alt=""></p>
<p>如图所示，<code>_carName</code> 和 <code>name</code> 均拥有对 <code>Amywushu</code> 这个字符串对象的所有权，该对象的引用计数变为 1+1=2 。</p>
<p>strong 是在 iOS 引入 ARC 的时候引入的关键字，是retain的一个可选的替代。 strong 跟 retain 的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。</p>
<p>关于 strong 和 weak 还有什么不清楚的话，可以学习 onevcat 的<a href="https://onevcat.com/2012/06/arc-hand-by-hand/" target="_blank" rel="external">手把手教你ARC——iOS/Mac开发ARC入门和使用</a>这篇文章，讲得非常清晰易懂。</p>
<h2 id="copy-与-mutableCopy"><a href="#copy-与-mutableCopy" class="headerlink" title="copy 与 mutableCopy"></a>copy 与 mutableCopy</h2><p>copy 、mutableCopy 与 strong 的区别在于，深拷贝时，示例变量对于传入对象的副本拥有所有权，而不是对象本身；浅拷贝时，则没有区别。<br>如果设置 copy ，在 setter 方法中是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setCarName:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">	<span class="keyword">if</span> (_carName != name) &#123;</div><div class="line">		[_carName release];</div><div class="line">		_carName = [name <span class="keyword">copy</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/2016-09-08-语法-property-中的常用关键字分析/图4.png" alt=""></p>
<p>如上图所示，原来对象的 retainCount 不变，新 copy 出来的对象副本的 retainCount=1 ，原对象引用计数不变，两者 copy 之后互不相关，这是深拷贝。</p>
<blockquote>
<ul>
<li><strong>深拷贝与浅拷贝</strong></li>
</ul>
<p><strong>深拷贝</strong>： 是对内存空间的拷贝，也就是这里的 copy（数组等类型例外）<br><strong>浅拷贝</strong>： 是对内存地址的拷贝，也就是上面的 retain/strong，以及 copy 的某些情况<br><strong>深拷贝和浅拷贝比较复杂，我的另一篇文章有具体讲解<a href="https://amywushu.github.io/2016/10/20/%E8%AF%AD%E6%B3%95-copy-%E4%B8%8E-mutableCopy%EF%BC%88%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89.html">copy 与 mutableCopy（传说中的深浅拷贝）</a>，这里只是简要提及一下。</strong></p>
</blockquote>
<p><strong>注意！ 如果是 copy 的是一个 NSArray 呢?</strong>    比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"hello"</span>,<span class="string">@"world"</span>,<span class="string">@"baby"</span>];</div><div class="line"><span class="built_in">NSArray</span> *array2 = [array <span class="keyword">copy</span>];</div></pre></td></tr></table></figure>
<p>这个时候,系统的确是为 array2 开辟了一块内存空间,但是我们要知道的是, array2 中的每个元素,,只是 copy 了指向 array 中相对应元素的指针，这是<strong>“单层深拷贝”</strong>.</p>
<hr>
<p><strong>一般来说，不要将 copy 用到 NSMutableString ，NSMutableArray ，NSMutableDictionary 等可变对象上，除非有特别的需求。</strong></p>
<p>例如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableArray</span> *mutableArray_copy;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithObject:<span class="string">@"123"</span>];</div><div class="line">    <span class="keyword">self</span>.mutableArray_copy = mutableArray;</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.mutableArray_copy addObject:<span class="string">@"456"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行则会报出错误 <strong>signal SIGABRT</strong></p>
<p><img src="/images/2016-09-08-语法-property-中的常用关键字分析/图5.png" alt=""></p>
<p>我们明明在代码里用的 NSMutableArray 这个可变数组，为什么错误里会说是在向 NSArray 这个不可变数组，调用 addObject: 这个方法呢？（ __NSArrayI 表示的是 NSArray 类型）。<br>是因为在 <code>self.mutableArray_copy = mutableArray;</code> 这一句的时候，会调用 mutableArray_copy 的 setter 方法， copy 属性默认 setter 方法是这样写的:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setMutableArray_copy:(<span class="built_in">NSMutableArray</span> *)mutableArray_copy &#123;</div><div class="line">	_mutableArray_copy = [mutableArray_copy <span class="keyword">copy</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setter 方法里调用的是 copy，而不是 mutableCopy ，也就是说拷贝过来的是不可变的 NSArray 类型。那么 NSMutableArray 的添加元素等方法自然就不能使用了。<br>解决方法为：将 copy 改为 strong ；或者重写 setter 方法，将 copy 改为 mutableCopy 。</p>
<blockquote>
<p>copy 现在都比较少用，一般用于 NSString 。因为<strong>父类指针可以指向子类对象</strong>，NSMutableNSString 是 NSString 的子类，使用 strong 的话虽然 NSString 是不可变对象，但是它传入的值可能会是 NSMutableString 可变对象，<strong>如果这个可变对象的内容在其他地方被修改了，那 NSString 指针所指的对象也随之改变了</strong>，而其本身可能对此毫不知情。因此一般用 copy 。</p>
</blockquote>
<h2 id="nonull-nullable-null-resettable"><a href="#nonull-nullable-null-resettable" class="headerlink" title="nonull nullable null_resettable"></a>nonull nullable null_resettable</h2><p>这三个属性关键字是 WWDC2015 中介绍的 OC 新特性，与 Swift 中的 ? 和 ! 类似。</p>
<ul>
<li><strong>nonull</strong>：该属性不能为 nil ,必须有值。</li>
<li><strong>nullable</strong>：表示可选的，可以为 nil。</li>
<li><strong>null_resettable</strong>：表示 setter 方法是 nullable ,可以为 nil；而 getter 方法是nonull ，必须有值。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，就是内存处理方式不一样，assign/weak 相当于借用传入的指针变量来指向对象（实际上并不是，可以这样理解），retain/strong 相当于不同的指针变量指向同一个对象，copy 则是在内存里复制了一个对象并指向它。读写属性以及原子性比较简单，不再赘述。</p>
<p>关于 atomic 的锁机制，以及 ARC 机制到底如何进行的内存管理，之后会进一步学习。敬请期待。</p>
<p>2016.12.07 补充：</p>
<p>新增博文： <a href="https://amywushu.github.io/2016/12/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-ARC-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84.html">ARC 是如何进行内存管理的</a></p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Objective-C 内存管理——你需要知道的一切　<a href="https://segmentfault.com/a/1190000004943276" target="_blank" rel="external">https://segmentfault.com/a/1190000004943276</a><br>[2] @property属性关键字详解　<a href="http://www.wugaojun.com/blog/2015/07/25/at-propertyshu-xing-guan-jian-zi-xiang-jie/" target="_blank" rel="external">http://www.wugaojun.com/blog/2015/07/25/at-propertyshu-xing-guan-jian-zi-xiang-jie/</a><br>[3] Objective-C 的自动引用计数（ARC）　<a href="https://hran.me/archives/objective-c-automatic-reference-counting.html" target="_blank" rel="external">https://hran.me/archives/objective-c-automatic-reference-counting.html</a><br>[4] Objective-c 内存管理的历史和参考资料　<a href="http://www.pchou.info/ios/2015/06/05/oc-memory-management.html" target="_blank" rel="external">http://www.pchou.info/ios/2015/06/05/oc-memory-management.html</a></p>
<p><strong>声明: 本文转载需标明出处，禁止用于商业目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;我搬进鸟的眼睛，经常盯着路过的风。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;栈与堆&quot;&gt;&lt;a href=&quot;#栈与堆&quot; class=&quot;headerlink&quot; title=&quot;栈与堆&quot;&gt;&lt;/a&gt;栈与堆&lt;/h2&gt;&lt;p&gt;首先，我们需要知道：为什么&lt;strong&gt;只有OC对象需要进行内存管理&lt;/strong&gt;，而其它非对象类型（如基本数据类型）不需要我们来管理呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为： Objective-C 的对象在内存中是以堆的方式分配空间的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆里面的内存是动态分配的，所以也就需要程序员手动的去添加内存、回收内存&lt;/li&gt;
&lt;li&gt;OC对象存放于堆里面(堆内存要程序员手动回收，也就是 release )   &lt;/li&gt;
&lt;li&gt;非OC对象一般放在栈里面(栈内存会被系统自动回收)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OC语法" scheme="https://amywushu.github.io/categories/OC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Property" scheme="https://amywushu.github.io/tags/Property/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking 3.1.0 第一部分</title>
    <link href="https://amywushu.github.io/2016/09/06/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-AFNetworking-3.1.0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.html"/>
    <id>https://amywushu.github.io/2016/09/06/源码学习-AFNetworking-3.1.0-第一部分.html</id>
    <published>2016-09-05T16:00:00.000Z</published>
    <updated>2016-12-07T08:42:42.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>空山新雨后，天气晚来秋。</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h2><p>我主要根据作者polobymulberry的博客<a href="http://www.cnblogs.com/polobymulberry/category/785705.html" target="_blank" rel="external">AFNetworking源码阅读系列</a>来学习，因为我有很多知识不懂，所以有些地方可能会记录得过于繁琐。原作者的大体流程和记录不变，某些知识点会有自己的补充。在此非常感谢博客作者polobymulberry的分享。</p>
<a id="more"></a>
<blockquote>
<p>第一次运行运行example时总是出现 Module ‘AFNetworking’ not found 问题，查了好多关于Module的资料，对于问题的解决却没有帮助，后来偶然间在AFNetworking的github上的issues里找到解决办法，真是特别惭愧。应该点击文件夹内的<code>AFNetworking.xcworkspace</code>，而不是其他<code>.xcodeproj</code>文件。</p>
</blockquote>
<p>图片1</p>
<p>运行成功后，就开始我们艰难的学习旅程吧！</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a><strong>开始</strong></h2><h3 id="AppDelegate"><a href="#AppDelegate" class="headerlink" title="AppDelegate"></a>AppDelegate</h3><p>此文件主要就是实现函数didFinishLaunchingWithOptions。将windows的rootViewController设置为rootViewController为GlobaltimelineViewController的NavigationController。此处有两点需要注意一下：</p>
<p>第一处</p>
<pre><code>NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024 diskCapacity:20 * 1024 * 1024 diskPath:nil];
[NSURLCache setSharedURLCache:URLCache];
</code></pre><p>NSURLCache 为您的应用的 URL 请求提供了内存中（对应memoryCapacity）以及磁盘上（对应diskCapacity）的综合缓存机制。所以你想使用NSURLCache带来的好处，就需要在此处设置一个sharedURLCache。</p>
<p>第二处</p>
<pre><code>[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES];
</code></pre><p>为了说明AFNetworkingActivityIndicator是什么，直接上图：</p>
<p>图2</p>
<p>当你有session task正在运行时，这个小菊花就会转啊转。这个是自动检测的，只需要你设置AFNetworkingActivityIndicatorManager的sharedManager中的enabled设为YES即可。</p>
<p>这里我简单看了下AFNetworkingActivityIndicatorManager，发现它对外接口不多，比较容易理解它的业务流程。所以我准备在第三部分就将AFNetworkingActivityIndicatorManager的源码拿下。</p>
<p>设置完了cache和AFNetworkingActivityIndicator，接着就是进入GlobalTimelineViewController（UITableViewController）了。这里我学到一个，就是UITableViewController可以使用initWithStyle进行初始化。（<strong>因为我对iOS界面不太了解，所以这个initWithStyle现在并不懂</strong>）</p>
<blockquote>
<p>polobymulberry在开篇画了一个iOS Example的代码结构图，我不太懂MVC，特地查了下。以下是我个人非常粗浅的了解：</p>
<ul>
<li>M代表Model，V代表View，C代表Cotroller。这是一种设计模式，是想让各模块分离，视图跟数据处理以及中间的控制协调端各司其职。</li>
<li>视图只用于展现APP的界面，用于人和程序的交互。至于你点击按钮后产生的反馈，是由Controller来传递给Model处理，比如点击按钮后，会在文本框内展现文字。则Model从数据库中读取文字并通知Controller，事件已经处理完，Controller收到通知然后决定怎么处理，比如通过outlet控制View展示文字。</li>
<li><p>注意View和Model之间并不直接通信。</p>
<p> 图3</p>
</li>
</ul>
<p>参考自<a href="http://blog.csdn.net/nhwslxf123/article/details/49703773" target="_blank" rel="external">实际案例讲解iOS设计模式——MVC模式</a></p>
</blockquote>
<h3 id="GlobalTimelineViewController"><a href="#GlobalTimelineViewController" class="headerlink" title="GlobalTimelineViewController"></a>GlobalTimelineViewController</h3><p>主要是围绕UITableView的delegate和dataSource来说。</p>
<h5 id="1-UITableViewDelegate"><a href="#1-UITableViewDelegate" class="headerlink" title="1) UITableViewDelegate"></a>1) UITableViewDelegate</h5><p>主要是计算heightForRowAtIndexPath这个函数比较麻烦（应该是<code>-(CGFloat)tableView:heightForRowAtIndexPath:</code>函数），这里的Cell比较简单，可以直接使用posts中存储的text值来计算高度，核心代码就下面这句：</p>
<pre><code>CGRect rectToFit = [text boundingRectWithSize:CGSizeMake(240.0f, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName: [UIFont systemFontOfSize:12.0f]} context:nil];
</code></pre><p>对于boundingRectWithSize的使用又增进了一步。（<strong>这里我也不懂</strong>）</p>
<h5 id="2-UITableViewDataSource"><a href="#2-UITableViewDataSource" class="headerlink" title="2) UITableViewDataSource"></a>2) UITableViewDataSource</h5><p>主要是用posts作为数据源，而posts的获取在此处尤为关键，是通过Post本身（model）的globalTimelinePostsWithBlock函数获取数据的，这里作者将网络端的请求放在了model里面。</p>
<p>接着调用了refreshControl控件的setRefreshingWithStateOfTask:。setRefreshingWithStateOfTask:其实是UIRefreshControl+AFNetworking的一个category中定义的。UIRefreshControl+AFNetworking的源码很简单，放在第四部分讲。</p>
<p>注意setRefreshingWithStateOfTask:有一个参数就是NSURLSessionTask*。而这个NSURLSessionTask的获取是调用了Post类中的globalTimelinePostsWithBlock:函数。</p>
<p>在globalTimelinePostsWithBlock:函数中其实封装了一层AFHTTPSessionManager的GET函数</p>
<pre><code>- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString
                            parameters:(nullable id)parameters
                              progress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress
                              success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre><p>具体细节后面讨论，此处我们知道是根据一个url获取到服务器端的数据即可。注意获取到的数据是JSON格式的，这里作者在Post类，即Model中定义了一个JSON—-&gt;Model函数-initWithAttributes，，也就是说模型数据转化部分也放在了model中。</p>
<p>另外，调用GET方法不是直接用AFHTTPSessionManager的manager，而是又定义了一个AFAppDotNetAPIClient，继承自AFHTTPSessionManager。并在其定义的单例模式中简单地封装了一些AFHTTPSessionManager的设置。</p>
<pre><code>+ (instancetype)sharedClient {
       static AFAppDotNetAPIClient *_sharedClient = nil;
       static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        // 初始化HTTP Client的base url，此处为@&quot;https://api.app.net/&quot;
        _sharedClient = [[AFAppDotNetAPIClient alloc] initWithBaseURL:[NSURL URLWithString:AFAppDotNetAPIBaseURLString]];
           // 设置HTTP Client的安全策略为AFSSLPinningModeNone
        _sharedClient.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];
});

    return _sharedClient;
}
</code></pre><p>知识点：SSL Pinning</p>
<p>Https对比Http已经很安全，但在建立安全链接的过程中，可能遭受中间人攻击。防御这种类型攻击的最直接方式是Client使用者能正确鉴定Server发的证书【目前很多浏览器在这方面做的足够好，用户只要不在遇到警告时还继续其中的危险操作】，而对于Client的开发者而言，一种方式保持一个可信的根证书颁发机构列表，确认可信的证书，警告或阻止不是可信根证书颁发机构颁发的证书。</p>
<p>SSL Pinning其实就是证书绑定，一般浏览器的做法是信任可信根证书颁发机构颁发的证书，但在移动端【非浏览器的桌面应用亦如此】，应用只和少数的几个Server有交互，所以可以做得更极致点，直接就在应用内保留需要使用的具体Server的证书。对于iOS开发者而言，如果使用AFNetwoking作为网络库，那么要做到这点就很方便，直接证书作为资源打包进去就好，AFNetworking会自动加载，具体代码就不贴了，nsscreencast已经有很好的tutorial。</p>
<p>至于model根据网络层获取的数据赋值，除了user的头像那块比较难，因为涉及到UIImageView+AFNetworking等文件，其他部分很简单。而AFNetworking的UIImageView+AFNetworking的部分其实很类似SDWebImage的思路。</p>
<h5 id="Add：BLock作为函数参数"><a href="#Add：BLock作为函数参数" class="headerlink" title="Add：BLock作为函数参数"></a>Add：BLock作为函数参数</h5><p><code>block原本的形式为:</code></p>
<p><code>返回值  (^block名称  可省) (参数  可省) ＝ ^{函数体};</code><br><code>调用形式： block名称(参数);</code></p>
<p>在GlobalTimelineViewController.m <code>- (void)reload:</code> 函数中遇到了第一个block</p>
<pre><code>NSURLSessionTask *task = [Post globalTimelinePostsWithBlock:^(NSArray *posts, NSError *error) {
        if (!error) {
            self.posts = posts;
            [self.tableView reloadData];
        }
    }];
</code></pre><p><code>^(NSArray *posts, NSError *error){}</code> 整个block作为参数传递给<code>+ (NSURLSessionDataTask *)globalTimelinePostsWithBlock:</code>函数</p>
<blockquote>
<p>参数传递只需要 ^(参数){block函数体} </p>
<p> ^表明是block形式</p>
</blockquote>
<p>Post.m <code>+ (NSURLSessionDataTask *)globalTimelinePostsWithBlock:</code>函数:</p>
<pre><code>+ (NSURLSessionDataTask *)globalTimelinePostsWithBlock:(void (^)(NSArray *posts, NSError *error))block {
                 ......
}
</code></pre><blockquote>
<p>即这个函数的参数为(void (^)(NSArray <em>posts, NSError </em>error))block</p>
<p>(返回值 (^)(参数))block名称</p>
</blockquote>
<p>也就是说在block作为函数参数传递时，定义block的这个A函数(<code>globalTimelinePostsWithBlock:</code>)并没有block函数体，而是调用A函数(<code>[Post globalTimelinePostsWithBlock:]</code>)在传参数时定义block的具体执行内容。</p>
<p><strong>声明: 本文转载需标明出处，禁止用于商业目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;空山新雨后，天气晚来秋。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我主要根据作者polobymulberry的博客&lt;a href=&quot;http://www.cnblogs.com/polobymulberry/category/785705.html&quot;&gt;AFNetworking源码阅读系列&lt;/a&gt;来学习，因为我有很多知识不懂，所以有些地方可能会记录得过于繁琐。原作者的大体流程和记录不变，某些知识点会有自己的补充。在此非常感谢博客作者polobymulberry的分享。&lt;/p&gt;
    
    </summary>
    
      <category term="源码学习" scheme="https://amywushu.github.io/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Network" scheme="https://amywushu.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>（译） iOS  Kernel  Heap  Armageddon —— Stefan Esser</title>
    <link href="https://amywushu.github.io/2016/08/29/%E8%AF%91-iOS-Kernel-Heap-Armageddon.html"/>
    <id>https://amywushu.github.io/2016/08/29/译-iOS-Kernel-Heap-Armageddon.html</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2016-12-07T08:43:13.784Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>人世间最让你感动的是什么？   ——是遥远的相似性</p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>你所了解到的关于 iOS 内核堆利用的公开研究，最终都可以归结于对内核堆空间的分配，这个观点由 nemo 首先提出来。总而言之，这种分配将空间内的内核内存分成相同大小的内存块。通过利用重写堆元数据，可以向空间的空闲列表 (freelist) 中注入任意内存区。</p>
<p>在本文中，我们将首先概括关于内核堆空间分配的知识，像 nemo 和 Esser 之前所提到的那样。接着，我们将看一看其他的内核堆管理以及 Mac OSX 和 iOS 内核中的内存分配封装函数。在简单介绍这些封装函数之后，我们将进一步介绍这些分配器在最新版本 iOS 5 之后的改变。本文将继续介绍内核层的应用数据重写与直接攻击分配器的空闲列表区之间的差异。最后将展示一种普遍的技术：为了实现内核堆利用，通过执行内核堆喷射  (heap spraying) ，来控制内核堆布局的布局。</p>
<a id="more"></a>
<h2 id="内核堆空间分配"><a href="#内核堆空间分配" class="headerlink" title="内核堆空间分配"></a><strong>内核堆空间分配</strong></h2><p>对于 Mac OSX 以及越狱的苹果手机，有一种可用的工具叫做 zprint ，它可以查看由内核堆分配器注册的内核内存空间。<br>例如：</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图1.png" alt=""></p>
<p>这些信息都是由内核 API 函数 host_zone_info 以及 mach_zone_info 提供的。当涉及到构造内核堆利用方法时，这些 API 函数都非常有用，因为它们可以检索每个内核空间的详细信息，比如分配的块的数量，空闲内存块的数量等。Sotirov提到：后者对于控制内核堆（又称为堆风水）技术非常有用。但是根据苹果 iOS 6 的介绍，为了防止内核 API 函数被用于工厂 设备iPhone ，这条路已经被关闭了。现在调用 PE_i_can_haz_debugger 函数，在越狱机以及特殊的苹果内部调试设备、通过苹果可能有的特殊调试虚拟磁盘启动的设备上，只会返回 true。不管怎样，以后的内核堆利用已经不能再依赖这些函数了。</p>
<p>为了弄清楚内核堆分配器是如何工作的，我们可以通过下面的图表了解，这些图表将会一步步记录其内部的运行。分配器将内核内存分成了许多空间，每个空间包含了同样大小的内存块。它首先在空间内分配一大块内存（通常是一个单独的内存页）。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图2.png" alt=""></p>
<p>所有的内存都在这个空间里，然后它被分为大小相同的块。在这个例子中，每块内存正好为 512bytes 。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图3.png" alt=""></p>
<p>内存管理器用每个空闲内存块的 4 个首字节作为指向另一个内存块的指针。如下图所示：</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图4.png" alt="">    </p>
<p>空间分配器创建了一个空闲内存块链表，即空闲列表。它是一个后进先出的列表，在链表内，每个元素都指向下一个元素。因为在新的内存页里的第一个空闲内存块首先被添加，正如下图所示，空闲内存将会被反序利用。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图5.png" alt="">    </p>
<p>某特定空间的最后一个元素被添加到空闲列表后，当内存被分配给这个特定空间时，该元素也被称为空闲列表头部，同时作为分配内存块标识返回。返回新分配的内存之后，空闲列表中下一个元素的指针从内存块的首4字节读取。指针读取成为新的自由列表头部。它指向的内存块将会因此成为下一个返回值。这个原则由下图证实。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图6.png" alt=""></p>
<p>现在我们知道了堆空间分配的基本机制，接下来我们介绍一下如何利用这种内存分配。我们发现，两个相邻的内存块，第一个为分配缓存区，第二个为空闲内存块，缓存区溢出将会导致堆元数据被覆盖。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图7.png" alt=""></p>
<p>如果攻击者控制了缓存区溢出的数据，那么他完全可以控制空闲列表中指向下一个元素的指针。如上所述的分配将会返回被重写的内存块，使得攻击者控制空闲列表的头部指针。之后分配器将会返回一个被攻击者控制的内存块。在公开的 iOS 内核堆利用中，这种技术被用来返回位于系统调用表中间的一块内存。通过强制内核分配一块内存，并用被攻击者控制的数据覆盖，这种方式可以替换任意系统调用处理程序，并实现任意内核代码执行。</p>
<p>据了解， iOS 6 的测试版在内核堆分配器中添加了一些内存标签，虽然一般来说，它不阻止攻击空闲列表，但是阻止公开地使用攻击，因为它只允许向内核的空闲列表中注入内存块，但是这样也已经完全在攻击者的控制之下了。</p>
<h2 id="其他内核堆内存管理和封装器"><a href="#其他内核堆内存管理和封装器" class="headerlink" title="其他内核堆内存管理和封装器"></a><strong>其他内核堆内存管理和封装器</strong></h2><p>Mac OSX 和 iOS 内核包含了许多其他的内核堆内存管理以及封装。下图展示了其中一部分的封装和内存管理。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图8.png" alt=""></p>
<p>在本节中，我们将介绍几个提到的分配器和封装，并讨论它们的属性以及利用。</p>
<hr>
<ul>
<li>kalloc()</li>
</ul>
<p>kalloc() 是用来封装 zalloc() 以及 kmem_alloc() 的。它在小分配时使用 zalloc() ，较大的内存请求时使用 kmem_alloc() 。它没有任何额外的堆元数据。因此，需要调用者记住分配的内存大小，当稍后内存使用 kfree() 释放时要求使用相同大小的值。</p>
<p>存储在内核空间的数据由内存管理器注册一个空间号码，这个号码为 kalloc.xxx ，xxx 即为 kalloc 空间大小。在 iOS 5 中可使用 zprint 工具得到以下空间。(译者注：在OS X 10.11 及以上系统可在 root 权限下使用 zprint | grep kalloc 命令)</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图9.png" alt=""></p>
<p>可以从中发现，这个内核空间是在 8 到 8192 之间的每2倍大小再加上一些额外的空间值，这些额外值的大小是2倍之间可被8整除的数。比如 kalloc.24,  kalloc.40, kalloc.48, kalloc.88, kalloc.112, kalloc.192, kalloc.384, kalloc.768, kalloc.1536, kalloc.3072 以及 kalloc.6144 。在 iOS 5 之前，这些 kalloc 空间并不存在，且最小的空间为 16 。这种增加空间的变化可能是为了减少内存浪费，以便使得最常用的分配越来越合适。</p>
<hr>
<ul>
<li>kfree()</li>
</ul>
<p>在跳转到下一个封装之前，还有一些值得注意的地方，kfree() 函数。正如之前所提到的那样，调用者需要记住需要释放的块的大小，否则 kfree() 不知道 zfree() 或 kmem_free() 是否被调用，以及需要向内存返回多大的空间。内存管理器除了保持对较大的分配内存块的跟踪之外，对于释放一个比之前所记忆值大的块的尝试将会被忽略。这是一个简单的保护机制防止二次释放。</p>
<hr>
<ul>
<li>_MALLOC()</li>
</ul>
<p>_MALLOC() 是一个对 kalloc() 函数的封装。对于分配的内存块它预先留下一个简短的头部，存储分配的大小。这种通过 _MALLOC() 进行内存分配的方式，在内核代码中可以在不需要保持对块大小的跟踪的情况下释放。下图是一个通过系统调用的内存分配例子。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图10.png" alt=""></p>
<p>0字节的分配是特例。_MALLOC() 会简单拒绝这样的分配并返回一个空指针。目前尚不知道为什么苹果不返回一个最小大小的分配值，因为分配 0 字节是可以在合理条件下发生的。用大小作为头部有两个缺点，第一为了确定分配的大小，它要求有整数加法，第二当重写导致可执行的情况，它相当于额外的堆元数据。</p>
<p>当看到 iOS 4 中的 XNU源代码树中的源代码，可以发现 _MALLOC() 中整数加法的危险是显而易见的。正如下面代码所示，苹果并没有设定在 iOS 4 以及 Mac OSX 中的整数溢出，这将会导致许多可能的内核堆错误。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图11.png" alt=""></p>
<p>但是在 iOS 5 的 release 版本之前，苹果研究了可能的整数溢出并关闭了它。代码改为捕捉整数溢出，防止在非阻塞情况下，溢出流返回空指针。但是在阻塞情况下，可以看到触发了内核 panic。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图12.png" alt=""></p>
<p>包含了额外大小字段的内存块头部，对于重写来说，是一个非常有趣的目标，因为通过重写它，内存管理器可以被欺骗去释放错误区域的空闲列表中的内存块。如果大小被重写为一个更小的值，这个块也将会被添加到更小尺寸的块的空闲列表中。这不会导致内存错误，但将会导致内存泄漏，因为稍长的那部分永远不会被覆盖。同样，如果一个较大的尺寸被写入头部，这个块也会被添加到较大尺寸块的自由列表中。这样将会导致内存错误，因为内核分配相信块比实际尺寸大，而这将会导致它在填满时覆盖到相邻的内存。</p>
<h2 id="内核堆应用数据重写"><a href="#内核堆应用数据重写" class="headerlink" title="内核堆应用数据重写"></a><strong>内核堆应用数据重写</strong></h2><p>考虑到苹果正在硬化空间分配器，一些内存分配器也将不再会有流入的堆元数据可以被覆盖，因此我们将要介绍一种有攻击性且有趣的存储在堆上的内核应用数据。本节的剩余部分，我们将使用内核层的 C++ 对象作为这种有趣的可以被广泛使用的应用数据的示例。</p>
<p>在 iOS 内核中的 libkern 实现了一个 C++ 运行时子集。它允许内核驱动程序用 C++ 写，其中 IOKit 驱动使用最为频繁。这太有意思了，因为它为 iOS 内核带来了 C++ 类的漏洞。但是对于我们来说，只有在内存布局中的类是有意义的</p>
<p>下图展示了一个支持 iOS 内核的 C++ 运行时以及继承的基本对象的概述：</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图13.png" alt=""></p>
<p>正如你所看见的，所有的这些类都是由基类 OSObject 分发而来的。接下来我们将要更进一步查看这些类的内存排布。可以看到 OSObject 由一个 vtable ptr 和一个引用计数器组成：</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图14.png" alt=""></p>
<p>vtable ptr 指向内核的数据段，即对象的方法表的存储位置。另一方面，引用计数器要稍微复杂一点。它是一个将 16bit 引用计数存储在低 16 位的 32bit 值。用高 16 位计数对象在集合中的频率，作为第二参考计数。貌似设计的最初目的是用来调试，因为集合计数看起来只能用来验证正常引用计数不低于集合计数。如果是这样，则任何情况都能导致内核 panic 被触发。引用计数器特别的一点是它有一个内置的整数溢出保护。如果引用计数器的值达到65534，则计数器将会被冻结，意味着它将既不会增加，也不会再减少。因此该对象不再可以被破坏，它的内存也不会被释放。</p>
<p>为了明白 iOS 内核对象重写是如何被利用的，首先需要弄清楚在内存中一个 OSObject 的每个部分被重写的影响。如果可以重写 vtable ptr，则可以改变用于查找对象方法的表中的地址。一旦这个指针被重写了对象上的每一个执行操作，将会导致任意内核代码执行。如果引用计数器被重写，将会允许将引用计数器设置为一个小于现有的实际引用计数的值。同时允许释放之前的对象，这将会导致一种典型用法，即通过悬挂引用引起的任意利用。一旦释放了下一个相同大小的分配内存，则对象的内容将会被完全替换。</p>
<p>在 iOS 内核中， OSObject 是一个最简单的 C++ 对象。其他对象比如 OSString 则更复杂一些，包含有更多数量或者更多不同类型的属性。进一步分析它们的内存布局也将会因此变得有趣。首先，让我们看看 OSString 对象，它的内存布局如下图所示。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图15.png" alt=""></p>
<p>除了 OSObject 中已知的属性外，flags，length 和 string ptr 三个是新增的。flags 只是控制对象内部的字符串指针是否在其被销毁时释放。这通常只在其他的字段同时被重写时有用。更有用一点的是 length 字段。如果字符串的长度被改变为一个大于原始值的数值，则会导致内核堆信息泄漏或者破坏的内存错误。内存错误是由于长度太大，进而导致长度较小的内存块被添加到错误的内核堆空间的空闲列表里。如果被释放的内存在之后重新分配，则返回的指针将会指向一个实际小于预期的内存块。当内核中的这个小内存块被数据填满时，多余的数据则会重写到相邻的内存中。最后一个字段可以被字符串指针自身重写。同样，该指针被重写，也会导致内核堆信息泄漏或者破坏的内存错误。这种情况下，攻击者可以向特殊空间的空闲列表注入一段任意内存地址，一旦那段内存被内核重新分配然后填满，将导致内存破坏。</p>
<p>另外一个有意思的重写对象是 OSArray 。它包括了更多的属性，因此也提供了一些新的有趣的重写可能性。让我们看一下 OSArray 对象的内存布局：</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图16.png" alt=""></p>
<p>updateStamp, reserved 以及 fOptions 字段对于重写来说没有什么用处，因为它们不能导致有用的可利用的场景。但是其他的字段都可以。count, capacity 和 capacityIncrement 字段都是由 kalloc() 分配的内存的值。重写这些值将会混淆内存，使得它分配或者再分配错误数量的内存。这种做法将会导致内核堆信息泄漏或者破坏的内存错误。最后一个字段 array ptr 是来自于 OSObject 的对象指针。重写它使得内核可以访问任意构造的对象，从而导致内核里的任意代码执行。另一种攻击是直接重写存储数据的内存块。</p>
<p>我们对于 重写 iOS 内核的 C++ 对象的内存布局，以及由此产生的可行性做了一个简单概述。记住这些信息，在下一节中，我们将利用这些对象来填充 iOS 内核堆并控制它的布局。</p>
<h2 id="控制-iOS-内核堆"><a href="#控制-iOS-内核堆" class="headerlink" title="控制 iOS 内核堆"></a><strong>控制 iOS 内核堆</strong></h2><p>要成功利用内核堆错误，则要求将内核堆从一个未知起点通过可控制的方式指向一个可预测的状态。对于这个需求，有很多不同的技术方法。其中最简单的方法叫做堆喷射 ( heap spraying ) ，即使用特殊的数据通过重复触发相同的分配来填充内存，直到内存中很大比例都被这种模式充满（或者触发另一个终止条件）。为了实现堆喷射，要求有一个分配基元来重复执行。由于这种技术早在 2001 年之前就已经开始使用，所以谁是堆喷射的最初发明者尚未可知。</p>
<p>A.Sotirov 在2007年提出了一个更复杂更好的用来控制堆状态的技术，叫做堆风水。在他的黑帽子谈话中，他描述了如何从未知状态的堆得到被控制的内存布局。首先需要重复分配内存来填充堆中的空洞。一旦所有的空洞都被封闭了，则进一步的分配将会使得彼此相邻。在这些相邻的区域释放内存块，将会在可控位置戳一些洞，使得接下来的分配都在这些洞的位置上。这种方式可以控制堆布局，即溢出缓存区将会正好溢出我们想要溢出的数据。当然，实现一个堆风水技术也要比堆喷射更复杂，它不仅需要一个分配基元，还需要一个回收基元。</p>
<p>在以前的公开 iOS 内核利用中，分配以及回收基元通常是特殊的，且依赖于实际的开发功能。在此，我们将介绍一个更为通用的方法，可以在没有易被攻击的特殊分配和回收基元的条件下，控制内核堆。</p>
<p>iOS 内核有一个非常有趣的函数叫做 OSUnserializeXML()。它由许多 IOKit API 中的函数来调用，被用于将对象从用户空间传送到内核空间。这个函数以 XML.plist 的格式 提供一个输入，可以是数字，布尔量，字符串，数据，字典，数组，集合和引用。下面是一个 XML plist 的例子。</p>
<pre><code>&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;IsThere&lt;/key&gt;
        &lt;string&gt;one technique to rule them all?&lt;/string&gt;
    &lt;key&gt;Answer&lt;/key&gt;
        &lt;true /&gt;
    &lt;key&gt;Audience&lt;/key&gt;
        &lt;string&gt;meet OSUnserializeXML()&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre><p>通过构建这样一个 XML.plist 数据包，可以在内存中创建任意对象集合，以及在所有大小和形状中，分配任意数量的不同类型的对象。我们可以用它来控制内核堆，以任何我们喜欢的方式。下表是一个基本对象的内存大小的备忘清单。</p>
<p><img src="/images/2016-08-29-译-iOS-Kernel-Heap-Armageddon/图17.png" alt=""></p>
<p>现在我们来看一下如何构造 XML 数据，使其实现堆喷射和堆风水。</p>
<hr>
<ul>
<li>重复分配</li>
</ul>
<p>我们首先需要做的是分配任意大小任意数量的内存块。不幸的是，在 XML.plist 数据块内部进行循环是不可能的。但是也没有限制，因此我们可以按照我们的想法分配尽可能多的数据。</p>
<pre><code>&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;ThisIsOurArray&lt;/key&gt;
     &lt;array&gt;
            &lt;string&gt;again and&lt;/string&gt;
            &lt;string&gt;again and&lt;/string&gt;
            &lt;string&gt;again and&lt;/string&gt;
            &lt;string&gt;again and&lt;/string&gt;
            &lt;string&gt;again and&lt;/string&gt;
            &lt;string&gt;again and&lt;/string&gt;
            &lt;string&gt;...&lt;/string&gt;
     &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt; 
</code></pre><p>这个示例使用一个数组对象，并填充任意数量的字符串。为了做一个内核堆喷射，我们只需要构建一个非常庞大的 XML 数据对象，并传给一个合适的 IOKit API 函数。</p>
<hr>
<ul>
<li>分配受攻击者控制的数据</li>
</ul>
<p>在 iOS 内核堆喷射中，使用字符串数据对象的缺点是，不能包含空字节。因此，用完全任意数据结构的字符串对象来实现堆喷射是不可行的。不过我们还有数据对象可以施以援手。由于数据是 base64 编码的，所以它允许创建任意数据结构，没有字符值的限制。另外，内核也支持简单的 16 进制。比如下面的例子。</p>
<pre><code>&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
       &lt;key&gt;ThisIsOurData&lt;/key&gt;
        &lt;array&gt;
              &lt;data&gt;VGhpcyBJcyBPdXIgRGF0YSB3aXRoIGEgTlVMPgA8+ADw=&lt;/data&gt;
              &lt;data format=&quot;hex&quot;&gt;00112233445566778899aabbccddeeff&lt;/data&gt;
              &lt;data&gt;...&lt;/data&gt;
       &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt; 
</code></pre><p>数据对象类型也更方便，因为它读取到4049块中，因此在解码 XML 时，它在我们感兴趣的内存空间中不分配块。通过结合数组和数据，我们可以执行内核水平的堆喷射。堆风水需要更多的控制条件，接下来我们会提到。</p>
<hr>
<ul>
<li>用应用数据填充任意大小的内存块</li>
</ul>
<p>对于堆风水，我们不仅需要分配任意大小的内存块，还需要在重写导致的任意代码执行时，分配被数据填充的任意大小内存块。对于此，我们再次使用数据对象类型（当然也可以使用字典对象类型）。</p>
<pre><code>&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
       &lt;key&gt;ThisArrayAllocates_4_Bytes&lt;/key&gt;
        &lt;array&gt;
              &lt;true /&gt;
        &lt;/array&gt;
       &lt;key&gt;ThisArrayAllocates_12_Bytes&lt;/key&gt;
        &lt;array&gt;
              &lt;true /&gt;&lt;true /&gt;&lt;true /&gt;
        &lt;/array&gt;
       &lt;key&gt;ThisArrayAllocates_28_Bytes&lt;/key&gt;
        &lt;array&gt;
              &lt;true /&gt;&lt;true /&gt;&lt;true &gt;&lt;true /&gt;&lt;true /&gt;&lt;true /&gt;&lt;true /&gt;
       &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre><p>在这个示例中，我们使用分配的数组来填充内存，并指向布尔对象。布尔量不会是单独的分配内存的对象。相反，它们会增加一个 global true 对象的引用计数。如果通过重写它向内核提供我们精心设计的对象，则会导致任意代码执行。字典对象类型可用于这种攻击。不同的是，在这个例子中，单个对象指针的乘数为 4，在字典中是 8，因为存储了 键值 (key) 和数值 (value) 对象的指针。</p>
<hr>
<ul>
<li>在分配区域戳洞</li>
</ul>
<p>实现对内核堆完全控制的最后一件事是不仅需要分配任意大小的内存块，还需要能够在这些分配中戳任意大小的洞。在字典对象的帮助下，我们可以了解如何在已分配的内存中戳洞，请看下面的示例。</p>
<pre><code>&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
  &lt;key&gt;AAAA&lt;/key&gt;
      &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA    &lt;/data&gt;
   &lt;key&gt;BBBB&lt;/key&gt;
      &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA    &lt;/data&gt;
   &lt;key&gt;CCCC&lt;/key&gt;
      &lt;data&gt;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ    &lt;/data&gt;
   &lt;key&gt;DDDD&lt;/key&gt;
      &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA    &lt;/data&gt;
   &lt;key&gt;EEEE&lt;/key&gt;
      &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA    &lt;/data&gt;
   &lt;key&gt;CCCC&lt;/key&gt;
      &lt;true /&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre><p>在这个例子中，可以看到键值 CCCC 被设定了两次。第一次是插入到字典中，第二次更新键值的数值，且前一个值已被破坏。这个数据对象的破坏将会释放该数值对象本身，以及释放由 base64 编码重复的 Z 字符所组成的数值。我们也因此在内存中有效地戳了一个洞。拼图的最后一块是你构建的用于控制堆的 XML.plist 文件是没有问题的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们首先重演了 iOS 内核堆空间分配，以及不同作者在之前所提到的它的利用。接着，我们介绍了其他的内核堆分配器以及它们所带来的额外的堆元数据。我们讨论了如何重写这些可以被利用的数据，以及提到了这些分配器目前的变化。接下来我们离内核堆元数据结构的利用只有一步之遥，我们讨论了 iOS C++ 内核对象，以及他们在内存结构的布局和在内存中重写他们可以得到什么。最后，我们介绍一种通用的技术，利用 OSUnserializeXML() 可以实现堆喷射和堆风水。这种新技术不仅可以使用任意数据喷射堆来完全控制它的布局，也可以使用有意思的内核应用数据来填充内核堆，该应用数据采用内核级别的 C++ 对象形式，一旦重写，将会允许任意代码执行。</p>
<hr>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><p>[1] E. PERLA, M. OLDANI, ”A GUIDE TO KERNEL EXPLOITATION - ATTACKING THE CORE”, 2010, HTTP://WWW.ATTACKINGTHECORE.COM/<br>[2] S. ESSER, ”IOS KERNEL EXPLOITATION, BLACKHAT USA”, 2011 HTTPS://MEDIA.BLACKHAT.COM/BH-US- 11/ESSER/BH_US_11_ESSER_EXPLOITING_THE_IOS_KERNEL_WP.PDF<br>[3] C. MILLER, D. BLAZAKIS, D. DAIZOVI, S. ESSER, V. IOZZO, R.-P. WEINMANN, ”IOS HACKER’S HANDBOOK”, 2012, HTTP://EU.WILEY.COM/WILEYCDA/WILEYTITLE/PRODUCTCD-1118204123,DESCCD- DESCRIPTION.HTML<br>[4] A. SOTIROV, ”HEAP FENG SHUI IN JAVASCRIPT, BLACKHAT EUROPE”, 2007 HTTPS://WWW.BLACKHAT.COM/PRESENTATIONS/BH-USA-07/SOTIROV/WHITEPAPER/BH- USA-07-SOTIROV-WP.PDF </p>
<p><strong>声明: 本文转载需标明出处，禁止用于商业目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;人世间最让你感动的是什么？   ——是遥远的相似性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;你所了解到的关于 iOS 内核堆利用的公开研究，最终都可以归结于对内核堆空间的分配，这个观点由 nemo 首先提出来。总而言之，这种分配将空间内的内核内存分成相同大小的内存块。通过利用重写堆元数据，可以向空间的空闲列表 (freelist) 中注入任意内存区。&lt;/p&gt;
&lt;p&gt;在本文中，我们将首先概括关于内核堆空间分配的知识，像 nemo 和 Esser 之前所提到的那样。接着，我们将看一看其他的内核堆管理以及 Mac OSX 和 iOS 内核中的内存分配封装函数。在简单介绍这些封装函数之后，我们将进一步介绍这些分配器在最新版本 iOS 5 之后的改变。本文将继续介绍内核层的应用数据重写与直接攻击分配器的空闲列表区之间的差异。最后将展示一种普遍的技术：为了实现内核堆利用，通过执行内核堆喷射  (heap spraying) ，来控制内核堆布局的布局。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://amywushu.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Kernel" scheme="https://amywushu.github.io/tags/Kernel/"/>
    
      <category term="Heap" scheme="https://amywushu.github.io/tags/Heap/"/>
    
  </entry>
  
</feed>
