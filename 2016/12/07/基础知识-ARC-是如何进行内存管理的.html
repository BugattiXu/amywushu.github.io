<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ARC,内存管理," />





  <link rel="alternate" href="/atom.xml" title="Amywushu" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.0.2" />






<meta name="description" content="基础知识提要对于 Objective-C 对象来讲，手动内存管理主要是通过以下方法来进行的：   

retain ：　　 　使得对象的引用计数+1
release：　　　使得对象的引用计数-1
autorelease：　使得对象的引用计数在 autorelease pool 释放的时候再-1
dealloc：　　　当对象的引用计数为0的时候自动调用，表明对象被释放">
<meta property="og:type" content="article">
<meta property="og:title" content="ARC 是如何进行内存管理的">
<meta property="og:url" content="https://amywushu.github.io/2016/12/07/基础知识-ARC-是如何进行内存管理的.html">
<meta property="og:site_name" content="Amywushu">
<meta property="og:description" content="基础知识提要对于 Objective-C 对象来讲，手动内存管理主要是通过以下方法来进行的：   

retain ：　　 　使得对象的引用计数+1
release：　　　使得对象的引用计数-1
autorelease：　使得对象的引用计数在 autorelease pool 释放的时候再-1
dealloc：　　　当对象的引用计数为0的时候自动调用，表明对象被释放">
<meta property="og:updated_time" content="2017-08-20T04:33:56.768Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ARC 是如何进行内存管理的">
<meta name="twitter:description" content="基础知识提要对于 Objective-C 对象来讲，手动内存管理主要是通过以下方法来进行的：   

retain ：　　 　使得对象的引用计数+1
release：　　　使得对象的引用计数-1
autorelease：　使得对象的引用计数在 autorelease pool 释放的时候再-1
dealloc：　　　当对象的引用计数为0的时候自动调用，表明对象被释放">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>





  <title> ARC 是如何进行内存管理的 | Amywushu </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Amywushu</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ARC 是如何进行内存管理的
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-07T00:00:00+08:00" content="2016-12-07">
              2016-12-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv">本文阅读量
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="基础知识提要"><a href="#基础知识提要" class="headerlink" title="基础知识提要"></a>基础知识提要</h2><p>对于 Objective-C 对象来讲，手动内存管理主要是通过以下方法来进行的：   </p>
<ul>
<li>retain ：　　 　使得对象的引用计数+1</li>
<li>release：　　　使得对象的引用计数-1</li>
<li>autorelease：　使得对象的引用计数在 autorelease pool 释放的时候再-1</li>
<li>dealloc：　　　当对象的引用计数为0的时候自动调用，表明对象被释放</li>
</ul>
<a id="more"></a>
<p>因为只有 OC 对象是分配在堆上的（其他如 C 语言对象是分配在栈上的），因此也<strong>只有 OC 对象在未开启 ARC 的时候需要我们手动管理内存。</strong></p>
<p>对象的计数器，用来表示当前有多少个事物想令此对象继续存活下去。</p>
<h2 id="对象的内存管理"><a href="#对象的内存管理" class="headerlink" title="对象的内存管理"></a>对象的内存管理</h2><h3 id="简单内存管理示例"><a href="#简单内存管理示例" class="headerlink" title="简单内存管理示例"></a>简单内存管理示例</h3><p>　　简单的手动内存管理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ARC 无效</span></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="comment">//obj变量持有NSObject对象，该对象的引用计数=1</span></div><div class="line"></div><div class="line">[obj <span class="keyword">retain</span>];</div><div class="line"><span class="comment">//NSObject对象的引用计数+1 = 2</span></div><div class="line"></div><div class="line">[obj release];</div><div class="line"><span class="comment">//NSObject对象的引用计数-1 = 1</span></div><div class="line"></div><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">//创建自动释放池</span></div><div class="line"></div><div class="line">[obj autorelease];</div><div class="line"><span class="comment">//NSObject对象加入自动释放池，引用计数+1 = 2</span></div><div class="line"></div><div class="line">[pool drain];</div><div class="line"><span class="comment">//自动释放池释放，对池中的所有对象发送 release 消息，因此NSObject对象引用计数-1 = 1</span></div><div class="line"></div><div class="line">[obj release];</div><div class="line"><span class="comment">//NSObject对象的引用计数-1 = 0</span></div><div class="line"><span class="comment">//自动调用 dealloc 方法，废弃对象</span></div></pre></td></tr></table></figure>
<p>　　<br>　　对应的 ARC 自动管理：<br>　　因为开启 ARC 后，编译器会自动对 OC 对象进行内存管理，所以，ARC 有效时，不能调用 retain /release /autorelease /dealloc /retainCount 方法，其中，dealloc 方法可以覆写，但依然不能显示调用。   </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//启用 ARC</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="comment">//obj变量持有NSObject对象，该对象的引用计数=1</span></div><div class="line"></div><div class="line">	<span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">		<span class="keyword">id</span> __autoreleasing obj2 = obj;</div><div class="line">		<span class="comment">//obj变量将NSObject对象赋给带有__autoreleasing关键字的obj2变量，相当于[obj autorelease]；</span></div><div class="line">		<span class="comment">//NSObject对象加入自动释放池，引用计数+1 = 2</span></div><div class="line"></div><div class="line">	&#125; <span class="comment">//自动释放池释放，对池中的所有对象发送 release 消息，因此NSObject对象引用计数-1 = 1</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//NSObject对象的持有者obj变量超出其作用域，引用失效</span></div><div class="line"><span class="comment">//因此，NSObject对象的引用计数-1 = 0</span></div><div class="line"><span class="comment">//自动调用 dealloc 方法，废弃对象</span></div></pre></td></tr></table></figure>
<h3 id="ARC-对象所有权修饰符"><a href="#ARC-对象所有权修饰符" class="headerlink" title="ARC 对象所有权修饰符"></a>ARC 对象所有权修饰符</h3><ul>
<li>__strong： 默认修饰符，表示对对象的“强引用”，该修饰符修饰的变量在超出其作用域时被废弃，随着强引用的失效，自动 release 自己所持有的对象；</li>
<li>__weak： 弱引用。不持有对象，若该对象被废弃，则弱引用变量将自动赋值为 nil；</li>
<li>__unsafe_unretained： 同 __weak 一样不持有对象，但对象废弃时，不会自动为 nil，容易出现悬挂指针；</li>
<li>__autoreleasing： 相当于调用 autorelease 方法，即对象被注册到 autorelease pool 中。</li>
</ul>
<p><strong>什么叫做持有对象？</strong><br>　　我们知道 OC 对象的变量类型其实是指针变量，这些指针存储在栈上，指针指向的对象存储在堆中。<br>&emsp;&emsp;指针 X1 指向对象 A，并使得对象 A 的引用计数+1，则我们说指针变量 X1 持有对象 A，或者 X1 持有该对象的强引用。<br>&emsp;&emsp;指针 X2 虽然指向对象 A，但是对对象 A 的引用计数没有任何影响，即 X2 不指向对象 A，对象 A 的引用计数也不会减1；X2 指向对象 A，对象 A 的引用计数也不会加1，则我们说指针变量 X2 不持有对象 A。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//启用 ARC</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj_weak = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj_unsafe;</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="comment">//obj变量默认加了__strong修饰符，所以是强引用，持有NSObject对象，该对象的引用计数+1 =1</span></div><div class="line">	</div><div class="line">	obj_weak = obj0;</div><div class="line">	<span class="comment">//obj1持有NSObject对象的弱引用，对引用计数无影响</span></div><div class="line"></div><div class="line">	obj_unsafe = obj0;</div><div class="line">	<span class="comment">//obj_unsafe不持有NSObject对象，对引用计数无影响</span></div><div class="line"></div><div class="line">	<span class="keyword">id</span> obj_strong = obj0;</div><div class="line">	<span class="comment">//obj3变量默认加了__strong修饰符，是强引用，NSObject对象的引用计数+1 = 2</span></div><div class="line"></div><div class="line">	<span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">		<span class="keyword">id</span> __autoreleasing obj_auto = obj0;</div><div class="line">		<span class="comment">//obj变量将NSObject对象赋给带有__autoreleasing关键字的obj_auto变量，相当于[obj autorelease]；</span></div><div class="line">		<span class="comment">//obj_auto暂时持有NSObject对象，稍后释放；</span></div><div class="line">		<span class="comment">//NSObject对象被暂时持有，加入自动释放池，引用计数+1 = 3</span></div><div class="line"></div><div class="line">	&#125; <span class="comment">//自动释放池释放，obj_auto变量超出其作用域，持有对象失效，</span></div><div class="line">	  <span class="comment">//也就是自动释放池取消obj_auto变量对对象的暂时持有权，</span></div><div class="line">	  <span class="comment">//相当于对池中的NSObject对象发送 release 消息，因此对象引用计数-1 = 2</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//NSObject对象的持有者obj0变量超出其作用域，强引用失效，释放自己所持有的对象，NSObject对象的引用计数-1 = 1；</span></div><div class="line"><span class="comment">//持有者obj_storng变量超出作用域，强引用失效，释放自己所持有的对象，对象的引用计数-1 = 0；</span></div><div class="line"><span class="comment">//NSObject对象无持有者（即引用计数为0），自动调用 dealloc 方法，废弃对象；</span></div><div class="line"><span class="comment">//该对象的弱引用变量obj_weak失效，自动赋值为nil;</span></div><div class="line"><span class="comment">//obj_unsafe变量表示的对象已被废弃，变为悬挂指针。</span></div></pre></td></tr></table></figure>
<p><br><br><strong>修饰符番外</strong><br>　　id 的指针或对象的指针会默认加上 __autoreleasing 修饰符，如<code>NSError **error</code>，实际上为<code>NSError *__autoreleasing* error</code>。</p>
<p>&emsp;&emsp;对象被废弃时，含有 __weak 修饰符的变量将会有以下动作：<br>1) 从 weak 表中获取以废弃对象的地址为键值的记录；<br>2) 将包含在记录中的所有 __weak 修饰符变量的地址，赋值为 nil；<br>3) 从 weak 表中删除记录；<br>4) 从引用计数表中删除以被废弃对象的地址为键值的记录。   </p>
<p>　　也就是说含有 __weak 修饰符的变量所指的对象被废弃时，会比其他修饰符多执行前3步，如果大量使用 weak 修饰符，则会消耗相应的 CPU 资源，因此<strong>最好是在需要避免循环引用的时候才使用 __weak 修饰符。</strong></p>
<p>在访问有 __weak 修饰符的变量时，其实会访问注册到 autorelease pool 的对象。</p>
<pre><code>
{
    id __weak obj1 = obj;
}

//实际上为：
id obj1;
objc_initWeak(&obj1, obj);
objc_destroyWeak(&obj1);
</code></pre>

<pre><code>
{
    id __weak obj2 = obj;
    NSLog(@"%@", obj2);
}


//实际上为：
id obj2;
objc_initWeak(&obj2, obj);

id tmp = objc_loadWeakRetained(&obj2);
objc_autorelease(tmp);

NSLog(@"%@", tmp);

objc_destroyWeak(&obj2);
</code></pre>

<p>　　在 @autoreleasepool 块结束之前，使用多少次 weak 变量，就会注册到 autorelease pool 中多少次，所以在使用 __weak 修饰符的变量时，最好赋值给 __strong 修饰符的变量后使用。</p>
<blockquote>
<p>可通过 <code>_objc_autoreleasePoolPrint()</code> 函数打印出注册到 autorelease pool 中的对象。</p>
</blockquote>
<h2 id="方法的内存管理"><a href="#方法的内存管理" class="headerlink" title="方法的内存管理"></a>方法的内存管理</h2><p>方法命名规则：    </p>
<ul>
<li>alloc/new/copy/mutableCopy 使用这些名称开头的方法，意味着生成的对象自己持有；</li>
<li>以上名称之外的其他方法取得的对象，自己不持有。</li>
</ul>
<p>注：以 <code>init</code> 开始的方法必须是实例方法，且必须要返回对象，该返回对象不注册到 autorelease pool 上，基本上只是对 alloc 方法返回值的对象进行初始化处理并返回该对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ARC 无效</span></div><div class="line">- (<span class="keyword">id</span>)allocObject</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)object</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	[obj autorelease];</div><div class="line">	<span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj1 = [obj0 allocObject];</div><div class="line">	<span class="comment">//alloc开头的方法返回自己生成并持有的对象，</span></div><div class="line">	<span class="comment">//即obj变量持有NSObject对象，该对象的引用计数至少=1</span></div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">id</span> obj2 = [obj0 object];</div><div class="line">	<span class="comment">//取得对象存在，但obj2变量不持有NSObject对象，</span></div><div class="line">	<span class="comment">//该对象的引用计数无变化</span></div><div class="line"></div><div class="line">	[obj2 <span class="keyword">retain</span>];</div><div class="line">	<span class="comment">//使得obj2持有对象，对象的引用计数+1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//启用ARC</span></div><div class="line">- (<span class="keyword">id</span>)object</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	<span class="keyword">return</span> obj；</div><div class="line">	<span class="comment">//因为return使得变量obj超出作用域，所以强引用失效，自己持有的对象会被释放，</span></div><div class="line">	<span class="comment">//但是因为该对象是作为方法的返回值，所以ARC会自动将其注册到autorelease pool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　也就是说<strong>对于非自己持有的方法，比如 [NSMutableArray array] 方法，在其方法内部，自动为返回值添加了 autorelease，我们可以使用这个返回值，但并不持有返回值所指的对象。</strong>在其对应的 autorelease pool 释放时（在主线程中，就是 RunLoop 循环一次之后），返回值所指的对象即被释放，如果没有对返回值执行 retain 操作，则对象没有持有者，自动调用 dealloc 方法，被废弃。</p>
<p>　　我们常说，ARC 有效时，编译器会自动插入 retain/release/autorelease 方法。但实际上，<strong>ARC 在调用这些方法时，并不是通过普通的 OC 消息派发机制，而是直接调用底层 C 语言版本</strong>，比如 ARC 会调用与 retain 等价的底层函数 objc_retain。这样做更能优化性能，也是不能覆写 retain、release、autorelease 方法的原因，因为这些方法不会被直接调用。</p>
<p>　　ARC 的优化还体现在很多方面，如使用非自己持有的方法，我们可以看到，在方法内部的返回对象调用 autorelease，与方法返回后，在调用方对返回对象 retain，两个操作实际上是可以抵消的，ARC 会自动做这方面的优化。以 [NSMutableArray array] 为例：</p>
<pre code="">
// ARC 代码
+ (id)array
{
    return [[NSMutableArray alloc] init];
}

//编译器的模拟代码
+ (id)array
{
    id obj = objc_msgSend(NSMutableArray, @selector(alloc));
    objc_msgSend(obj, @selector(init));
    return objc_autoreleaseReturnValue(obj);
}

// ARC 代码
{
    id obj = [NSMutableArray array];
    //obj默认为 __strong 修饰符变量，相当于[返回对象 retain]
}

//编译器的模拟代码
id obj = objc_msgSend(NSMutableArray, @selector(array));

objc_retainAutoreleasedReturnValue(obj);

objc_release(obj);

</pre>

<p>　　<code>objc_autoreleaseReturnValue</code> 函数会检查使用该函数的方法，或函数调用方的执行命令列表，如果方法的调用方在调用了该方法后，紧接着调用了 <code>objc_retainAutoreleasedReturnValue()</code> 函数，那么就不将返回的对象注册到 autorelease pool 中，而是直接传递到方法的调用方。</p>
<h2 id="Block-的内存管理"><a href="#Block-的内存管理" class="headerlink" title="Block 的内存管理"></a>Block 的内存管理</h2><p>Block 的内存管理主要涉及到循环引用的问题。</p>
<p>Block 的创建一般是在栈上，但以下情况会被复制到堆上：<br>1) 调用 Block 的 copy 方法时；<br>2) Block 作为函数返回值时；<br>3) 将 Block 赋值给 __strong 修饰符的 id 类型或 Block 类型的成员变量时；<br>4) 在方法名中含有 usingBlock 的 Cocoa 框架方法或 GCD 的 API 中传递 Block 时。    </p>
<p>我们知道 Block 会在声明时截获在 Block 内部将会用到的变量，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">	<span class="keyword">void</span> (^blk) (<span class="keyword">void</span>) = ^&#123;printf(val);&#125;;</div><div class="line">	val = <span class="number">20</span>;</div><div class="line">	blk();</div><div class="line"><span class="comment">//输出结果：10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="strong-变量"><a href="#strong-变量" class="headerlink" title="__strong 变量"></a>__strong 变量</h3><p>　　对于 OC 对象而言，当 Block 从栈上被复制到堆上时，会对将要用到的带有 __strong 修饰符的变量执行 retain 操作，也就是 Block 会持有这个变量所指向的对象。如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启 ARC</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^blk_t)(<span class="keyword">id</span>);</div><div class="line">blk_t blk;</div><div class="line">&#123;</div><div class="line">	<span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">	blk = ^(<span class="keyword">id</span> obj) &#123;</div><div class="line">		[array addObject:obj];</div><div class="line">		<span class="built_in">NSLog</span>(<span class="string">@"count = %ld"</span>, [array count]);</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//array超出作用域，变量被废弃，</span></div><div class="line"> <span class="comment">//但blk持有array所指向的对象，所以对象不会被废弃</span></div><div class="line"></div><div class="line">blk([[<span class="built_in">NSObject</span> alloc] init]);</div><div class="line">blk([[<span class="built_in">NSObject</span> alloc] init]);</div><div class="line"></div><div class="line"><span class="comment">//输出： count = 1</span></div><div class="line"><span class="comment">//      count = 2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li>开启 ARC 时，对于修饰符为 __strong 且捕获了外部变量（无论是否是 OC 对象）的 Block，会自动进行 copy 操作，将 Block 从栈上复制到堆上，由 NSStackBlock 转换为 NSMallocBlock。</li>
<li>修饰符为 __strong 但未捕获外部变量的 Block，或者通过声明全局变量来声明 Block，都会自动创建为 NSGlobalBlock 类型。</li>
<li>无法手动创建堆上的 Block，即 NSMallocBlock。</li>
</ul>
<p>　　上述代码中 array 变量超出了作用域因此被废弃，但是 blk 调用的时候仍可以使用 array 是为什么呢？<br>　　是因为 Block 在进行 copy 操作的时候，会在自身结构体中添加一个同类型的 __strong 修饰符的 array 变量，所以访问的并不是之前我们所定义的 <code>id array</code>，而是 <code>block-&gt;array</code>。</p>
<h3 id="block-变量"><a href="#block-变量" class="headerlink" title="__block 变量"></a>__block 变量</h3><p>　　__block 修饰符的变量可以在 Block 中更改变量，Block 在捕获变量时，会对有该修饰符的变量生成 __Block_byref_val 结构体。</p>
<pre><code>
__block val =10;

//在 Block 中存储为结构体
__Block_byref_val_0 val = {
    void *__isa;
    __Block_byref_val_0 *__forwarding;  //= &val
    int __flags;
    int __size; //=sizeof(__Block_byref_val_0)
    int val; //=10
}
</code></pre>

<p>　　__Block_byref_val 结构体的成员变量 __forwarding 是指向该结构体实例自身的指针。Block 在访问__block 修饰的变量时，是通过这个指针来的：<br>　　<code>block -&gt;val(block结构体中的成员变量)-&gt;__forwarding-&gt;val</code>。<br>当 Block 从栈复制到堆上是，该变量也会复制到堆上，栈上的原来指向自身的 __forwarding 指针会改变为指向堆上的 __block 变量。</p>
<p>　　因此 __block 修饰的变量在 ARC 和非 ARC 中是有差别的。</p>
<p>　　ARC 有效时，__block 变量除了可以在 Block 内部修改之外，无其他用处，是否 retain 取决于变量的 ARC 修饰符（__strong 持有、__weak 不持有等）。那么由于可修改，因此<strong>可以在 Block 内部对造成循环引用的变量赋值为 nil，释放掉自身的对象持有权，从而打破循环。</strong></p>
<p>　　ARC 无效时，在 [block copy] 之后，没有__block 修饰符的变量对象会被自动后台 retain，从而被 Block 持有；而有__block 修饰符的变量反而不会被 retain，不会被 Block 持有。因此<strong>对变量添加 __block 修饰符可以在非 ARC 情况下打破循环引用。</strong></p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>既然 Block 也会持有对象，那么就很容易出现不易发现的循环引用问题了。如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启 ARC</span></div><div class="line">- (<span class="keyword">void</span>)loadView </div><div class="line">&#123; </div><div class="line"></div><div class="line"> [<span class="keyword">super</span> loadView]; </div><div class="line"></div><div class="line"> _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span> </div><div class="line"> object:<span class="literal">nil</span> </div><div class="line"> queue:<span class="literal">nil</span> </div><div class="line"> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123; </div><div class="line"> [<span class="keyword">self</span> dismissModalViewControllerAnimated:<span class="literal">YES</span>]; </div><div class="line"> &#125;]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如之前所提到的 Blcok 被复制到堆上的情况，<code>在使用方法名中含有 usingBlock 的 Cocoa 框架方法</code>时会被自动 copy 到堆上，从而对捕获到的 <code>__strong 变量</code> 执行 retain 操作，Block 持有该变量。</p>
<p>&emsp;&emsp;在本例中，<strong>self 的成员变量 _observer</strong> 会 <code>copy 一份 Block</code>，从而持有 Block，而 Block 中用到了默认为 <code>__strong 修饰符的 self变量</code> ，从而持有 self，self 类本身又持有 <code>成员变量 _observer</code>，从而导致循环引用，使得谁都无法被最终释放，导致内存泄漏。</p>
<p>所以，要打破这种循环引用，需要使得 [block copy] 时不会 retain 捕获到的 self 变量。</p>
<blockquote>
<p>注意：函数的闭包和 block 如果没有引用任何实例或类变量，其本身也不会造成循环引用，另外在 GCD 中，一般不会造成循环引用。这个例子之所以会造成循环引用，是因为 _observer 是 self 的成员变量。</p>
</blockquote>
<h4 id="方法一：-在-ARC-中使用不持有对象的-weak-或-unsafe-unretain-修饰符"><a href="#方法一：-在-ARC-中使用不持有对象的-weak-或-unsafe-unretain-修饰符" class="headerlink" title="方法一： 在 ARC 中使用不持有对象的 __weak 或 __unsafe_unretain 修饰符"></a>方法一： 在 ARC 中使用不持有对象的 <code>__weak</code> 或 <code>__unsafe_unretain</code> 修饰符</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启 ARC</span></div><div class="line">- (<span class="keyword">void</span>)loadView </div><div class="line">&#123; </div><div class="line"> [<span class="keyword">super</span> loadView];</div><div class="line"> </div><div class="line"> __<span class="keyword">weak</span> TestViewController *wself = <span class="keyword">self</span>; </div><div class="line"></div><div class="line"> _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span> </div><div class="line"> object:<span class="literal">nil</span> </div><div class="line"> queue:<span class="literal">nil</span> </div><div class="line"> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123; </div><div class="line"></div><div class="line"> __<span class="keyword">strong</span> TestViewController *sself = wself;</div><div class="line"> </div><div class="line"> [sself dismissModalViewControllerAnimated:<span class="literal">YES</span>]; </div><div class="line"> &#125;]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于拥有 __weak 修饰符的 wself 变量，Block 复制时，不会对该变量指向的对象进行 retain，从而不持有该对象，对该对象的引用计数无影响。在 Block 内部又通过 __strong 修饰符的 sself 变量来持有对象，是为了避免在 Block 执行过程中，该对象被其他地方释放，从而造成访问错误。这实际上是一种延迟 self 的 retain 操作，使得它不在 Block 被 copy 的时候 retain，而是在执行的时候 retain。</p>
<p>&emsp;&emsp;因为如果在最初 copy 的时候 retain，那么只有等 Block 被废弃时，该变量才会被废弃，从而释放对对象 X 的持有权。但是由于循环引用，该变量始终直接或间接的持有 block 对象，所以 Block 永远不会被废弃，进而也不会释放对象 X 的持有权，从而造成这两块内存永远不会被回收，即内存泄漏。</p>
<p>&emsp;&emsp;而在执行的时候 retain，ARC会对 Block 的执行作用域的变量自动进行内存管理，执行完毕后即释放，不会等到 Block 被废弃时才能被释放，因此打破了循环引用。</p>
<h4 id="方法二：在-ARC-中使用-block-修饰符，并在-Block-中为其赋值为-nil"><a href="#方法二：在-ARC-中使用-block-修饰符，并在-Block-中为其赋值为-nil" class="headerlink" title="方法二：在 ARC 中使用 __block 修饰符，并在 Block 中为其赋值为 nil"></a>方法二：在 ARC 中使用 <code>__block 修饰符，并在 Block 中为其赋值为 nil</code></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开启 ARC</span></div><div class="line">- (<span class="keyword">void</span>)loadView </div><div class="line">&#123; </div><div class="line"> [<span class="keyword">super</span> loadView];</div><div class="line"> </div><div class="line"> __blok TestViewController *wself = <span class="keyword">self</span>; </div><div class="line"></div><div class="line"> _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span> </div><div class="line"> object:<span class="literal">nil</span> </div><div class="line"> queue:<span class="literal">nil</span> </div><div class="line"> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</div><div class="line"> [wself dismissModalViewControllerAnimated:<span class="literal">YES</span>]; </div><div class="line"> &#125;]; </div><div class="line"></div><div class="line"> wself = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在 Block 执行时释放了对 self 所指向的对象的持有权，因此 Block 执行后即打破循环引用，同样不会等到 Block 被废弃时才能释放对象的持有权，因此没有内存泄漏。</p>
<p>&emsp;&emsp;这种方法的缺点是，一定要确保 Block 会执行。如果有多种分支，而某一条分支中的 Block 不会执行，那么这条分支同样会造成内存泄漏。</p>
<h4 id="方法三：在非-ARC-中使用-block-修饰符"><a href="#方法三：在非-ARC-中使用-block-修饰符" class="headerlink" title="方法三：在非 ARC 中使用 __block 修饰符"></a>方法三：在非 ARC 中使用 <code>__block 修饰符</code></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ARC 无效</span></div><div class="line">- (<span class="keyword">void</span>)loadView </div><div class="line">&#123; </div><div class="line"> [<span class="keyword">super</span> loadView];</div><div class="line"> </div><div class="line"> __block TestViewController *wself = <span class="keyword">self</span>; </div><div class="line"></div><div class="line"> _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span> </div><div class="line"> object:<span class="literal">nil</span> </div><div class="line"> queue:<span class="literal">nil</span> </div><div class="line"> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</div><div class="line"> [wself dismissModalViewControllerAnimated:<span class="literal">YES</span>]; </div><div class="line"> &#125;]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在非 ARC 中，Block 不持有 __block 修饰符修饰的对象，因此也不会造成循环引用。</p>
<p>注1：在使用委托 delegate 时，属性要用 weak 关键字也是为了避免循环引用。<br>注2：在异常 <code>NSException</code> 处理过程中，也容易遗忘对象释放，从而造成内存泄漏，一般须在 <code>@finally</code> 中将未释放的资源释放掉。当然如果该异常直接造成程序崩溃，也就无所谓释放不释放了。</p>
<p>以上即是 ARC 与非 ARC 的内存管理区别，以及 ARC 是如何将手动管理转换为自动管理的。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] 《Objective-C 高级编程 - iOS 与 OS X 多线程和内存管理》<br>[2] 《Effective Objective-C 2.0》<br>[3]&ensp;Objective-C中block实现和技巧学习　<a href="http://www.tuicool.com/articles/aQFV7bv" target="_blank" rel="external">http://www.tuicool.com/articles/aQFV7bv</a></p>

      
    </div>
	<div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">
  <p><span>本文标题:</span><a href="/2016/12/07/基础知识-ARC-是如何进行内存管理的.html">ARC 是如何进行内存管理的</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Amywushu 的个人博客">Amywushu</a></p>
  <p><span>原始链接:</span><a href="/2016/12/07/基础知识-ARC-是如何进行内存管理的.html" title="ARC 是如何进行内存管理的">https://amywushu.github.io/2016/12/07/基础知识-ARC-是如何进行内存管理的.html</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://amywushu.github.io/2016/12/07/基础知识-ARC-是如何进行内存管理的.html"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
	clipboard.on('success', $(function(){
	  $(".fa-clipboard").click(function(){
		swal({   
		  title: "",   
		  text: '复制成功',   
		  html: false,
		  timer: 500,   
		  showConfirmButton: false
	    });
	  });
    }));  
</script>

      
	</div>
    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ARC/" rel="tag">#ARC</a>
          
            <a href="/tags/内存管理/" rel="tag">#内存管理</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/09/逆向知识-通过汇编解读-objc_msgSend.html" rel="next" title="通过汇编解读 objc_msgSend">
                <i class="fa fa-chevron-left"></i> 通过汇编解读 objc_msgSend
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/16/译-Analysis-and-exploitation-of-Pegasus-kernel-vulnerabilities-CVE-2016-4655-CVE-2016-4656.html" rel="prev" title="（译）Analysis and exploitation of Pegasus kernel vulnerabilities (CVE-2016-4655 / CVE-2016-4656)">
                （译）Analysis and exploitation of Pegasus kernel vulnerabilities (CVE-2016-4655 / CVE-2016-4656) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar1.jpg"
               alt="Amywushu" />
          <p class="site-author-name" itemprop="name">Amywushu</p>
          <p class="site-description motion-element" itemprop="description">好吧，你想知道点儿什么？</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://amywushu.github.io" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识提要"><span class="nav-number">1.</span> <span class="nav-text">基础知识提要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存管理"><span class="nav-number">2.</span> <span class="nav-text">对象的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单内存管理示例"><span class="nav-number">2.1.</span> <span class="nav-text">简单内存管理示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC-对象所有权修饰符"><span class="nav-number">2.2.</span> <span class="nav-text">ARC 对象所有权修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法的内存管理"><span class="nav-number">3.</span> <span class="nav-text">方法的内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Block-的内存管理"><span class="nav-number">4.</span> <span class="nav-text">Block 的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#strong-变量"><span class="nav-number">4.1.</span> <span class="nav-text">__strong 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#block-变量"><span class="nav-number">4.2.</span> <span class="nav-text">__block 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环引用"><span class="nav-number">4.3.</span> <span class="nav-text">循环引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法一：-在-ARC-中使用不持有对象的-weak-或-unsafe-unretain-修饰符"><span class="nav-number">4.3.1.</span> <span class="nav-text">方法一： 在 ARC 中使用不持有对象的 __weak 或 __unsafe_unretain 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法二：在-ARC-中使用-block-修饰符，并在-Block-中为其赋值为-nil"><span class="nav-number">4.3.2.</span> <span class="nav-text">方法二：在 ARC 中使用 __block 修饰符，并在 Block 中为其赋值为 nil</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法三：在非-ARC-中使用-block-修饰符"><span class="nav-number">4.3.3.</span> <span class="nav-text">方法三：在非 ARC 中使用 __block 修饰符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">5.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Amywushu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
    <span class="site-pv">总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcss.com/velocity/1.3.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcss.com/velocity/1.3.1/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
