<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[[逆向知识] 通过汇编解读 objc_msgSend]]></title>
      <url>https://amywushu.github.io/2016/11/09/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86-%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB-objc_msgSend.html</url>
      <content type="text"><![CDATA[想做一条瀑布，每一秒钟都可以跳楼。 基础知识提要调用方法，本质是发送消息。比如： 12345Person *p = [[Person alloc] init];[p test];// 本质是发送消息： clang -rewrite-objc main.m((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName("test")); 当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个，objc_msgSend、 objc_msgSend_stret、 objc_msgSendSuper 和 objc_msgSendSuper_stret。 发送给对象的父类的消息会使用 objc_msgSendSuper ; 有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret ; 其它的消息都是使用 objc_msgSend 发送的。 也就是说所有的方法调用，都是通过 objc_msgSend（或其大类）来实现转发的。 objc_msgSend 的具体实现由汇编语言编写而成，不同平台有不同的实现，objc-msg-arm.s、objc-msg-arm64.s、objc-msg-i386.s、objc-msg-simulator-i386.s、objc-msg-simulator-x86_64.s、objc-msg-x86_64.s。本文以 ARM64 平台为例。 汇编分析汇编概览如下图所示： 流程图分析分支1：X0 = 0 这条分支很简单，对照图1的总图来讲，就是蓝色的那条线，第1行-&gt;第2行-&gt; 29 -&gt; 35~41 ret。先对传入的 X0（即对象地址）作判断，如果 X0=0，则直接返回。 分支2：X0 &lt; 0 (Tagger Pointer) 对照图1来讲，流程为黄色的那根线，1~2 -&gt; 29~34 -&gt; 6 -&gt; … 判断 X0&lt;0，即地址最高位为1，这是 Tagger Pointer 类型的标志（对于 ARM64 架构来讲），关于这个类型，部分内容在我之前的文章copy 与 mutableCopy（传说中的深浅拷贝）中5.4节有提到。 loc_1800b9c30 这个模块取出了 Tagger Pointer 的类索引表，赋值给 X10。下一行 UBFM X11,X0,#0x3C,#0x3F，取 0x3C~0x3F 中的值赋给 X11，其余位以0填充，与图1第32行的意思相同，都是取出最高4位，比如 NSString 类型的 Tagger Pointer 最高4位为 a，运算过后，x11 = 0xa 。接着 LDR X9,[X10,X11,LSL#3]，先运算 X11 左移3位等于 0x50。x9 = x10[0x50]，也就是在类索引表中查找所属类。找到后跳到 loc_1800b9BD0，也就是图1中的第6行。 分支3：X0 &gt; 0 这是大多数情况会走的流程。 1234567//类的结构struct objc_class : objc_object &#123; // Class ISA; //继承自objc_object Class superclass; // 父类引用 cache_t cache; // 用来缓存指针和虚函数表 class_data_bits_t bits; // class_rw_t 指针加上 rr/alloc 标志&#125; 接下来我们根据汇编指令一条条来分析。LDR X13,[X0] 取出调用方法的对象指针保存的地址（从上面代码可以看出，就是 isa 指针地址），赋给 X13。 AND X9,X13,#0x1FFFFFFF8 解读这条指令之前，要先了解 isa 指针的结构。 1234567891011121314151617union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19; &#125;;&#125;; 首先先来看一下这 64 个二进制位每一位的含义： 区域名 代表信息 indexed (0位) 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc (1、2位) 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls (3~35位) 类的指针 magic (36~41位) 固定值，用于在调试时分辨对象是否未完成初始化 weakly_referenced (42位) 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating (43位) 表示该对象是否正在析构 has_sidetable_rc (44位) 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc (45~63位) 存储引用计数值减一后的结果 也就是说 0x1FFFFFFF8 取1的位数刚好是 shiftcls 的区域，是 isa 指针中存储的该对象的类指针。所以 X9 = isa-&gt;cls。 LDP X10,X11,[X9,#0X10]： X9+16个字节，也就是跳过了8个字节的 isa 指针，和8个字节的 superclass 指针，到了 cache 指针这里。 cache 的结构如下： 12345678910struct bucket_t &#123; void *sel; void *imp;&#125;;struct cache_t &#123; struct bucket_t *buckets; mask_t mask; mask_t occupied;&#125;; 因此，X10=buckets 指针，X11 的低32位为 mask，高32位为 occupied（mask_t 是 int 类型）。 occupied是 cache 中实际拥有的方法个数。 AND W12,W1,W11： 将 _cmd 的低32位和 cache-&gt;mask 作与运算。ADD X12,X10,X12,LSL#4: 与运算后的结果左移4位，作为buckets的索引（相当于数组下标）。这里也可以看出 mask 的作用，应该是一种优化的 hash 表搜索算法。将取得的指针赋给 X12。LDP X16,X17,[X12]： 由 bucket 的结构可以知道，这里是将 bucket [(_cmd&amp;mask)&lt;&lt;4] 中的 sel 赋给 X16，imp 赋给 X17（imp 为方法的入口地址）。这三条指令就是通过 mask 找到一个 bucket 元素。 CMP X16,X1, B.NE loc_1800B9BEC, BR X17： 这3条指令很好理解，比较 bucket 元素中的 sel 和 _cmd 的值是否相等，不相等，则跳到 loc_1800B9BEC 模块，相等则直接进入对应 imp（方法入口地址）。 loc_1800B9BEC CBZ X16,_objc_msgSend_uncached_impcache： 如果 X16=0 则跳到 objc_msgSend_uncached 这个函数去，不等于0则继续执行。CMP X12,X10, B.EQ loc_1800B9C00： 判断是否已搜索到最后一个 bucket（即 bucket 的初始地址），是则跳到 loc_1800B9C00，否则继续执行。 先讨论没有搜索完的情况，loc_1800B9C00 LDP X16,X17,[X12,#-0X10], B loc_1800B9BE0： bucket 元素减16字节，即跳到前一个 bucket 元素，同样将 sel 和 imp 指针赋值，然后跳回与 _cmd 比较的那条指令循环。 直到搜索完毕，ADD X12,X12,W11,UXTW #4： x12 = buckets+(mask&lt;&lt;4)，扩大搜索范围，在缓存内全面搜索。（进行到这一步，说明 bucket [(_cmd&amp;mask)&lt;&lt;4] 元素之前的 bucket 已全部被占满，且均不是我没要找的方法）LDP X16,X17,[X12]： 跟之前的命令意思一样。 可以看到，之后的流程跟前面的循环一模一样，但是加大了搜索范围，从 bucket [mask&lt;&lt;4] 往前开始搜索（进行到这一步说明 bucket [(_cmd&amp;mask)&lt;&lt;4] 前面的缓存都占满了）。从以上分析，我们可以看出，能在缓存 cache 里找到的方法，会直接跳到入口地址 X17。而没有在 cache 里的方法，则要继续调用 objc_msgSend_uncached 函数。现在，返回图1再查看，是不是觉得思路清晰很多呀！ 关于缓存 cahcecache 的原则是缓存那些可能要执行的函数地址。 有一种说法是，只要函数执行过一次的方法，都会存入缓存。但在我的测试中，有时候会遵循这种说法，有时候又不尽然，执行过的方法不一定会被放入缓存，但没有被执行过的肯定不会进入缓存。具体什么样的操作会导致方法被载入缓存，还需要从类的初始化探讨起，此点存疑。 cahce 其实是一个 hash 表，通过 _cmd&amp;mask 的结果再左移4位，作为索引值，如果这个地址存的方法 _cmd2 与 _cmd 不同，那么有两种原因：一是 _cmd 压根儿没被载入缓存；二是由于它的索引值跟 _cmd 相同，但 _cmd2 先进入缓存，因此 _cmd2 占据了这个位置。这时，如果 _cmd 被载入缓存的话，则在 _cmd2 索引值-1的位置存入，如果这个位置也不为0，那么继续前往索引值-2的位置，直到找到一个0位，然后存入。 在上面的汇编分析中，我们也能看到这个思路。在图1中第8行，取 bucket 索引值；第10行，比较 _cmd 值；如果不同则第13行，查看是否为0，如果为0，则不再搜索，直接进入 uncache 函数（因为是0的话，由上一段分析可以知道，说明这个方法没有在缓存里）；如果不为0，则前往索引值-1（地址-16）的位置查找；第17行返回循环到第10行。 下面来做一个测试， 123456789@implementation aboutObjectiveC-(void)objc_msgSend1 &#123; NSLog(@"objc_msgSend1"); [self objc_msgSend2];&#125;-(void)objc_msgSend1 &#123; NSLog(@"objc_msgSend2");&#125; 如上图所示，在 main.m 第17行下断点（即第二次执行 objc_msgSend1 方法时），si 进入 objc_msgSend 函数，然后执行到图1中的第7行，打印各值如下 w11 是 mask 的值为0011，跟 init的 SEL(0x1883910b6) 指针作与运算，为0x2，左移4位为0x20，因此在 x10+0x20 处载入 cache；跟 objc_msgSend1 的 SEL(0x10008ecac) 作与运算，为0x0，左移4位还是0x0，因此在 x10 bucket 处载入 cache；同样对 objc_msgSend2 作与运算左移4位，也是0x20，而 bucket[0x20] 处已经被 init 占用了，因此前往 bucket[0x20-0x10] 处，这个位置是0，所以将 objc_msgSend2 填入缓存的这个位置。如下图所示： lookUpImpOrForward 函数我们已经知道如果缓存中没有找到该方法，则跳转执行 _objc_msgSend_uncached_impcache，在这里又会执行 bl _class_lookupMethodAndLoadCache3 指令，跳转到 _class_lookupMethodAndLoadCache3，由汇编语言的实现回到了 C 函数的实现，这个函数只是简单的调用了另外一个函数 lookUpImpOrForward，并传入参数 cache=NO，这个函数是 Runtime 消息机制中非常重要的一环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; Class curClass; IMP imp = nil; Method meth; bool triedResolver = NO; runtimeLock.assertUnlocked(); //因为 _class_lookupMethodAndLoadCache3 传入的 cache = NO， //所以这里会直接跳过 if 中代码的执行， //在 objc_msgSend 中已经使用汇编代码查找过了。 if (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp; &#125; //根据 cls-&gt;isRealized() 来判断是否要调用 realizeClass 函数在 // Objective-C 运行时 初始化的过程中会对其中的类进行第一次初始化 //也就是执行 realizeClass 方法，为类分配可读写结构体 class_rw_t //的空间，并返回正确的类结构体。 if (!cls-&gt;isRealized()) &#123; rwlock_writer_t lock(runtimeLock); realizeClass(cls); &#125; //根据 cls-&gt;isInitialized() 来判断类的是不是 initialized， //也就是类的首次被使用的时候，其 initialize 方法要在此时被调用 //一次，也仅此一次。没有 initialized 的话，则调用 //_class_initialize 函数去触发这个类的 initialize 方法，然后 //会设置 isInitialized 状态为 initialized if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; _class_initialize (_class_getNonMetaClass(cls, inst)); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125; // The lock is held to make method-lookup + cache-fill atomic // with respect to method addition. Otherwise, a category could // be added but ignored indefinitely because the cache was re-filled // with the old value after the cache flush on behalf of the category. retry: runtimeLock.read(); // 是否开启GC(垃圾回收)； if (ignoreSelector(sel)) &#123; imp = _objc_ignored_method; cache_fill(cls, sel, imp, inst); goto done; &#125; // 这里再次查找 cache 是因为有可能 cache 真的又有了，因为锁的原因 imp = cache_getImp(cls, sel); if (imp) goto done; // Try this class's method lists. meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; &#125; // Try superclass caches and method lists. curClass = cls; while ((curClass = curClass-&gt;superclass)) &#123; // Superclass cache. imp = cache_getImp(curClass, sel); if (imp) &#123; if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; &#125; &#125; // Superclass method list. meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; // No implementation found. Try method resolver once. if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); _class_resolveMethod(cls, sel, inst); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn't help. // Use forwarding. imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlockRead(); // paranoia: look for ignored selectors with non-ignored implementations assert(!(ignoreSelector(sel) &amp;&amp; imp != (IMP)&amp;_objc_ignored_method)); // paranoia: never let uncached leak out assert(imp != _objc_msgSend_uncached_impcache); return imp;&#125; lookUpImpOrForward 主要做了以下几个工作 判断类的初始化 cls-&gt;isRealized() 和 cls-&gt;isInitialized() ； 是否开启GC(垃圾回收)； 再次尝试去缓存中获取IMP； 找不到接着去 class 的方法列表查找，找到会加入缓存列表然后返回 IMP； 找不到，去父类的缓存列表找，然后去父类的方法列表找，找到了会加入自己的缓存列表，然后返回 IMP，找不到循环此步骤，直到找到基类； 都找不到则 _class_resolveMethod 函数会被调用，进入消息动态处理、转发阶段。 对于 objc_msgSend 反汇编的分析就结束啦！如果是在动态调试过程中，遇到 objc_msgSend 想要进入被调用的方法的话，有 cache，则直接 si 进入 br X17，如果没有 cache，则在 _objc_msgSend_uncached_impcache 函数中最后几行中的 br X17 指令输入 si 即可进入被调用方法。 Reference[1] ObjC Runtime（五）：消息传递机制 https://xiuchundao.me/post/runtime-messaging[2] 从源代码看 ObjC 中消息的发送 http://draveness.me/message/[3] objc_msgSend内部到底做了什么？ http://oriochan.com/14710029019312.html[4] 用 isa 承载对象的类信息 http://www.desgard.com/isa/[5] 深入解析 ObjC 中方法的结构 https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[语法] copy 与 mutableCopy（传说中的深浅拷贝）]]></title>
      <url>https://amywushu.github.io/2016/10/20/%E8%AF%AD%E6%B3%95-copy-%E4%B8%8E-mutableCopy%EF%BC%88%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89.html</url>
      <content type="text"><![CDATA[光是永恒的，所以你是永恒的。 概念对象拷贝有两种方式：浅拷贝和深拷贝。 浅拷贝(shallow copy)，并不拷贝对象本身，仅仅是拷贝指向对象的指针。如果 B = [A 浅拷贝]，则 A、B 两个对象中都保存的同一个指针，如果 A 通过这个指针改变了指针指向的对象，那么 B 指针指向的对象也就随之改变了； 深拷贝是直接拷贝整个对象到另一块内存中，开辟新的地址来存储，两个对象至此一别，再无关联。 对于集合对象（如 NSSArray、NSDictionary 等）而言，又有单层深拷贝与完全拷贝之分。 单层深拷贝(one-level-deep copy)：指的是对于被拷贝对象，至少有一层是深拷贝。完全拷贝(real-deep copy)：指的是对于被拷贝对象的每一层都是对象拷贝。 copy 与 mutableCopy不管是集合类对象，还是非集合类对象，接收到 copy 和 mutableCopy 消息时，都遵循以下准则： copy 返回不可变(imutable)对象，如果对copy返回值使用可变对象方法就会crash； mutablCopy 默认返回可变(mutable)对象（如果拷贝后的对象本身是不可变的，那也没法变呀，总不能改变人对象的类型吧，比如 NSString *str2 = [str1 mutableCopy]; ）。 示例头文件首先定义了一系列会用到的属性，另外，我在宏定义里去掉了 NSLog 的时间戳，然后定义了 AmyLog ，用来显示对象的所属类，以及地址。 123456789101112131415161718192021222324252627#import &lt;Foundation/Foundation.h&gt;#define NSLog(FORMAT, ...) fprintf(stderr, "%s\n", [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String] )#define AmyLog(_var) NSLog(@" (%@ *) %p\n", [_var class], _var)@interface FirstClass : NSObject//非集合类对象@property (nonatomic, copy) NSString *string;@property (nonatomic, strong) NSMutableString *mString;@property (nonatomic, copy) NSString *stringCopy;@property (nonatomic, copy) NSString *stringMutableCopy;@property (nonatomic, strong) NSMutableString *mStringCopy;@property (nonatomic, strong) NSMutableString *mStringMutableCopy;//集合类对象@property (nonatomic, copy) NSArray *array;@property (nonatomic, copy) NSArray *arrayCopy;@property (nonatomic, copy) NSArray *arrayMutableCopy;@property (nonatomic, strong) NSMutableArray *mArrayCopy;@property (nonatomic, strong) NSMutableArray *mArrayMutableCopy;@end 非集合类对象(NSString)执行代码：1234567891011121314FirstClass *fC = [[FirstClass alloc] init]; fC.string = @"originString";fC.stringCopy = fC.string; //浅，指针 (不可变String）fC.stringMutableCopy = [fC.string mutableCopy]; //深，新地址 (可变String) fC.mStringCopy = [fC.string copy]; //浅，指针 (不可变String）fC.mStringMutableCopy = [fC.string mutableCopy]; //深，新地址 (可变String) NSLog(@"\n非集合类对象(NSString)：\noriginal address: "); AmyLog(fC.string);NSLog(@"copy -&gt; NSString: "); AmyLog(fC.stringCopy);NSLog(@"mutableCopy -&gt; NSString: "); AmyLog(fC.stringMutableCopy);NSLog(@"copy -&gt; NSMutableString: "); AmyLog(fC.mStringCopy);NSLog(@"mutableCopy -&gt; NSMutableString: "); AmyLog(fC.mStringMutableCopy); 打印结果： __NSCFConstantString 和 __NSCFString__NSCFConstantString __NSCFConstantString 对象，就是字符串常量对象，存储在栈上，创建之后由系统来管理内存释放.相同内容的 NSCFConstantString 对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的 retainCount ，对其进行 retain 或 release 也不会影响其引用计数。 当创建一个 NSCFConstantString 对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。 总的来说，对于 NSCFConstantString 对象，只要字符串内容不变，就不会分配新的内存地址，无论你是赋值、 retain、 copy 。这种优化在大量使用 NSString 的情况下可以节省内存，提高性能。 ——摘自简书作者路子：NSString：内存简述，Copy与Strong关键字 对于 NSString 来说，以下几种赋值方法将会保存为 NSCFConstantString 对象： 直接赋值，如 NSString *str = @&quot;STR&quot;; stringWithString ,如 NSString *str = [NSString stringWithString:@&quot;Str&quot;]; str1 = str2; str1 = [str2 copy/retain]; __NSCFString __NSCFString 对象是 NSString 的一种子类，存储在堆上，不属于字符串常量对象。该对象创建之后和其他的 Obj 对象一样引用计数为1，对其执行 retain 和 release 将改变其 retainCount 。 诸如 [NSString stringWithFormat:] 方法以及 NSMutableString 创建的字符串等，都是构造的这种对象。 分析mutableCopy 意味着你告诉编译器，我拷贝过来的这个对象可能会改变，因此编译器肯定会新开辟一个地址给你。 因此采用这种方式的都是深拷贝（包括单层深拷贝和完全拷贝）。通过结果我们也可以看见，正如我们前面所提到的，copy 返回不可变对象，因此对于原始对象是不可变的 NSSring 类型，完全没有必要再新分配一块内存。因此对于不可变的非集合对象，采用 mutableCopy 方式的拷贝就是深拷贝，copy 是浅拷贝。 非集合类对象(NSMutableString)执行代码：123456789101112fC.mString = [NSMutableString stringWithString:@"mStringingi"];fC.stringCopy = fC.mString; //深，新地址（可变String）fC.stringMutableCopy = [fC.mString mutableCopy]; ////深，新地址 (可变String) fC.mStringCopy = [fC.mString copy]; //深，新地址，可变String）fC.mStringMutableCopy = [fC.mString mutableCopy]; //深，新地址，(可变String) NSLog(@"\n非集合类对象(NSMutableString)：\noriginal address: "); AmyLog(fC.mString);NSLog(@"copy -&gt; NSString: "); AmyLog(fC.stringCopy);NSLog(@"mutableCopy -&gt; NSString: "); AmyLog(fC.stringMutableCopy);NSLog(@"copy -&gt; NSMutableString: "); AmyLog(fC.mStringCopy);NSLog(@"mutableCopy -&gt; NSMutableString: "); AmyLog(fC.mStringMutableCopy); 打印结果： 分析我们已经知道只要用 mutableCopy ，对于非集合对象的拷贝，无论可变不可变，都是深拷贝。 copy 对于不可变对象的拷贝是浅拷贝。那么对于 copy 可变对象呢？如上图的结果所示，是深拷贝。 也很容易理解，我这个对象是可变的，我随时可能通过其他引用它的指针来改变这个对象，现在你要拷贝一份不可变的内容，编译器当然不能直接把它的指针给你啦，这样岂不就是可变的了？所以要新分配给你一块内存，用来储存你拷贝的不可变内容。 就是说，对于可变非集合对象的拷贝，copy 和 mutableCopy 都是做的深拷贝。 __NSTaggedPointerStringTagged Pointer 是一个能够提升性能、节省内存的有趣的技术。我们知道，程序都使用了指针地址对齐概念。指针地址对齐就是指在分配堆中的内存时往往采用偶数倍或以2为指数倍的内存地址作为地址边界。几乎所有系统架构，包括 Mac OS 和 iOS，都使用了地址对齐概念对象。对于 iOS 和 MAC 来说，指针地址是以16个字节（或16的倍数）为对齐边界的，进一步说，分配的内存地址最后4位永远都是0。 Tagged Pointer 利用了这一现状，它使对象指针中非零位（最后4位）有了特殊的含义。在苹果的64位 Objective-C 实现中，若对象指针的最低有效位为1(即奇数)，则该指针为 Tagged Pointer 。这种指针不通过解引用 isa 来获取其所属类，而是通过接下来三位的一个类表的索引。该索引是用来查找所属类是采用 Tagged Pointer 的哪个类。剩下的60位则留给类来使用。 Tagged Pointer 有一个简单的应用，那就是 NSNumber 。它使用60位来存储数值。最低位置1。剩下3位为 NSNumber 的标志。这样，就可以存储任何所需内存小于60位的数值。 注：以上是在 x86_64 架构中，在 iOS ARM64 架构中，是最高4位表示所属类，对于最低位，不同类有不同的意义，比如 NSString 代表的是字符长度 length，NSNumber 我猜测代表的是数字长度类型。 从外部看，Tagged Pointer很像一个对象。它能够响应消息，因为 objc_msgSend 可以识别 Tagged Pointer 。假设你调用 integerValue ，它将从那60位中提取数值并返回。这样，每访问一个对象，就省下了一次真正对象的内存分配，省下了一次间接取值的时间。同时引用计数可以是空指令，因为没有内存需要释放。对于常用的类，这将是一个巨大的性能提升。 NSString 也是如此。对于那些所需内存小于60位的字符串，它可以创建一个 Tagged Pointer。所需内存大于60位的则放置在真正的 NSString 对象里。这使得常用的短字符串的性能得到明显的提升。 关于 NSString 中的 Tagged Pointer 编码比较复杂，条件是长度小于11位，且由 Apple 的代码生成在运行时，即不是直接定义，而是如上图中 mutableCopy/copy 转换而来，编码详情请见【译】采用Tagged Pointer的字符串 在 WWDC2013 中 APPLE 对于它的特点是这样总结的： Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和NSDate Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free 。跟 __NSCFConstantString 一样拥有非常大的 retainCount ，因为压根儿就不在堆上啊。 在内存读取上有着3倍的效率，创建时比以前快106倍。 对 NSString 对象来说，当非字面量的数字，英文字母字符串的长度小于等于11的时候会自动成为 NSTaggedPointerString 类型（赋值为常量除外），如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 __NSCFString 类型。 Tagged Pointer 举例比如我们将上面的字符串改为 fC.mString = [NSMutableString stringWithString:@&quot;mStringingin&quot;];，比之前少了1位，只有11位，则输出结果就变为了： 除了拷贝的可变副本（最后一个），其他不可变副本都是 Tagged Pointer ，直接存储的值。 集合类对象(NSArray)执行代码：1234567891011121314fC.array = [NSArray arrayWithObjects:@"hello",@"world",@"baby", nil];fC.arrayCopy = fC.array; //浅，指针fC.arrayMutableCopy = [fC.array mutableCopy]; //单层深，新地址 fC.mArrayCopy = [fC.array copy]; //浅，指针fC.mArrayMutableCopy = [fC.array mutableCopy]; //单层深，新地址 NSLog(@"\n集合类对象(NSArray)：\noriginal address: "); AmyLog(fC.array); AmyLog([fC.array objectAtIndex:1]); NSLog(@"copy -&gt; NSArray: "); AmyLog(fC.arrayCopy); AmyLog([fC.arrayCopy objectAtIndex:1]);NSLog(@"mutableCopy -&gt; NSArray: "); AmyLog(fC.arrayMutableCopy); AmyLog([fC.arrayMutableCopy objectAtIndex:1]);NSLog(@"copy -&gt; NSMutableArray: "); AmyLog(fC.mArrayCopy); AmyLog([fC.mArrayCopy objectAtIndex:1]);NSLog(@"mutableCopy -&gt; NSMutableArray: "); AmyLog(fC.mArrayMutableCopy); AmyLog([fC.mArrayMutableCopy objectAtIndex:1]); 打印结果： 分析从结果可以发现，对于第一层的指针来说，跟 NSString 是一样的，copy 浅拷贝（复制指针，即指针不变）， mutableCopy 深拷贝（新内存），但是打印数组中的元素，就发现元素的指针并没有变，也就是第二层依然是浅拷贝，因此这就是单层深拷贝了。 集合的浅拷贝和完全拷贝集合的浅拷贝有非常多种方法（上面那种 copy 就是）。当你进行浅拷贝时，会向原始的集合发送retain消息，引用计数加1，同时指针被拷贝到新的集合。 现在让我们看一些浅拷贝的例子： 123NSArray *shallowCopyArray = [someArray copyWithZone:nil]; NSSet *shallowCopySet = [NSSet mutableCopyWithZone:nil]; NSDictionary *shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:NO]; 那么如何才能对元素也进行深拷贝呢？ 集合的深拷贝有两种方法。可以用 initWithArray:copyItems: 将第二个参数设置为 YES 即可深拷贝，如 1NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES]; 如果你用这种方法深拷贝，集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深拷贝到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深拷贝，会在运行时出错。 copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深拷贝。 第二个方法是将集合进行归档(archive)，然后解档(unarchive)，如： 1NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]]; 终于搞定这个了！ Reference[1] NSString：内存简述，Copy与Strong关键字 http://www.jianshu.com/p/0e98f37114e3[2] iOS 集合的深复制与浅复制 https://www.zybuluo.com/MicroCai/note/50592[3] 深入理解Tagged Pointe http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/[4] 【译】采用Tagged Pointer的字符串 http://www.cocoachina.com/ios/20150918/13449.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[逆向知识] 栈·参数存储方式]]></title>
      <url>https://amywushu.github.io/2016/10/12/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86-%E6%A0%88%C2%B7%E5%8F%82%E6%95%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.html</url>
      <content type="text"><![CDATA[人在世上，爱欲之中，独生独死，独来独往，苦乐自知，无有代者。 基础提要：栈结构ARM内存中的栈区域是满递减的，由高地址向低地址增长，SP指针始终指向最后一个压入栈的地址，即栈顶地址。如图所示： 为什么栈向下增长？ 每一个可执行C程序，从低地址到高地址依次是：text，data，bss，堆，栈，环境参数变量；其中堆和栈之间有很大的地址空间空闲着，在需要分配空间的时候，堆向上涨，栈往下涨。 这样设计可以使得堆和栈能够充分利用空闲的地址空间。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。 所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。 所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化！！ —— 引用自判断栈和堆的生长方向 如何判断栈的增长方向？很简单，我们可以通过两个函数的调用来确定。我们知道，执行一个函数时，这个函数的相关信息都会出现栈之中，比如参数、返回地址和局部变量。 那么，当它调用另一个函数时，在它栈信息保持不变的情况下，会把被调用函数的信息放到栈中。两个函数的相对信息位置是固定的，肯定是先调用的函数其信息先入栈，后调用的函数其信息后入栈。只需要判断这两个地址，就可以判断栈的增长方向了。 比如设计两个函数fun1()和fun2()，将fun1()中某参数的地址传给fun2()，且在fun1()中调用fun2()，最后在fun2()中打印出两个函数参数的地址，则大功告成。 12345678910111213141516void func2(int *a)&#123; int b=0; printf("%x\n%x\n",a,&amp;b);&#125;void func1()&#123; int a=0; func2(&amp;a);&#125;int main()&#123; func1();&#125; 我这边测试打印出来分别是5fbff91c 5fbff8f4 （我用的Xcode 的 command line 测试的）。即a 的地址 &gt; b的地址，先分配的是高地址，因此是高地址向低地址增长。 如何区分栈底和栈顶？很容易将分不清高地址和低地址到底谁才是栈底。我们可以想象一个桶，这个桶内的空间就是栈区，桶底（栈底）是确定了的，不会改变。往桶内加水，即使入栈操作。水面即是栈顶，也就SP指针所在的位置。我们不断加水，只会使得水面（栈顶SP指针）增长，而水底（栈底指针）仍旧不变。而栈区又是高地址向低地址增长，因此栈区的最高地址是为栈低，SP指针是栈顶指针。 只不过，在实际应用情况中，我们经常习惯将栈底指针（最高地址处）放在最上面，SP指针在最下面，也就是一个倒扣着的桶，在失重情况下，往倒扣的桶里加水，水底仍然是栈底指针，水面仍然是栈顶指针，水面随着水的加入而增长。 实例在逆向过程中，我一直对栈的数据排列非常迷惑，现在让我们一起来解决它吧！以下是我逆向遇到的一个小实例： 在图中我们可以看到目前运行到第三行代码stp x9, x10, [sp, #8]处，stp指令是将寄存器中的值依次存入后面的地址处。我们先打印一下x12 x8以及sp的值： 那么也就是说第二条指令stp x12, x8, [sp, #24]已经将x12和x8的值存入了sp+24地址处。 那么我们仔细想想，究竟这两个值在栈上是如何排列的呢？先存入的是x12还是x8呢？第二参数是在sp+24的高地址处还是低地址处呢？ 我们打印一下内存上的信息看一下就知道了： /4xb: 就是说从该地址开始，按照1个字节，16进制的方式打印4个单位。/4xw: 按照4个字节，16进制的方式打印4个单位 更多有关打印格式的请看gdb查看内存区命令 跟上面x12和x8比较后，我们可以发现，内存在打印的时候，每个打印单位（这里是以w格式打印，即4个字节）我们要从右往左看（从高地址到低地址），单位内部还是从左到右为高地址到低地址。也就是说，第一个打印单位的最右边是当前打印地址（最低地址），最后一个打印单位的最左边是最高地址。如下图所示，图中箭头为从高地址指向低地址： 那么，也就是说，x12存储在从sp+24 (0x16fd11cc8)到sp+31 (0x16fd11ccf)之间x8 存储在从sp+32 (0x16fd11cd0) 到sp+39 (0x16fd11cd7)之间 则他们之间的具体排列如下图所示 小测试（第3、4行命令）现在我们大概对数据的排布有一个更深入的理解了，那么，就以第三行命令来测试一下我们是否真的理解了吧！在执行第三条命令之前，我们先看一下x9，x10的值： 那么，按照上一条命令的方式，我们来猜测一下内存排布吧。stp x9, x10, [sp, #8] 这条命令的意思是，将x9，x10中的值依次放入sp+8所在的位置。那么，到底是存储在sp+8的高地址处，还是低地址处呢？ 其实很好理解，因为栈是向低地址处增长的，如果我们往sp到sp+8处写入这两个寄存器的值，很明显是不够的，这里只有8个字节的空间，而我们需要16个字节，因此sp指针就会往低地址处移动，则栈空间就增大了，但是sp指针并没有改变，这些指令都没有关于要改变栈顶指针的，所以这个想法是错误的。 也就是说，在往栈内存储数据时，都在高地址到给定的地址之间存入，即向栈中已分配的空间存入。 那么，x9，x10依次存储在sp+8 ~ sp+15，sp+16 ~ sp+23之间。 按照之前讲的打印单位与单位之间是从右往左为从高地址到低地址，单位内的顺序是从左往右，1个地址存储1个字节（8位，两个字符）。我们按照一个字节一个字节的打印（16进制），则 在sp+8 ~ sp+15处的数据应为：64 c3 af 0b 00 00 00 00； 在sp+16 ~ sp+31处的数据应为：86 dd a9 b1 00 00 00 00。 如果我们按照4xw的格式打印，则应该是sp+8: 0x0bafc364 0x00000000，sp+16: 0xb1a9dd86 0x00000000 我们打印一下看看猜测是否正确： 完全正确！我们继续往下执行第4条命令：str x11, [sp]这条命令的意思是，将x11中的值放入sp所指的地方。我们知道sp是栈顶指针，是栈的最后一个元素所在的位置，所以x11肯定是存储在sp到sp+8之间。打印一下x11的值： 那么，依旧按照之前的方法，每个打印单位，要从右往左看： 那么sp的地址0x16fd11cb0到sp+8 (0x16fd11cb8)之间依次应该为ef e1 0f db 00 00 00 00； 按照4xw的打印格式则应该为：0x16fd11cb0: 0xdbofelef 0x00000000 0x0bafc364 0x00000000 （sp+8 ~ sp+15是刚刚我们执行过的x9的值） 打印一下： 完全正确！好了，现在关于内存栈的数据排列，你是不是有更清晰的图像印在脑海里了呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[练习] C语言编程题（2016年360笔试习题之病毒]]></title>
      <url>https://amywushu.github.io/2016/09/21/%E7%BB%83%E4%B9%A0-C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%A2%98-2016%E5%B9%B4360%E7%AC%94%E8%AF%95%E4%B9%A0%E9%A2%98%E4%B9%8B%E7%97%85%E6%AF%92.html</url>
      <content type="text"><![CDATA[人生如此，拿酒来。 题目（编程题：病毒）小B最近对破解和程序攻击产生了兴趣，她迷上了病毒，然后可怕的事情发生了。不知道什么原因，可能是小B的技术水平还不够高，小B编写的病毒程序在攻击一个服务器时出现了问题。尽管成功的入侵了服务器，但并没有按照期望的方式发挥作用。 小B的目的很简单：控制服务器内存区域，试图在内存中装入从1到n之间的n个自然数，以覆盖内存区域。可能是小B对编程理解上的问题，病毒似乎没有完全成功。可能是由于保护机制的原因，内存写入只接受二进制的形式，所以十进制表达中除了0和1之外的其他值都没有成功写入内存。小B希望知道，究竟有多少数成功的写入了服务器的内存！ 输入 输入中有多组测试数据，每组测试数据在单独的一行中，为整数n（1&lt;=n&lt;=10^9）。 输出 对每组测试数据，在单独的行中输出问题的答案。 举例 输入：10输出： 2 输入：20输出：3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt;/** * 1. 输入的字符数组从最高位开始依次与1做比较 * 2. 小于等于1 取原值，并比较下一位，如果没有下一位，则返回； * 3. 大于1，则其后的位数都取1，并返回； * 4. 将得到的字符数组看作二进制，并转化为十进制。 * */static char addarray[10] = "";static char array1[10] = "";char * fun(char *cstring, int n) &#123; char compareString = *(cstring + n); char *onestring = "1"; char array[10] = ""; char *rec = ""; if (strcmp(onestring,&amp;compareString) &gt;= 0) &#123; //compareString &lt;= 1 array[0] = compareString; if (*(cstring+n+1)) &#123; strcat(array, fun(cstring, n+1)); strcpy(addarray, array); rec = addarray; &#125; else rec = cstring + n; &#125; else &#123; //compareString &gt; 1 for (int i = 0; i &lt; (strlen(cstring) - n); i++) &#123; strcat(array1, onestring); &#125; rec = array1; &#125; return rec;&#125;int main(int argc, const char * argv[]) &#123; char nstring[10]; printf("Input String:"); scanf("%s", nstring); char *resultString = fun(nstring, 0); printf("%s\n", resultString); long result = strtol(resultString, NULL, 2); printf("%ld\n", result); return 0;&#125; 输出： Input String:20113 Input String:1040101111 Input Stirng:23003041111111127 知识点总结关于字符数组和字符串在函数间的传递 从代码中可以看到我用了两个静态数组变量，之所以不直接定义在函数体内作为局部变量是因为： 当用字符指针char*返回字符数组首地址时，函数体内的局部变量数组里的值已经被释放，返回的首地址虽然没有变，但里面的值已经无意义了。 例如： 12345678910111213#include "stdio.h" char *test() &#123; //char tmp[30]="测试"; char *tmp="测试";//写成这样可以用指针返回数组首地址 return tmp; &#125; void main(void) &#123; printf("%s",test()); &#125; 打印出来的值可能是乱码也能为nil。解决方式：1. static全局变量 123456789101112#include "stdio.h" char *test()&#123; static char tmp[30]="static测试"; return tmp;&#125; void main(void)&#123; printf("%s",test());&#125; 在数组tmp[30]前面加入了static关键字，它就使得tmp[30]存放在内存中的静态存储区中，所占用的存储单元一直不释放，直到整个程序运行结束。所以当主函数调用完print()函数后，该空间依然存在。所以main()函数中接到首地值后可以访问数组中的元素。 2. 结构体作为返回值 123456789101112131415161718192021#include "stdio.h"#include "string.h"struct ret&#123; char buf[30];&#125;; struct ret test(char *tmp)&#123; struct ret a; strcpy(a.buf,tmp); return a;&#125;void main(void)&#123; struct ret b; b=test("用结构体作为返回值传递数组"); printf("%s",b.buf);&#125; 两点注意： 1、数组之间的赋值不要直接，即不要直接将数组 A 赋给数组 B，而是要用strcpy（字符型数组）或者memcpy（非字符型数组）。 2、用结构体定义变量和函数时不要忘了结构体名（上面程序的ret）。 Reference[1] 【原】C语言函数返回数组的问题 http://www.cnblogs.com/wuqi1003/archive/2013/01/09/2853657.html[2] C语言中字符串如何转换为二进制、八进制、十进制、十六进制 http://blog.csdn.net/edonlii/article/details/9162769[3] C语言之strcat函数 http://blog.csdn.net/hgj125073/article/details/8439448[4] C语言strcmp()函数：比较字符串（区分大小写） http://c.biancheng.net/cpp/html/162.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[语法] @property 中的常用关键字分析]]></title>
      <url>https://amywushu.github.io/2016/09/08/%E8%AF%AD%E6%B3%95-property-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[我搬进鸟的眼睛，经常盯着路过的风。 栈与堆首先，我们需要知道：为什么只有OC对象需要进行内存管理，而其它非对象类型（如基本数据类型）不需要我们来管理呢？ 因为： Objective-C 的对象在内存中是以堆的方式分配空间的 堆里面的内存是动态分配的，所以也就需要程序员手动的去添加内存、回收内存 OC对象存放于堆里面(堆内存要程序员手动回收，也就是 release ) 非OC对象一般放在栈里面(栈内存会被系统自动回收) 例如： 123int a = 10;int b = 20;Car *c = [[Car alloc] init]; 我们知道OC对象一般都是指针形式，大神ibireme在 Objective-C 中的类和对象中提到： 凡是首地址是*isa的struct指针，都可以被认为是objc中的对象。运行时可以通过isa指针，查找到该对象是属于什么类(Class)。 下图可以清楚的表示 OC 中的堆栈分配： assign 与 weak 基础知识提要 @property 声明的属性，会自动创建 getter,setter 方法。 属性中申明的关键字主要有三大类： readwrite/readonly： 是否生成 setter 方法, 默认 readwrite assign/weak/strong/copy/retain： setter 方法中如何传递所有权等内存管理策略, ARC 环境默认为 strong nonatomic/atomic：是否加线程锁（并不能完全控制线程访问，最好事是自己手动底层加锁，默认 atomic NSString 的引用计数LLVM是有优化的，并不是简单根据设定的关键字来判断。本文只是为了方便易懂，以这个类作为例子。 assign如果设置 assign ，在 setter 方法中是这样的： 123- (void)setCarName:(NSString *)name &#123; _carName = name; //默认是有下划线的&#125; 也就是说成员变量 _name 并没有获得 name 所指的对象的所有权，原来对象 @“Amywushu” 的 retainCount 不会改变。一旦 name 被释放，_carName 也就不再指向一个合法的位置，出现指针悬空，如下图所示，相当于 _carName （图中为 carName ）指向的 name，但实际上 _carName 是指向OC对象的，这里只是为了方便理解。 assign/weak 的区别ARC 中 OC 对象已经不再使用 assign 了，而是使用 weak ，两者的区别在： weak 弱引用所指的对象没有被任何strong指针指向，那么就将被销毁，所有指向这个对象的 weak 指针也将被置为 nil 。而 assign 不会被置为 nil 。但对于非 OC 对象来讲，因为其存储空间在栈上，由系统管理内存，所以一般还是使用 assign。 unsafe_unretainedunsafe_unretained 的语义与 assign 类似，相当于用于 OC 对象类型的 assign 。使用这个关键字主要出于性能考虑，因为 weak 对性能有一些影响，因此对性能要求高的地方可以考虑使用 unsafe_unretained 替换 weak 。比如 YYModel 的实现，为了追求更高的性能，其中大量使用 unsafe_unretained 作为变量标识符。 retain 与 strong 知识点: MRR内存管理基本原则 为创建的所有对象设置所有权 应使用retain方法获取对象（你尚未拥有）的所有权 当不再使用某个对象时，必须放弃其所有权 不能放弃不归你所有的对象的所有权 123456789101112//对象通过 alloc 消息创建后，变量 atom 就拥有了该对象的所有权（原则1）Atom *atom = [[Atom alloc] init];//变量 href 获取了这个对象的所有权（原则2），不能写成 Atom *href = atom; //这样写的话 href 没有获取对象的所有权，一旦 atom 释放了，href 就不再指向一个合法的位置，出现指针悬空。Atom *href = [atom retain];// 变量 atom 释放，但 href 依旧拥有该对象的所有权[atom release];// 变量 href 释放，对象引用计数变为 0 ，运行时系统可以释放对象了[href release]; ——引用自[精通Objective-C]内存管理 如果设置 retain ，在 setter 方法中是这样的： 123456- (void)setCarName:(NSString *)name &#123; if (_carName != name) &#123; [_carName release]; _carName = [name retain]; &#125;&#125; 也就是说，retain/strong 会在 setter 方法中，对传入的对象 &quot;Amywushu&quot; 进行引用计数 +1 的操作。简单来说，就是会拥有传入对象 &quot;Amywushu&quot; 的所有权，而不是像 assign/weak 一样，依赖于传入的对象指针 name ，而并非拥有实际所有权。 相当于一个保险柜拥有两把钥匙，变量解除所有权 (release) ，也就相当于归还钥匙。当两把钥匙都被归还之后，这个保险柜（对象）也就会被释放。只要拥有该对象的所有权（至少有一把钥匙没有归还），这个对象就不会被释放。 如图所示，_carName 和 name 均拥有对 Amywushu 这个字符串对象的所有权，该对象的引用计数变为 1+1=2 。 strong 是在 iOS 引入 ARC 的时候引入的关键字，是retain的一个可选的替代。 strong 跟 retain 的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。 关于 strong 和 weak 还有什么不清楚的话，可以学习 onevcat 的手把手教你ARC——iOS/Mac开发ARC入门和使用这篇文章，讲得非常清晰易懂。 copy 与 mutableCopycopy 、mutableCopy 与 strong 的区别在于，深拷贝时，示例变量对于传入对象的副本拥有所有权，而不是对象本身；浅拷贝时，则没有区别。如果设置 copy ，在 setter 方法中是这样的： 123456- (void)setCarName:(NSString *)name &#123; if (_carName != name) &#123; [_carName release]; _carName = [name copy]; &#125;&#125; 如上图所示，原来对象的 retainCount 不变，新 copy 出来的对象副本的 retainCount=1 ，原对象引用计数不变，两者 copy 之后互不相关，这是深拷贝。 深拷贝与浅拷贝 深拷贝： 是对内存空间的拷贝，也就是这里的 copy（数组等类型例外）浅拷贝： 是对内存地址的拷贝，也就是上面的 retain/strong，以及 copy 的某些情况深拷贝和浅拷贝比较复杂，我的另一篇文章有具体讲解[语法] copy 与 mutableCopy（传说中的深浅拷贝），这里只是简要提及一下。 注意！ 如果是 copy 的是一个 NSArray 呢? 比如： 12NSArray *array = [NSArray arrayWithObjects:@"hello",@"world",@"baby"];NSArray *array2 = [array copy]; 这个时候,系统的确是为 array2 开辟了一块内存空间,但是我们要知道的是, array2 中的每个元素,,只是 copy 了指向 array 中相对应元素的指针，这是“单层深拷贝”. 一般来说，不要将 copy 用到 NSMutableString ，NSMutableArray ，NSMutableDictionary 等可变对象上，除非有特别的需求。 例如: 1234567891011121314@interface ViewController ()@property (nonatomic, copy) NSMutableArray *mutableArray_copy;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray *mutableArray = [NSMutableArray arrayWithObject:@"123"]; self.mutableArray_copy = mutableArray; [self.mutableArray_copy addObject:@"456"];&#125; 运行则会报出错误 signal SIGABRT 我们明明在代码里用的 NSMutableArray 这个可变数组，为什么错误里会说是在向 NSArray 这个不可变数组，调用 addObject: 这个方法呢？（ __NSArrayI 表示的是 NSArray 类型）。是因为在 self.mutableArray_copy = mutableArray; 这一句的时候，会调用 mutableArray_copy 的 setter 方法， copy 属性默认 setter 方法是这样写的: 123- (void)setMutableArray_copy:(NSMutableArray *)mutableArray_copy &#123; _mutableArray_copy = [mutableArray_copy copy];&#125; setter 方法里调用的是 copy，而不是 mutableCopy ，也就是说拷贝过来的是不可变的 NSArray 类型。那么 NSMutableArray 的添加元素等方法自然就不能使用了。解决方法为：将 copy 改为 strong ；或者重写 setter 方法，将 copy 改为 mutableCopy 。 copy 现在都比较少用，一般用于 NSString 。因为父类指针可以指向子类对象，NSMutableNSString 是 NSString 的子类，使用 strong 的话虽然 NSString 是不可变对象，但是它传入的值可能会是 NSMutableString 可变对象，如果这个可变对象的内容在其他地方被修改了，那 NSString 指针所指的对象也随之改变了，而其本身可能对此毫不知情。因此一般用 copy 。 nonull nullable null_resettable这三个属性关键字是 WWDC2015 中介绍的 OC 新特性，与 Swift 中的 ? 和 ! 类似。 nonull：该属性不能为 nil ,必须有值。 nullable：表示可选的，可以为 nil。 null_resettable：表示 setter 方法是 nullable ,可以为 nil；而 getter 方法是nonull ，必须有值。 总结总的来说，就是内存处理方式不一样，assign/weak 相当于借用传入的指针变量来指向对象（实际上并不是，可以这样理解），retain/strong 相当于不同的指针变量指向同一个对象，copy 则是在内存里复制了一个对象并指向它。读写属性以及原子性比较简单，不再赘述。 关于 atomic 的锁机制，以及 ARC 机制到底如何进行的内存管理，之后会进一步学习。敬请期待。 Reference[1] Objective-C 内存管理——你需要知道的一切 https://segmentfault.com/a/1190000004943276 [2] @property属性关键字详解 http://www.wugaojun.com/blog/2015/07/25/at-propertyshu-xing-guan-jian-zi-xiang-jie/ [3] Objective-C 的自动引用计数（ARC） https://hran.me/archives/objective-c-automatic-reference-counting.html [4] Objective-c 内存管理的历史和参考资料 http://www.pchou.info/ios/2015/06/05/oc-memory-management.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[源码学习] AFNetworking 3.1.0 第一部分]]></title>
      <url>https://amywushu.github.io/2016/09/06/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-AFNetworking-3.1.0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.html</url>
      <content type="text"><![CDATA[空山新雨后，天气晚来秋。 写在前面我主要根据作者polobymulberry的博客AFNetworking源码阅读系列来学习，因为我有很多知识不懂，所以有些地方可能会记录得过于繁琐。原作者的大体流程和记录不变，某些知识点会有自己的补充。在此非常感谢博客作者polobymulberry的分享。 第一次运行运行example时总是出现 Module ‘AFNetworking’ not found 问题，查了好多关于Module的资料，对于问题的解决却没有帮助，后来偶然间在AFNetworking的github上的issues里找到解决办法，真是特别惭愧。应该点击文件夹内的AFNetworking.xcworkspace，而不是其他.xcodeproj文件。 图片1 运行成功后，就开始我们艰难的学习旅程吧！ 开始AppDelegate此文件主要就是实现函数didFinishLaunchingWithOptions。将windows的rootViewController设置为rootViewController为GlobaltimelineViewController的NavigationController。此处有两点需要注意一下： 第一处 NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024 diskCapacity:20 * 1024 * 1024 diskPath:nil]; [NSURLCache setSharedURLCache:URLCache]; NSURLCache 为您的应用的 URL 请求提供了内存中（对应memoryCapacity）以及磁盘上（对应diskCapacity）的综合缓存机制。所以你想使用NSURLCache带来的好处，就需要在此处设置一个sharedURLCache。 第二处 [[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES]; 为了说明AFNetworkingActivityIndicator是什么，直接上图： 图2 当你有session task正在运行时，这个小菊花就会转啊转。这个是自动检测的，只需要你设置AFNetworkingActivityIndicatorManager的sharedManager中的enabled设为YES即可。 这里我简单看了下AFNetworkingActivityIndicatorManager，发现它对外接口不多，比较容易理解它的业务流程。所以我准备在第三部分就将AFNetworkingActivityIndicatorManager的源码拿下。 设置完了cache和AFNetworkingActivityIndicator，接着就是进入GlobalTimelineViewController（UITableViewController）了。这里我学到一个，就是UITableViewController可以使用initWithStyle进行初始化。（因为我对iOS界面不太了解，所以这个initWithStyle现在并不懂） polobymulberry在开篇画了一个iOS Example的代码结构图，我不太懂MVC，特地查了下。以下是我个人非常粗浅的了解： M代表Model，V代表View，C代表Cotroller。这是一种设计模式，是想让各模块分离，视图跟数据处理以及中间的控制协调端各司其职。 视图只用于展现APP的界面，用于人和程序的交互。至于你点击按钮后产生的反馈，是由Controller来传递给Model处理，比如点击按钮后，会在文本框内展现文字。则Model从数据库中读取文字并通知Controller，事件已经处理完，Controller收到通知然后决定怎么处理，比如通过outlet控制View展示文字。 注意View和Model之间并不直接通信。 图3 参考自实际案例讲解iOS设计模式——MVC模式 GlobalTimelineViewController主要是围绕UITableView的delegate和dataSource来说。 1) UITableViewDelegate主要是计算heightForRowAtIndexPath这个函数比较麻烦（应该是-(CGFloat)tableView:heightForRowAtIndexPath:函数），这里的Cell比较简单，可以直接使用posts中存储的text值来计算高度，核心代码就下面这句： CGRect rectToFit = [text boundingRectWithSize:CGSizeMake(240.0f, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName: [UIFont systemFontOfSize:12.0f]} context:nil]; 对于boundingRectWithSize的使用又增进了一步。（这里我也不懂） 2) UITableViewDataSource主要是用posts作为数据源，而posts的获取在此处尤为关键，是通过Post本身（model）的globalTimelinePostsWithBlock函数获取数据的，这里作者将网络端的请求放在了model里面。 接着调用了refreshControl控件的setRefreshingWithStateOfTask:。setRefreshingWithStateOfTask:其实是UIRefreshControl+AFNetworking的一个category中定义的。UIRefreshControl+AFNetworking的源码很简单，放在第四部分讲。 注意setRefreshingWithStateOfTask:有一个参数就是NSURLSessionTask*。而这个NSURLSessionTask的获取是调用了Post类中的globalTimelinePostsWithBlock:函数。 在globalTimelinePostsWithBlock:函数中其实封装了一层AFHTTPSessionManager的GET函数 - (nullable NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; 具体细节后面讨论，此处我们知道是根据一个url获取到服务器端的数据即可。注意获取到的数据是JSON格式的，这里作者在Post类，即Model中定义了一个JSON—-&gt;Model函数-initWithAttributes，，也就是说模型数据转化部分也放在了model中。 另外，调用GET方法不是直接用AFHTTPSessionManager的manager，而是又定义了一个AFAppDotNetAPIClient，继承自AFHTTPSessionManager。并在其定义的单例模式中简单地封装了一些AFHTTPSessionManager的设置。 + (instancetype)sharedClient { static AFAppDotNetAPIClient *_sharedClient = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 初始化HTTP Client的base url，此处为@&quot;https://api.app.net/&quot; _sharedClient = [[AFAppDotNetAPIClient alloc] initWithBaseURL:[NSURL URLWithString:AFAppDotNetAPIBaseURLString]]; // 设置HTTP Client的安全策略为AFSSLPinningModeNone _sharedClient.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone]; }); return _sharedClient; } 知识点：SSL Pinning Https对比Http已经很安全，但在建立安全链接的过程中，可能遭受中间人攻击。防御这种类型攻击的最直接方式是Client使用者能正确鉴定Server发的证书【目前很多浏览器在这方面做的足够好，用户只要不在遇到警告时还继续其中的危险操作】，而对于Client的开发者而言，一种方式保持一个可信的根证书颁发机构列表，确认可信的证书，警告或阻止不是可信根证书颁发机构颁发的证书。 SSL Pinning其实就是证书绑定，一般浏览器的做法是信任可信根证书颁发机构颁发的证书，但在移动端【非浏览器的桌面应用亦如此】，应用只和少数的几个Server有交互，所以可以做得更极致点，直接就在应用内保留需要使用的具体Server的证书。对于iOS开发者而言，如果使用AFNetwoking作为网络库，那么要做到这点就很方便，直接证书作为资源打包进去就好，AFNetworking会自动加载，具体代码就不贴了，nsscreencast已经有很好的tutorial。 至于model根据网络层获取的数据赋值，除了user的头像那块比较难，因为涉及到UIImageView+AFNetworking等文件，其他部分很简单。而AFNetworking的UIImageView+AFNetworking的部分其实很类似SDWebImage的思路。 Add：BLock作为函数参数block原本的形式为: 返回值 (^block名称 可省) (参数 可省) ＝ ^{函数体};调用形式： block名称(参数); 在GlobalTimelineViewController.m - (void)reload: 函数中遇到了第一个block NSURLSessionTask *task = [Post globalTimelinePostsWithBlock:^(NSArray *posts, NSError *error) { if (!error) { self.posts = posts; [self.tableView reloadData]; } }]; ^(NSArray *posts, NSError *error){} 整个block作为参数传递给+ (NSURLSessionDataTask *)globalTimelinePostsWithBlock:函数 参数传递只需要 ^(参数){block函数体} ^表明是block形式 Post.m + (NSURLSessionDataTask *)globalTimelinePostsWithBlock:函数: + (NSURLSessionDataTask *)globalTimelinePostsWithBlock:(void (^)(NSArray *posts, NSError *error))block { ...... } 即这个函数的参数为(void (^)(NSArray posts, NSError error))block (返回值 (^)(参数))block名称 也就是说在block作为函数参数传递时，定义block的这个A函数(globalTimelinePostsWithBlock:)并没有block函数体，而是调用A函数([Post globalTimelinePostsWithBlock:])在传参数时定义block的具体执行内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[（译） iOS Kernel Heap Armageddon —— Stefan Esser]]></title>
      <url>https://amywushu.github.io/2016/08/29/%E8%AF%91-iOS-Kernel-Heap-Armageddon.html</url>
      <content type="text"><![CDATA[人世间最让你感动的是什么？ ——是遥远的相似性 摘要你所了解到的关于 iOS 内核堆利用的公开研究，最终都可以归结于对内核堆空间的分配，这个观点由 nemo 首先提出来。总而言之，这种分配将空间内的内核内存分成相同大小的内存块。通过利用重写堆元数据，可以向空间的空闲列表 (freelist) 中注入任意内存区。 在本文中，我们将首先概括关于内核堆空间分配的知识，像 nemo 和 Esser 之前所提到的那样。接着，我们将看一看其他的内核堆管理以及 Mac OSX 和 iOS 内核中的内存分配封装函数。在简单介绍这些封装函数之后，我们将进一步介绍这些分配器在最新版本 iOS 5 之后的改变。本文将继续介绍内核层的应用数据重写与直接攻击分配器的空闲列表区之间的差异。最后将展示一种普遍的技术：为了实现内核堆利用，通过执行内核堆喷射 (heap spraying) ，来控制内核堆布局的布局。 内核堆空间分配对于 Mac OSX 以及越狱的苹果手机，有一种可用的工具叫做 zprint ，它可以查看由内核堆分配器注册的内核内存空间。例如： 这些信息都是由内核 API 函数 host_zone_info 以及 mach_zone_info 提供的。当涉及到构造内核堆利用方法时，这些 API 函数都非常有用，因为它们可以检索每个内核空间的详细信息，比如分配的块的数量，空闲内存块的数量等。Sotirov提到：后者对于控制内核堆（又称为堆风水）技术非常有用。但是根据苹果 iOS 6 的介绍，为了防止内核 API 函数被用于工厂 设备iPhone ，这条路已经被关闭了。现在调用 PE_i_can_haz_debugger 函数，在越狱机以及特殊的苹果内部调试设备、通过苹果可能有的特殊调试虚拟磁盘启动的设备上，只会返回 true。不管怎样，以后的内核堆利用已经不能再依赖这些函数了。 为了弄清楚内核堆分配器是如何工作的，我们可以通过下面的图表了解，这些图表将会一步步记录其内部的运行。分配器将内核内存分成了许多空间，每个空间包含了同样大小的内存块。它首先在空间内分配一大块内存（通常是一个单独的内存页）。 所有的内存都在这个空间里，然后它被分为大小相同的块。在这个例子中，每块内存正好为 512bytes 。 内存管理器用每个空闲内存块的 4 个首字节作为指向另一个内存块的指针。如下图所示： 空间分配器创建了一个空闲内存块链表，即空闲列表。它是一个后进先出的列表，在链表内，每个元素都指向下一个元素。因为在新的内存页里的第一个空闲内存块首先被添加，正如下图所示，空闲内存将会被反序利用。 某特定空间的最后一个元素被添加到空闲列表后，当内存被分配给这个特定空间时，该元素也被称为空闲列表头部，同时作为分配内存块标识返回。返回新分配的内存之后，空闲列表中下一个元素的指针从内存块的首4字节读取。指针读取成为新的自由列表头部。它指向的内存块将会因此成为下一个返回值。这个原则由下图证实。 现在我们知道了堆空间分配的基本机制，接下来我们介绍一下如何利用这种内存分配。我们发现，两个相邻的内存块，第一个为分配缓存区，第二个为空闲内存块，缓存区溢出将会导致堆元数据被覆盖。 如果攻击者控制了缓存区溢出的数据，那么他完全可以控制空闲列表中指向下一个元素的指针。如上所述的分配将会返回被重写的内存块，使得攻击者控制空闲列表的头部指针。之后分配器将会返回一个被攻击者控制的内存块。在公开的 iOS 内核堆利用中，这种技术被用来返回位于系统调用表中间的一块内存。通过强制内核分配一块内存，并用被攻击者控制的数据覆盖，这种方式可以替换任意系统调用处理程序，并实现任意内核代码执行。 据了解， iOS 6 的测试版在内核堆分配器中添加了一些内存标签，虽然一般来说，它不阻止攻击空闲列表，但是阻止公开地使用攻击，因为它只允许向内核的空闲列表中注入内存块，但是这样也已经完全在攻击者的控制之下了。 其他内核堆内存管理和封装器Mac OSX 和 iOS 内核包含了许多其他的内核堆内存管理以及封装。下图展示了其中一部分的封装和内存管理。 在本节中，我们将介绍几个提到的分配器和封装，并讨论它们的属性以及利用。 kalloc() kalloc() 是用来封装 zalloc() 以及 kmem_alloc() 的。它在小分配时使用 zalloc() ，较大的内存请求时使用 kmem_alloc() 。它没有任何额外的堆元数据。因此，需要调用者记住分配的内存大小，当稍后内存使用 kfree() 释放时要求使用相同大小的值。 存储在内核空间的数据由内存管理器注册一个空间号码，这个号码为 kalloc.xxx ，xxx 即为 kalloc 空间大小。在 iOS 5 中可使用 zprint 工具得到以下空间。(译者注：在OS X 10.11 及以上系统可在 root 权限下使用 zprint | grep kalloc 命令) 可以从中发现，这个内核空间是在 8 到 8192 之间的每2倍大小再加上一些额外的空间值，这些额外值的大小是2倍之间可被8整除的数。比如 kalloc.24, kalloc.40, kalloc.48, kalloc.88, kalloc.112, kalloc.192, kalloc.384, kalloc.768, kalloc.1536, kalloc.3072 以及 kalloc.6144 。在 iOS 5 之前，这些 kalloc 空间并不存在，且最小的空间为 16 。这种增加空间的变化可能是为了减少内存浪费，以便使得最常用的分配越来越合适。 kfree() 在跳转到下一个封装之前，还有一些值得注意的地方，kfree() 函数。正如之前所提到的那样，调用者需要记住需要释放的块的大小，否则 kfree() 不知道 zfree() 或 kmem_free() 是否被调用，以及需要向内存返回多大的空间。内存管理器除了保持对较大的分配内存块的跟踪之外，对于释放一个比之前所记忆值大的块的尝试将会被忽略。这是一个简单的保护机制防止二次释放。 _MALLOC() _MALLOC() 是一个对 kalloc() 函数的封装。对于分配的内存块它预先留下一个简短的头部，存储分配的大小。这种通过 _MALLOC() 进行内存分配的方式，在内核代码中可以在不需要保持对块大小的跟踪的情况下释放。下图是一个通过系统调用的内存分配例子。 0字节的分配是特例。_MALLOC() 会简单拒绝这样的分配并返回一个空指针。目前尚不知道为什么苹果不返回一个最小大小的分配值，因为分配 0 字节是可以在合理条件下发生的。用大小作为头部有两个缺点，第一为了确定分配的大小，它要求有整数加法，第二当重写导致可执行的情况，它相当于额外的堆元数据。 当看到 iOS 4 中的 XNU源代码树中的源代码，可以发现 _MALLOC() 中整数加法的危险是显而易见的。正如下面代码所示，苹果并没有设定在 iOS 4 以及 Mac OSX 中的整数溢出，这将会导致许多可能的内核堆错误。 但是在 iOS 5 的 release 版本之前，苹果研究了可能的整数溢出并关闭了它。代码改为捕捉整数溢出，防止在非阻塞情况下，溢出流返回空指针。但是在阻塞情况下，可以看到触发了内核 panic。 包含了额外大小字段的内存块头部，对于重写来说，是一个非常有趣的目标，因为通过重写它，内存管理器可以被欺骗去释放错误区域的空闲列表中的内存块。如果大小被重写为一个更小的值，这个块也将会被添加到更小尺寸的块的空闲列表中。这不会导致内存错误，但将会导致内存泄漏，因为稍长的那部分永远不会被覆盖。同样，如果一个较大的尺寸被写入头部，这个块也会被添加到较大尺寸块的自由列表中。这样将会导致内存错误，因为内核分配相信块比实际尺寸大，而这将会导致它在填满时覆盖到相邻的内存。 内核堆应用数据重写考虑到苹果正在硬化空间分配器，一些内存分配器也将不再会有流入的堆元数据可以被覆盖，因此我们将要介绍一种有攻击性且有趣的存储在堆上的内核应用数据。本节的剩余部分，我们将使用内核层的 C++ 对象作为这种有趣的可以被广泛使用的应用数据的示例。 在 iOS 内核中的 libkern 实现了一个 C++ 运行时子集。它允许内核驱动程序用 C++ 写，其中 IOKit 驱动使用最为频繁。这太有意思了，因为它为 iOS 内核带来了 C++ 类的漏洞。但是对于我们来说，只有在内存布局中的类是有意义的 下图展示了一个支持 iOS 内核的 C++ 运行时以及继承的基本对象的概述： 正如你所看见的，所有的这些类都是由基类 OSObject 分发而来的。接下来我们将要更进一步查看这些类的内存排布。可以看到 OSObject 由一个 vtable ptr 和一个引用计数器组成： vtable ptr 指向内核的数据段，即对象的方法表的存储位置。另一方面，引用计数器要稍微复杂一点。它是一个将 16bit 引用计数存储在低 16 位的 32bit 值。用高 16 位计数对象在集合中的频率，作为第二参考计数。貌似设计的最初目的是用来调试，因为集合计数看起来只能用来验证正常引用计数不低于集合计数。如果是这样，则任何情况都能导致内核 panic 被触发。引用计数器特别的一点是它有一个内置的整数溢出保护。如果引用计数器的值达到65534，则计数器将会被冻结，意味着它将既不会增加，也不会再减少。因此该对象不再可以被破坏，它的内存也不会被释放。 为了明白 iOS 内核对象重写是如何被利用的，首先需要弄清楚在内存中一个 OSObject 的每个部分被重写的影响。如果可以重写 vtable ptr，则可以改变用于查找对象方法的表中的地址。一旦这个指针被重写了对象上的每一个执行操作，将会导致任意内核代码执行。如果引用计数器被重写，将会允许将引用计数器设置为一个小于现有的实际引用计数的值。同时允许释放之前的对象，这将会导致一种典型用法，即通过悬挂引用引起的任意利用。一旦释放了下一个相同大小的分配内存，则对象的内容将会被完全替换。 在 iOS 内核中， OSObject 是一个最简单的 C++ 对象。其他对象比如 OSString 则更复杂一些，包含有更多数量或者更多不同类型的属性。进一步分析它们的内存布局也将会因此变得有趣。首先，让我们看看 OSString 对象，它的内存布局如下图所示。 除了 OSObject 中已知的属性外，flags，length 和 string ptr 三个是新增的。flags 只是控制对象内部的字符串指针是否在其被销毁时释放。这通常只在其他的字段同时被重写时有用。更有用一点的是 length 字段。如果字符串的长度被改变为一个大于原始值的数值，则会导致内核堆信息泄漏或者破坏的内存错误。内存错误是由于长度太大，进而导致长度较小的内存块被添加到错误的内核堆空间的空闲列表里。如果被释放的内存在之后重新分配，则返回的指针将会指向一个实际小于预期的内存块。当内核中的这个小内存块被数据填满时，多余的数据则会重写到相邻的内存中。最后一个字段可以被字符串指针自身重写。同样，该指针被重写，也会导致内核堆信息泄漏或者破坏的内存错误。这种情况下，攻击者可以向特殊空间的空闲列表注入一段任意内存地址，一旦那段内存被内核重新分配然后填满，将导致内存破坏。 另外一个有意思的重写对象是 OSArray 。它包括了更多的属性，因此也提供了一些新的有趣的重写可能性。让我们看一下 OSArray 对象的内存布局： updateStamp, reserved 以及 fOptions 字段对于重写来说没有什么用处，因为它们不能导致有用的可利用的场景。但是其他的字段都可以。count, capacity 和 capacityIncrement 字段都是由 kalloc() 分配的内存的值。重写这些值将会混淆内存，使得它分配或者再分配错误数量的内存。这种做法将会导致内核堆信息泄漏或者破坏的内存错误。最后一个字段 array ptr 是来自于 OSObject 的对象指针。重写它使得内核可以访问任意构造的对象，从而导致内核里的任意代码执行。另一种攻击是直接重写存储数据的内存块。 我们对于 重写 iOS 内核的 C++ 对象的内存布局，以及由此产生的可行性做了一个简单概述。记住这些信息，在下一节中，我们将利用这些对象来填充 iOS 内核堆并控制它的布局。 控制 iOS 内核堆要成功利用内核堆错误，则要求将内核堆从一个未知起点通过可控制的方式指向一个可预测的状态。对于这个需求，有很多不同的技术方法。其中最简单的方法叫做堆喷射 ( heap spraying ) ，即使用特殊的数据通过重复触发相同的分配来填充内存，直到内存中很大比例都被这种模式充满（或者触发另一个终止条件）。为了实现堆喷射，要求有一个分配基元来重复执行。由于这种技术早在 2001 年之前就已经开始使用，所以谁是堆喷射的最初发明者尚未可知。 A.Sotirov 在2007年提出了一个更复杂更好的用来控制堆状态的技术，叫做堆风水。在他的黑帽子谈话中，他描述了如何从未知状态的堆得到被控制的内存布局。首先需要重复分配内存来填充堆中的空洞。一旦所有的空洞都被封闭了，则进一步的分配将会使得彼此相邻。在这些相邻的区域释放内存块，将会在可控位置戳一些洞，使得接下来的分配都在这些洞的位置上。这种方式可以控制堆布局，即溢出缓存区将会正好溢出我们想要溢出的数据。当然，实现一个堆风水技术也要比堆喷射更复杂，它不仅需要一个分配基元，还需要一个回收基元。 在以前的公开 iOS 内核利用中，分配以及回收基元通常是特殊的，且依赖于实际的开发功能。在此，我们将介绍一个更为通用的方法，可以在没有易被攻击的特殊分配和回收基元的条件下，控制内核堆。 iOS 内核有一个非常有趣的函数叫做 OSUnserializeXML()。它由许多 IOKit API 中的函数来调用，被用于将对象从用户空间传送到内核空间。这个函数以 XML.plist 的格式 提供一个输入，可以是数字，布尔量，字符串，数据，字典，数组，集合和引用。下面是一个 XML plist 的例子。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;IsThere&lt;/key&gt; &lt;string&gt;one technique to rule them all?&lt;/string&gt; &lt;key&gt;Answer&lt;/key&gt; &lt;true /&gt; &lt;key&gt;Audience&lt;/key&gt; &lt;string&gt;meet OSUnserializeXML()&lt;/string&gt; &lt;/dict&gt; &lt;/plist&gt; 通过构建这样一个 XML.plist 数据包，可以在内存中创建任意对象集合，以及在所有大小和形状中，分配任意数量的不同类型的对象。我们可以用它来控制内核堆，以任何我们喜欢的方式。下表是一个基本对象的内存大小的备忘清单。 现在我们来看一下如何构造 XML 数据，使其实现堆喷射和堆风水。 重复分配 我们首先需要做的是分配任意大小任意数量的内存块。不幸的是，在 XML.plist 数据块内部进行循环是不可能的。但是也没有限制，因此我们可以按照我们的想法分配尽可能多的数据。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;ThisIsOurArray&lt;/key&gt; &lt;array&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;...&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 这个示例使用一个数组对象，并填充任意数量的字符串。为了做一个内核堆喷射，我们只需要构建一个非常庞大的 XML 数据对象，并传给一个合适的 IOKit API 函数。 分配受攻击者控制的数据 在 iOS 内核堆喷射中，使用字符串数据对象的缺点是，不能包含空字节。因此，用完全任意数据结构的字符串对象来实现堆喷射是不可行的。不过我们还有数据对象可以施以援手。由于数据是 base64 编码的，所以它允许创建任意数据结构，没有字符值的限制。另外，内核也支持简单的 16 进制。比如下面的例子。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;ThisIsOurData&lt;/key&gt; &lt;array&gt; &lt;data&gt;VGhpcyBJcyBPdXIgRGF0YSB3aXRoIGEgTlVMPgA8+ADw=&lt;/data&gt; &lt;data format=&quot;hex&quot;&gt;00112233445566778899aabbccddeeff&lt;/data&gt; &lt;data&gt;...&lt;/data&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 数据对象类型也更方便，因为它读取到4049块中，因此在解码 XML 时，它在我们感兴趣的内存空间中不分配块。通过结合数组和数据，我们可以执行内核水平的堆喷射。堆风水需要更多的控制条件，接下来我们会提到。 用应用数据填充任意大小的内存块 对于堆风水，我们不仅需要分配任意大小的内存块，还需要在重写导致的任意代码执行时，分配被数据填充的任意大小内存块。对于此，我们再次使用数据对象类型（当然也可以使用字典对象类型）。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;ThisArrayAllocates_4_Bytes&lt;/key&gt; &lt;array&gt; &lt;true /&gt; &lt;/array&gt; &lt;key&gt;ThisArrayAllocates_12_Bytes&lt;/key&gt; &lt;array&gt; &lt;true /&gt;&lt;true /&gt;&lt;true /&gt; &lt;/array&gt; &lt;key&gt;ThisArrayAllocates_28_Bytes&lt;/key&gt; &lt;array&gt; &lt;true /&gt;&lt;true /&gt;&lt;true &gt;&lt;true /&gt;&lt;true /&gt;&lt;true /&gt;&lt;true /&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 在这个示例中，我们使用分配的数组来填充内存，并指向布尔对象。布尔量不会是单独的分配内存的对象。相反，它们会增加一个 global true 对象的引用计数。如果通过重写它向内核提供我们精心设计的对象，则会导致任意代码执行。字典对象类型可用于这种攻击。不同的是，在这个例子中，单个对象指针的乘数为 4，在字典中是 8，因为存储了 键值 (key) 和数值 (value) 对象的指针。 在分配区域戳洞 实现对内核堆完全控制的最后一件事是不仅需要分配任意大小的内存块，还需要能够在这些分配中戳任意大小的洞。在字典对象的帮助下，我们可以了解如何在已分配的内存中戳洞，请看下面的示例。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;AAAA&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA &lt;/data&gt; &lt;key&gt;BBBB&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA &lt;/data&gt; &lt;key&gt;CCCC&lt;/key&gt; &lt;data&gt;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ &lt;/data&gt; &lt;key&gt;DDDD&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA &lt;/data&gt; &lt;key&gt;EEEE&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA &lt;/data&gt; &lt;key&gt;CCCC&lt;/key&gt; &lt;true /&gt; &lt;/dict&gt; &lt;/plist&gt; 在这个例子中，可以看到键值 CCCC 被设定了两次。第一次是插入到字典中，第二次更新键值的数值，且前一个值已被破坏。这个数据对象的破坏将会释放该数值对象本身，以及释放由 base64 编码重复的 Z 字符所组成的数值。我们也因此在内存中有效地戳了一个洞。拼图的最后一块是你构建的用于控制堆的 XML.plist 文件是没有问题的。 总结本文中我们首先重演了 iOS 内核堆空间分配，以及不同作者在之前所提到的它的利用。接着，我们介绍了其他的内核堆分配器以及它们所带来的额外的堆元数据。我们讨论了如何重写这些可以被利用的数据，以及提到了这些分配器目前的变化。接下来我们离内核堆元数据结构的利用只有一步之遥，我们讨论了 iOS C++ 内核对象，以及他们在内存结构的布局和在内存中重写他们可以得到什么。最后，我们介绍一种通用的技术，利用 OSUnserializeXML() 可以实现堆喷射和堆风水。这种新技术不仅可以使用任意数据喷射堆来完全控制它的布局，也可以使用有意思的内核应用数据来填充内核堆，该应用数据采用内核级别的 C++ 对象形式，一旦重写，将会允许任意代码执行。 References[1] E. PERLA, M. OLDANI, ”A GUIDE TO KERNEL EXPLOITATION - ATTACKING THE CORE”, 2010, HTTP://WWW.ATTACKINGTHECORE.COM/ [2] S. ESSER, ”IOS KERNEL EXPLOITATION, BLACKHAT USA”, 2011 HTTPS://MEDIA.BLACKHAT.COM/BH-US- 11/ESSER/BH_US_11_ESSER_EXPLOITING_THE_IOS_KERNEL_WP.PDF [3] C. MILLER, D. BLAZAKIS, D. DAIZOVI, S. ESSER, V. IOZZO, R.-P. WEINMANN, ”IOS HACKER’S HANDBOOK”, 2012, HTTP://EU.WILEY.COM/WILEYCDA/WILEYTITLE/PRODUCTCD-1118204123,DESCCD- DESCRIPTION.HTML [4] A. SOTIROV, ”HEAP FENG SHUI IN JAVASCRIPT, BLACKHAT EUROPE”, 2007 HTTPS://WWW.BLACKHAT.COM/PRESENTATIONS/BH-USA-07/SOTIROV/WHITEPAPER/BH- USA-07-SOTIROV-WP.PDF]]></content>
    </entry>

    
  
  
</search>
